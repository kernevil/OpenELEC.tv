diff --git a/.gitignore b/.gitignore
index 9b4f7f0..8555e6a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,6 @@
 # global patterns
 testMain
+appkey.h
 
 # commonly used editors
 # vim
@@ -365,7 +366,6 @@ lib/cmyth/Makefile
 /project/Win32BuildSetup/languages.nsi
 /project/Win32BuildSetup/xbmc-pvr-addons.nsi
 /project/Win32BuildSetup/BUILD_WIN32/
-/project/Win32BuildSetup/dependencies
 
 # /project/BuildDependencies
 /project/BuildDependencies/downloads
diff --git a/Readme.md b/Readme.md
new file mode 100644
index 0000000..8596579
--- /dev/null
+++ b/Readme.md
@@ -0,0 +1,243 @@
+SPOTYXBMC2
+==========
+This is a rewrite of the s potyxbmc project, the code is cleaner and better encapsulated from XBMC. It is now being prepared to be lifted out to a binary addon.
+The code is not heavily tested and has known issues, don´t install if you don´t know what you are doing.
+
+The main discussion for spotyxbmc is [here](http://forum.xbmc.org/showthread.php?t=67012)
+A discussion concerning a unified music addon front-end can be read [here](http://forum.xbmc.org/showthread.php?t=105147).
+
+You must have a valid spotify premium account to be able to use spotyXBMC.
+
+Features and usage
+------------------
+This implementation adds spotify content to the regular music categories under the music section, do not try to run the addon, its only there for settings!
+
+A video showing most of the features can be seen [here](http://www.youtube.com/watch?v=xFSdxKyWXpU).
+
+* Starred tracks, albums and artists will show up in the songs, albums and artists sections alongside the local music.
+* Spotify playlists shows up in the playlist section.
+* The normal music search will return local music and spotify search result.
+* Top 100 spotify lists with artists, albums and tracks is available in the top 100 section.
+* Modifying playlists and star/unstar items in the spotify client will result in that the lists is updated in XBMC.
+* Multi-disc albums are split up into separate albums with suffix "disc #".
+* Browsing artist albums will provide a "similar artists" folder with spotify similar artists.
+* Navigate to the album artist from an album or to the artist or album from a track using the context menu.
+* Star/unstar albums and tracks from within XBMC using the context menu.
+* The settings is changed from within a built-in addon.
+* Two spotify "radios" is provided int the music root, visit the settings to set name, years and genres.
+* Top-lists will update once every 24 hour.
+
+Missing features
+----------------
+* Interaction with spotify items like creating and modify playlists, adding spotify tracks to playlists and so on is not supported yet.
+* The year and genre nodes will not lead to any spotify items yet.
+* A lot more I guess.
+
+Platforms
+---------
+
+* Linux - supported
+* Windows - supported
+* OSX - Not supported
+
+Known issues
+------------
+Enable preloading of artists together with preloading of top 100 lists and/or a massive collection of starred tracks will result in a short freeze of XBMC during start (about 5-10 seconds depending on your Internet speed, computer...).
+
+Memory leaks do exist, beware.
+
+A lot of other bugs, the implementation is not heavily tested.
+ 
+Want to help killing a bug?
+---------------------------
+Right now the there is a lot of trace prints, they are printed out straight to the console so be sure that you start XBMC from a console in order to fetch the traces and create a bug report.
+
+Please submit a report to the github issues and provide all relevant data like logs, OS info, what track, playlist or album you have problems with. Or even better, fix it yourself and send me a pull request or an e-mail.
+
+SpotyXBMC2 for OpenElec
+-----------------------------------------------
+Thanks to Tompen a version of OpenElec with spotyXBMC2 integration is available.
+
+Read about it [here](http://openelec.tv/forum/13-general-discussion/7010-spotify).
+
+
+Installation instructions for Microsoft Windows
+-----------------------------------------------
+1. Obtain spotyXBMC2 source
+   Use your favorite git tool to clone the repo: `git://github.com/akezeke/spotyxbmc2.git`
+
+2. Spotify API key
+   Get your own spotify API key from http://developer.spotify.com/en/libspotify/application-key/
+   Click on c-code and copy the content to a new file called appkey.h placed in the xbmc source root folder. (where this readme is located).
+  
+3. Build
+   Follow a guide from XBMC.org and build it yourself, if you are not using the Win32BuildSetup utility make sure that you copy libspotify.dll to your XBMC install location.
+  
+4. Start xbmc
+   From the start menu.
+
+9. Start spotyXBMC
+   start the preinstalled music addon spotyXBMC and set the settings
+
+10. Restart XBMC
+
+11. Enable the music library and enjoy spotify music inside xbmc
+		The spotify music is located inside the normal music categories, do not try to start the spotyXBMC addon!
+
+
+Installation instructions for Ubuntu Linux 32/64
+------------------------------------------------
+1. Download libSpotify
+
+	For 32 bit:
+	`$ wget http://developer.spotify.com/download/libspotify/libspotify-10.1.16-Linux-i686-release.tar.gz`
+
+	64 bit OS:
+   `$ wget http://developer.spotify.com/download/libspotify/libspotify-10.1.16-Linux-x86_64-release.tar.gz`
+
+2. Untar:
+   `$ tar xzf libspotify-*.tar.gz`
+
+3. Install libspotify
+   `$ cd libspotify-Linux...`
+   `$ sudo make install prefix=/usr/local`
+
+4. Obtain spotyXBMC2 source
+   Make sure you have git installed, if not and in ubuntu install with `sudo apt-get install git-core`
+   `$ cd ..`
+   `$ git clone git://github.com/akezeke/spotyxbmc2.git`
+   `$ cd xbmc`
+
+5. Spotify API key
+   Get your own spotify API key from http://developer.spotify.com/en/libspotify/application-key/
+   Click on c-code and copy the content to a new file called appkey.h placed in the xbmc source root folder. (where this readme is located).
+
+6. Install all XBMC dependencies listed in the corresponding readme file.
+   For ubuntu 11.04 run:
+
+`$ sudo apt-get install git-core make g++ gcc gawk pmount libtool nasm yasm automake cmake gperf zip unzip bison libltdl-dev libsdl-dev libsdl-image1.2-dev libsdl-gfx1.2-dev libsdl-mixer1.2-dev libfribidi-dev liblzo2-dev libfreetype6-dev libsqlite3-dev libogg-dev libasound2-dev python-sqlite libglew-dev libcurl3 libcurl4-gnutls-dev libxrandr-dev libxrender-dev libmad0-dev libogg-dev libvorbisenc2 libsmbclient-dev libmysqlclient-dev libpcre3-dev libdbus-1-dev libhal-dev libhal-storage-dev libjasper-dev libfontconfig-dev libbz2-dev libboost-dev libenca-dev libxt-dev libxmu-dev libpng-dev libjpeg-dev libpulse-dev mesa-utils libcdio-dev libsamplerate-dev libmpeg3-dev libflac-dev libiso9660-dev libass-dev libssl-dev fp-compiler gdc libmpeg2-4-dev libmicrohttpd-dev libmodplug-dev libssh-dev gettext cvs python-dev libyajl-dev libboost-thread-dev libplist-dev libusb-dev libudev-dev autopoint`
+
+
+7. Configure, make and install xbmc
+   `$ ./bootstrap`
+   `$ ./configure`
+   `$ make`
+   `$ sudo make install`
+
+8. Start xbmc
+   `$ xbmc`
+
+9. Start spotyXBMC
+   start the preinstalled music addon spotyXBMC and set the settings
+
+10. Restart XBMC
+
+11. Enable the music library and enjoy spotify music inside xbmc
+    The spotify music is located inside the normal music categories, do not try to start the spotyXBMC addon!
+
+Done!
+
+Source
+------
+The spotify related code lives all in xbmc/music/spotyXBMC/ and can (fairly) easely be extracted and used in other applications.
+
+Added files:
+
+* xbmc/music/spotyXBMC/Addon.music.spotify.cpp
+* xbmc/music/spotyXBMC/Addon.music.spotify.h
+* xbmc/music/spotyXBMC/Logger.cpp
+* xbmc/music/spotyXBMC/Logger.h
+* xbmc/music/spotyXBMC/SxSettings.cpp
+* xbmc/music/spotyXBMC/SxSettings.h
+* xbmc/music/spotyXBMC/Utils.cpp
+* xbmc/music/spotyXBMC/Utils.h
+* xbmc/music/spotyXBMC/radio/SxRadio.cpp
+* xbmc/music/spotyXBMC/radio/SxRadio.h
+* xbmc/music/spotyXBMC/radio/RadioHandler.cpp
+* xbmc/music/spotyXBMC/radio/RadioHandler.h
+* xbmc/music/spotyXBMC/album/SxAlbum.cpp
+* xbmc/music/spotyXBMC/album/SxAlbum.h
+* xbmc/music/spotyXBMC/album/AlbumStore.cpp
+* xbmc/music/spotyXBMC/album/AlbumStore.h
+* xbmc/music/spotyXBMC/album/AlbumContainer.cpp
+* xbmc/music/spotyXBMC/album/AlbumContainer.h
+* xbmc/music/spotyXBMC/artist/SxArtist.cpp
+* xbmc/music/spotyXBMC/artist/SxArtist.h
+* xbmc/music/spotyXBMC/artist/ArtistStore.cpp
+* xbmc/music/spotyXBMC/artist/ArtistStore.h
+* xbmc/music/spotyXBMC/artist/ArtistContainer.cpp
+* xbmc/music/spotyXBMC/artist/ArtistContainer.h
+* xbmc/music/spotyXBMC/search/Search.cpp
+* xbmc/music/spotyXBMC/search/Search.h
+* xbmc/music/spotyXBMC/search/SearchHandler.cpp
+* xbmc/music/spotyXBMC/search/SearchHandler.h
+* xbmc/music/spotyXBMC/search/SearchBackgroundLoader.cpp
+* xbmc/music/spotyXBMC/search/SearchBackgroundLoader.h
+* xbmc/music/spotyXBMC/player/Codec.cpp
+* xbmc/music/spotyXBMC/player/Codec.h
+* xbmc/music/spotyXBMC/player/PlayerHandler.cpp
+* xbmc/music/spotyXBMC/player/PlayerHandler.h
+* xbmc/music/spotyXBMC/playlist/TopLists.cpp
+* xbmc/music/spotyXBMC/playlist/TopLists.h
+* xbmc/music/spotyXBMC/playlist/SxPlaylist.cpp
+* xbmc/music/spotyXBMC/playlist/SxPlaylist.h
+* xbmc/music/spotyXBMC/playlist/StarredList.cpp
+* xbmc/music/spotyXBMC/playlist/StarredList.h
+* xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.cpp
+* xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.h
+* xbmc/music/spotyXBMC/playlist/PlaylistStore.cpp
+* xbmc/music/spotyXBMC/playlist/PlaylistStore.h
+* xbmc/music/spotyXBMC/session/Session.cpp
+* xbmc/music/spotyXBMC/session/Session.h
+* xbmc/music/spotyXBMC/session/SessionCallbacks.cpp
+* xbmc/music/spotyXBMC/session/SessionCallbacks.h
+* xbmc/music/spotyXBMC/session/BackgroundThread.cpp
+* xbmc/music/spotyXBMC/session/BackgroundThread.h
+* xbmc/music/spotyXBMC/thumb/SxThumb.cpp
+* xbmc/music/spotyXBMC/thumb/SxThumb.h
+* xbmc/music/spotyXBMC/thumb/ThumbStore.cpp
+* xbmc/music/spotyXBMC/thumb/ThumbStore.h
+* xbmc/music/spotyXBMC/track/SxTrack.cpp
+* xbmc/music/spotyXBMC/track/SxTrack.h
+* xbmc/music/spotyXBMC/track/TrackStore.cpp
+* xbmc/music/spotyXBMC/track/TrackStore.h
+* xbmc/music/spotyXBMC/track/TrackContainer.cpp
+* xbmc/music/spotyXBMC/track/TrackContainer.h
+
+* addons/plugin.music.spotyXBMC/icon.png
+* addons/plugin.music.spotyXBMC/fanart.jpg
+* addons/plugin.music.spotyXBMC/default.py
+* addons/plugin.music.spotyXBMC/changelog.txt
+* addons/plugin.music.spotyXBMC/addon.xml
+* addons/plugin.music.spotyXBMC/resources/settings.xml
+* addons/plugin.music.spotyXBMC/resources/language/English/strings.xml
+* addons/skin.confluence/media/flagging/audio/spotify.png
+
+Modified files:
+
+* xbmc/cores/paplayer/CodecFactory.cpp
+* xbmc/filesystem/MusicSearchDirectory.cpp
+* xbmc/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
+* xbmc/MusicDatabaseDirectory/DirectoryNodeArtist.cpp
+* xbmc/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
+* xbmc/MusicDatabaseDirectory/DirectoryNodeSong.cpp
+* xbmc/MusicDatabaseDirectory/DirectoryNodeTop100.cpp
+* xbmc/music/windows/GUIWindowMusicBase.cpp
+* xbmc/music/Windows/GuiWindowMusicNav.cpp
+* xbmc/music/Makefile
+* xbmc/settings/Settings.cpp
+* xbmc/Application.cpp
+* xbmc/GUIInfoManager.cpp
+
+Buy me a beer?
+-------------
+<a href='http://www.pledgie.com/campaigns/15827'><img alt='Click here to lend your support to: spotyXBMC2 and make a donation at www.pledgie.com !' src='http://www.pledgie.com/campaigns/15827.png?skin_name=chrome' border='0' /></a>
+Contact
+-------
+
+http://github.com/akezeke/spotyxbmc
+david.erenger@gmail.com
+
+/David
+
+
diff --git a/addons/plugin.music.spotyXBMC/addon.xml b/addons/plugin.music.spotyXBMC/addon.xml
new file mode 100644
index 0000000..0b7bc86
--- /dev/null
+++ b/addons/plugin.music.spotyXBMC/addon.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="plugin.music.spotyXBMC"
+       name="spotyXBMC"
+       version="0.0.1"
+       provider-name="David Erenger">
+  <requires>
+    <import addon="xbmc.python" version="2.0"/>
+  </requires>
+  <extension point="xbmc.python.pluginsource"
+            library="default.py">
+        <provides>audio</provides>
+  </extension>
+  <extension point="xbmc.addon.metadata">
+    <platform>all</platform>
+    <summary>spotyXBMC</summary>
+    <description>Plugin that holds spotyXBMC settings</description>
+    <disclaimer>This product uses SPOTIFY(R) CORE but is not endorsed, certified or otherwise approved in any way by Spotify. Spotify is the registered trade mark of the Spotify Group.</disclaimer>
+  </extension>
+</addon>
diff --git a/addons/plugin.music.spotyXBMC/changelog.txt b/addons/plugin.music.spotyXBMC/changelog.txt
new file mode 100644
index 0000000..e49f0ce
--- /dev/null
+++ b/addons/plugin.music.spotyXBMC/changelog.txt
@@ -0,0 +1,2 @@
+[B]0.0.1[/B]
+- Created
diff --git a/addons/plugin.music.spotyXBMC/default.py b/addons/plugin.music.spotyXBMC/default.py
new file mode 100644
index 0000000..7ecaf02
--- /dev/null
+++ b/addons/plugin.music.spotyXBMC/default.py
@@ -0,0 +1,20 @@
+import xbmcplugin,xbmcgui,xbmcaddon
+
+# plugin constants
+__version__ = "0.0.1"
+__plugin__ = "spotyXBMC-" + __version__
+__author__ = "David Erenger"
+__url__ = "https://github.com/akezeke/xbmc"
+__settings__ = xbmcaddon.Addon(id='plugin.music.spotyXBMC')
+__language__ = __settings__.getLocalizedString
+
+def startPlugin():
+	if (__settings__.getSetting("enable") == "false"):
+		__settings__.openSettings()	
+		xbmc.executebuiltin('XBMC.ReplaceWindow(home)')
+
+	else:
+        	xbmc.executebuiltin('XBMC.ReplaceWindow(musiclibrary,musicdb://)')
+        	xbmc.executebuiltin('XBMC.Action(parentdir)')	
+
+startPlugin()
diff --git a/addons/plugin.music.spotyXBMC/fanart.jpg b/addons/plugin.music.spotyXBMC/fanart.jpg
new file mode 100644
index 0000000..3823455
Binary files /dev/null and b/addons/plugin.music.spotyXBMC/fanart.jpg differ
diff --git a/addons/plugin.music.spotyXBMC/icon.png b/addons/plugin.music.spotyXBMC/icon.png
new file mode 100644
index 0000000..e52ecc4
Binary files /dev/null and b/addons/plugin.music.spotyXBMC/icon.png differ
diff --git a/addons/plugin.music.spotyXBMC/resources/language/English/strings.xml b/addons/plugin.music.spotyXBMC/resources/language/English/strings.xml
new file mode 100644
index 0000000..393b113
--- /dev/null
+++ b/addons/plugin.music.spotyXBMC/resources/language/English/strings.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<strings>
+    <string id="30001">spotyXBMC</string>
+    <string id="30002">by</string>
+    <string id="30003">Restart XBMC to apply</string>
+    
+    <string id="30400">General</string>
+    <string id="30401">Username</string>
+    <string id="30402">Password</string>
+    <string id="30403">Cache location</string>
+    <string id="30404">Use high bitrate</string>
+    <string id="30405">Enable</string>
+    <string id="30406">Fanart</string>
+    <string id="30407">Use spotify fanart</string>
+    <string id="30408">Use custom fanart image</string>
+    <string id="30409">Use volume normalization</string>
+    <string id="30410">Download fanarts from HTBackdrops</string>
+    <string id="30411">Download artist thumbs from HTBackdrops.com</string>
+    <string id="30412">Delayed start (seconds)</string>
+    <string id="30413">Write log to file (temp/spotify/log.txt)</string>
+    
+    <string id="30420">Performance</string>
+    <string id="30421">Search: Max number of artists</string>
+    <string id="30422">Search: Max number of albums</string>
+    <string id="30423">Search: Max number of tracks</string>
+    <string id="30424">Artist browse: Max number of similar artists</string>
+    <string id="30425">Artist browse: Max number of albums</string>
+    <string id="30426">Artist browse: Max number of tracks</string>
+    <string id="30427">Preload artist albums and tracks</string>
+
+    <string id="30430">Top lists</string>
+    <string id="30431">Show lists for region</string>
+    <string id="30432">Everywhere</string>
+    <string id="30433">Your country</string>
+    <string id="30434">Preload top 100 lists (true = slow XBMC start)</string>
+
+    <string id="30440">Spotify radio1</string>
+    <string id="30441">Spotify radio2</string>
+    <string id="30442">Name</string>
+    <string id="30443">Alternative</string>
+    <string id="30444">Black Metal</string>
+    <string id="30445">Blues</string>
+    <string id="30446">Classical</string>
+    <string id="30447">Country</string>
+    <string id="30448">Club/House</string>
+    <string id="30449">Death Metal</string>
+    <string id="30450">Electronic</string>
+    <string id="30451">Emo</string>
+    <string id="30452">Folk</string>
+    <string id="30453">Hardcore</string>
+    <string id="30454">Heavy Metal</string>
+    <string id="30455">Hip-hop</string>
+    <string id="30456">Indie</string>
+    <string id="30457">Jazz</string>
+    <string id="30458">Latin</string>
+    <string id="30459">Pop</string>
+    <string id="30462">Punk</string>
+    <string id="30463">Reggae</string>
+    <string id="30464">R&B</string>
+    <string id="30465">Rock</string>
+    <string id="30466">Singer-songwriter</string>
+    <string id="30467">Soul</string>
+    <string id="30468">Trance</string>
+    <string id="30469">60s</string>
+    <string id="30471">70s</string>
+    <string id="30472">80s</string>
+    
+    <string id="30460">From decade</string>
+    <string id="30461">To decade</string>
+
+    <string id="30470">Number of radio tracks</string>
+
+    <string id="30500">Top 100 Spotify artists</string>
+    <string id="30501">Top 100 Spotify albums</string>
+    <string id="30502">Top 100 Spotify songs</string>
+    <string id="30503">Spotify radio: </string>
+    <string id="30504">* Similar artists</string>
+    <string id="30505">* Spotify inbox</string>
+    
+    <!-- Context buttons -->
+    <string id="30600">Spotify: star track</string>
+    <string id="30601">Spotify: unstar track</string>
+    <string id="30602">Spotify: star album</string>
+    <string id="30603">Spotify: unstar album</string>
+    <string id="30604">Spotify: browse album</string>
+    <string id="30605">Spotify: browse artist</string>
+</strings>
diff --git a/addons/plugin.music.spotyXBMC/resources/language/French/strings.xml b/addons/plugin.music.spotyXBMC/resources/language/French/strings.xml
new file mode 100644
index 0000000..6565ea9
--- /dev/null
+++ b/addons/plugin.music.spotyXBMC/resources/language/French/strings.xml
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<strings>
+    <string id="30001">spotyXBMC</string>
+    <string id="30002">par</string>
+    <string id="30003">Redémarrer XBMC pour appliquer</string>
+    
+    <string id="30400">Général</string>
+    <string id="30401">Nom d'utilisateur</string>
+    <string id="30402">Mot de Passe</string>
+    <string id="30403">Emplacement du cache</string>
+    <string id="30404">Bitrate haute qualité</string>
+    <string id="30405">Activé</string>
+    <string id="30406">Vignettes</string>
+    <string id="30407">Utilisé les pochettes Spotify</string>
+    <string id="30408">Utilisé des pochettes personnalisé</string>
+    <string id="30409">Utilisé le normalisateur de volume</string>
+    <string id="30410">Télécharger les pochettes depuis HTBackdrops</string>
+    <string id="30411">Télécharger les vignettes depuis HTBackdrops</string>
+    <string id="30412">Temporisation du démarrage (seconds)</string>
+    <string id="30413">Emplacement du log (temp/spotify/log.txt)</string>
+    
+    <string id="30420">Performance</string>
+    <string id="30421">Recherche: Nombre max d'artistes</string>
+    <string id="30422">Recherche: Nombre max d'albums</string>
+    <string id="30423">Recherche: Nombre max de pistes</string>
+    <string id="30424">Explorateur d'artiste: Nombre max d'artistes similaire</string>
+    <string id="30425">Explorateur d'artiste: Nombre max d'albums</string>
+    <string id="30426">Explorateur d'artiste: Nombre max de pistes</string>
+    <string id="30427">Préchargement albums et piste des artistes</string>
+
+    <string id="30430">Top listes</string>
+    <string id="30431">Voir listes par région</string>
+    <string id="30432">Mondial</string>
+    <string id="30433">Votre Pays</string>
+    <string id="30434">Précharger le top 100 (cocher = ralenti le démarrage de XBMC)</string>
+
+    <string id="30440">Spotify radio1</string>
+    <string id="30441">Spotify radio2</string>
+    <string id="30442">Nom</string>
+    <string id="30443">Alternative</string>
+    <string id="30444">Black Metal</string>
+    <string id="30445">Blues</string>
+    <string id="30446">Classical</string>
+    <string id="30447">Country</string>
+    <string id="30448">Club/House</string>
+    <string id="30449">Death Metal</string>
+    <string id="30450">Electronic</string>
+    <string id="30451">Emo</string>
+    <string id="30452">Folk</string>
+    <string id="30453">Hardcore</string>
+    <string id="30454">Heavy Metal</string>
+    <string id="30455">Hip-hop</string>
+    <string id="30456">Indie</string>
+    <string id="30457">Jazz</string>
+    <string id="30458">Latin</string>
+    <string id="30459">Pop</string>
+    <string id="30462">Punk</string>
+    <string id="30463">Reggae</string>
+    <string id="30464">R&B</string>
+    <string id="30465">Rock</string>
+    <string id="30466">Singer-songwriter</string>
+    <string id="30467">Soul</string>
+    <string id="30468">Trance</string>
+    <string id="30469">60s</string>
+    <string id="30471">70s</string>
+    <string id="30472">80s</string>
+    
+    <string id="30460">De la décénnie</string>
+    <string id="30461">à la décénnie</string>
+
+    <string id="30470">Nombre de piste de la radio</string>
+
+    <string id="30500">Top 100 Spotify artistes</string>
+    <string id="30501">Top 100 Spotify albums</string>
+    <string id="30502">Top 100 Spotify pistes</string>
+    <string id="30503">Spotify radio: </string>
+    <string id="30504">* Artistes Similaire </string>
+    <string id="30505">* Boite de réception</string>
+    
+    <!-- Context buttons -->
+    <string id="30600">Spotify: suivre la piste</string>
+    <string id="30601">Spotify: désactivé le suivi de la piste</string>
+    <string id="30602">Spotify: suivre l'album</string>
+    <string id="30603">Spotify: désactivé le suivi de l'album</string>
+    <string id="30604">Spotify: parcourir l'album</string>
+    <string id="30605">Spotify: parcourir l'artiste</string>
+</strings>
diff --git a/addons/plugin.music.spotyXBMC/resources/settings.xml b/addons/plugin.music.spotyXBMC/resources/settings.xml
new file mode 100644
index 0000000..50c7859
--- /dev/null
+++ b/addons/plugin.music.spotyXBMC/resources/settings.xml
@@ -0,0 +1,105 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<settings>
+
+  <!-- General -->
+  <category label="30400">
+    <setting id="desc" type="text" label="30003" default="" enable="false" />
+    <setting type="sep" />
+    <setting id="enable" type="bool" label="30405" default="false" />
+    <setting id="username" type="text" enable="eq(-1,true)" label="30401" default="" />
+    <setting id="password" type="text" enable="eq(-2,true)" option="hidden" label="30402" default="" />
+    <setting id="delay" type="enum" enable="eq(-3,true)" label="30412" values="0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20" default="1" />
+    <setting id="logtofile" type="bool" enable="eq(-4,true)" label="30413" default="false" />
+    <setting type="sep" />
+    <setting id="highBitrate" type="bool" enable="eq(-6,true)" label="30404" default="true" />
+    <setting id="normalization" type="bool" enable="eq(-7,true)" label="30409" default="true" />
+    <setting id="enablefanart" type="bool" enable="eq(-8,true)"  label="30407" default="true" />
+    <setting id="customfanart" type="bool" enable="eq(-9,true)" visible="eq(-1,true)" label="30408" default="false" />
+    <setting id="fanart" type="file" enable="eq(-10,true)" visible="eq(-1,true)" label="30406" default="" />
+    <setting id="htfanart" type="bool" enable="eq(-11,true)" visible="eq(-3,true)" label="30410" default="false" />
+    <setting id="htartistthumb" type="bool" enable="false" visible="false" label="30411" default="false" />
+  </category>
+  <category label="30420">
+    <setting id="searchNoArtists" type="enum" label="30421" values="10|20|30|40|50|60|70|80|90|100" default="1" />
+    <setting id="searchNoAlbums" type="enum" label="30422" values="10|20|30|40|50|60|70|80|90|100" default="1" />
+    <setting id="searchNoTracks" type="enum" label="30423" values="10|20|30|40|50|60|70|80|90|100" default="1" />
+    <setting type="sep" />
+    <setting id="preloadArtistDetails" type="bool" label="30427" default="false" />
+    <setting id="artistNoArtists" type="enum" label="30424" values="10|20|30|40|50|60|70|80|90|100|All" default="1" />
+    <setting id="artistNoAlbums" type="enum" label="30425" values="10|20|30|40|50|60|70|80|90|100|All" default="6" />
+    <setting id="artistNoTracks" type="enum" label="30426" values="10|20|30|40|50|60|70|80|90|100|All" default="6" />
+    <setting type="sep" />
+    <setting id="radioNoTracks" type="enum" label="30470" values="3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20" default="11" />
+  </category>
+  <category label="30430">
+    <setting id="topListRegion" type="enum" label="30431" lvalues="30433|30432" default="0" />
+    <setting id="preloadToplists" type="bool" label="30434" default="false" />
+  </category>
+  <category label="30440">
+    <setting id="radio1name" type="text" label="30442" default="Rock"/>
+    <setting id="radio1from" type="enum" label="30460" values="Older|50s|60s|70s|80s|90s|00s|10s" default="3" />
+    <setting id="radio1to" type="enum" label="30461" values="Older|50s|60s|70s|80s|90s|00s|10s" default="7" />
+    <setting id="radio1genre1" type="bool" label="30443" default="false" />
+    <setting id="radio1genre2" type="bool" label="30444" default="true" />
+    <setting id="radio1genre3" type="bool" label="30445" default="false" />
+    <setting id="radio1genre4" type="bool" label="30446" default="false" />
+    <setting id="radio1genre5" type="bool" label="30447" default="false" />
+    <setting id="radio1genre6" type="bool" label="30448" default="false" />
+    <setting id="radio1genre7" type="bool" label="30449" default="true" />
+    <setting id="radio1genre8" type="bool" label="30450" default="false" />
+    <setting id="radio1genre9" type="bool" label="30451" default="false" />
+    <setting id="radio1genre10" type="bool" label="30452" default="false" />
+    <setting id="radio1genre11" type="bool" label="30453" default="false" />
+    <setting id="radio1genre12" type="bool" label="30454" default="true" />
+    <setting id="radio1genre13" type="bool" label="30455" default="false" />
+    <setting id="radio1genre14" type="bool" label="30456" default="false" />
+    <setting id="radio1genre15" type="bool" label="30457" default="false" />
+    <setting id="radio1genre16" type="bool" label="30458" default="false" />
+    <setting id="radio1genre17" type="bool" label="30459" default="false" />
+    <setting id="radio1genre18" type="bool" label="30462" default="false" />
+    <setting id="radio1genre19" type="bool" label="30463" default="false" />
+    <setting id="radio1genre20" type="bool" label="30464" default="false" />
+    <setting id="radio1genre21" type="bool" label="30465" default="true" />
+    <setting id="radio1genre22" type="bool" label="30466" default="false" />
+    <setting id="radio1genre23" type="bool" label="30467" default="false" />
+    <setting id="radio1genre24" type="bool" label="30468" default="false" />
+    <setting id="radio1genre25" type="bool" label="30469" default="false" />
+    <setting id="radio1genre26" type="bool" label="30471" default="false" />
+    <setting id="radio1genre27" type="bool" label="30472" default="false" />
+    
+
+</category>
+  <category label="30441">
+    <setting id="radio2name" type="text" label="30442" default="Dance"/>
+    <setting id="radio2from" type="enum" label="30460" values="Older|50s|60s|70s|80s|90s|00s|10s" default="0" />
+    <setting id="radio2to" type="enum" label="30461" values="Older|50s|60s|70s|80s|90s|00s|10s" default="7" />
+    <setting id="radio2genre1" type="bool" label="30443" default="false" />
+    <setting id="radio2genre2" type="bool" label="30444" default="false" />
+    <setting id="radio2genre3" type="bool" label="30445" default="false" />
+    <setting id="radio2genre4" type="bool" label="30446" default="false" />
+    <setting id="radio2genre5" type="bool" label="30447" default="false" />
+    <setting id="radio2genre6" type="bool" label="30448" default="true" />
+    <setting id="radio2genre7" type="bool" label="30449" default="false" />
+    <setting id="radio2genre8" type="bool" label="30450" default="false" />
+    <setting id="radio2genre9" type="bool" label="30451" default="false" />
+    <setting id="radio2genre10" type="bool" label="30452" default="false" />
+    <setting id="radio2genre11" type="bool" label="30453" default="false" />
+    <setting id="radio2genre12" type="bool" label="30454" default="false" />
+    <setting id="radio2genre13" type="bool" label="30455" default="true" />
+    <setting id="radio2genre14" type="bool" label="30456" default="false" />
+    <setting id="radio2genre15" type="bool" label="30457" default="false" />
+    <setting id="radio2genre16" type="bool" label="30458" default="false" />
+    <setting id="radio2genre17" type="bool" label="30459" default="true" />
+    <setting id="radio2genre18" type="bool" label="30462" default="false" />
+    <setting id="radio2genre18" type="bool" label="30462" default="false" />
+    <setting id="radio2genre19" type="bool" label="30463" default="false" />
+    <setting id="radio2genre20" type="bool" label="30464" default="true" />
+    <setting id="radio2genre21" type="bool" label="30465" default="false" />
+    <setting id="radio2genre22" type="bool" label="30466" default="false" />
+    <setting id="radio2genre23" type="bool" label="30467" default="true" />
+    <setting id="radio2genre24" type="bool" label="30468" default="true" />
+    <setting id="radio2genre25" type="bool" label="30469" default="false" />
+    <setting id="radio2genre26" type="bool" label="30471" default="false" />
+    <setting id="radio2genre27" type="bool" label="30472" default="false" />
+</category>
+</settings>
diff --git a/addons/skin.confluence/media/flagging/audio/spotify.png b/addons/skin.confluence/media/flagging/audio/spotify.png
new file mode 100644
index 0000000..69b3130
Binary files /dev/null and b/addons/skin.confluence/media/flagging/audio/spotify.png differ
diff --git a/configure.in b/configure.in
index cf84ebb..de52cf4 100644
--- a/configure.in
+++ b/configure.in
@@ -1682,6 +1682,9 @@ else
   AC_MSG_NOTICE($vdpau_disabled)
 fi
 
+# spotify
+LIBS="-lspotify $LIBS"
+
 # VAAPI
 if test "x$use_vaapi" != "xno"; then
   if test "$host_vendor" = "apple" ; then
diff --git a/lib/libspotify/api.h b/lib/libspotify/api.h
new file mode 100755
index 0000000..052fc62
--- /dev/null
+++ b/lib/libspotify/api.h
@@ -0,0 +1,3577 @@
+/*
+ * Copyright (c) 2006-2010 Spotify Ltd
+ *
+ * The terms of use for this and related files can be read in
+ * the associated LICENSE file, usually stored in share/doc/libspotify/LICENSE.
+ */
+
+/**
+ * @file   api.h    Public API for libspotify
+ *
+ * @note   All input strings are expected to be in UTF-8
+ * @note   All output strings are in UTF-8.
+ *
+ * @note   All usernames are valid XMPP nodeprep identifiers:
+ *         http://tools.ietf.org/html/rfc3920#appendix-A
+ *         If you need to store user data, we strongly advise you
+ *         to use the canonical form of the username.
+ */
+
+#ifndef PUBLIC_API_H
+#define PUBLIC_API_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef SP_CALLCONV
+#ifdef _WIN32
+#define SP_CALLCONV __stdcall
+#else
+#define SP_CALLCONV
+#endif
+#endif
+
+#ifndef SP_LIBEXPORT
+#ifdef _WIN32
+#define SP_LIBEXPORT(x) x __stdcall
+#else
+#define SP_LIBEXPORT(x) x
+#endif
+#endif
+
+/* Includes */
+#include <stddef.h>
+
+
+
+#ifdef _WIN32
+typedef unsigned __int64 sp_uint64;
+#else
+#include <stdint.h>
+typedef uint64_t sp_uint64;
+#endif
+
+/* General types */
+
+#if !defined(__cplusplus) && !defined(__bool_true_false_are_defined)
+typedef unsigned char bool;
+#endif
+
+typedef unsigned char s_byte;
+
+/**
+ * @defgroup types Spotify types & structs
+ *
+ * @{
+ */
+
+typedef struct sp_session sp_session; ///< Representation of a session
+typedef struct sp_track sp_track; ///< A track handle
+typedef struct sp_album sp_album; ///< An album handle
+typedef struct sp_artist sp_artist; ///< An artist handle
+typedef struct sp_artistbrowse sp_artistbrowse; ///< A handle to an artist browse result
+typedef struct sp_albumbrowse sp_albumbrowse; ///< A handle to an album browse result
+typedef struct sp_toplistbrowse sp_toplistbrowse; ///< A handle to a toplist browse result
+typedef struct sp_search sp_search; ///< A handle to a search result
+typedef struct sp_link sp_link; ///< A handle to the libspotify internal representation of a URI
+typedef struct sp_image sp_image; ///< A handle to an image
+typedef struct sp_user sp_user; ///< A handle to a user
+typedef struct sp_playlist sp_playlist; ///< A playlist handle
+typedef struct sp_playlistcontainer sp_playlistcontainer; ///< A playlist container (playlist containing other playlists) handle
+typedef struct sp_inbox sp_inbox; ///< Add to inbox request handle
+/** @} */
+
+/**
+ * @defgroup error Error Handling
+ *
+ * All functions in libspotify use the same set of error codes. Most of them return
+ * an error code, and let the result of the operation be stored in an out-parameter.
+ *
+ * @{
+ */
+
+/**
+ * Error codes returned by various functions
+ */
+typedef enum sp_error {
+	SP_ERROR_OK                        = 0,  ///< No errors encountered
+	SP_ERROR_BAD_API_VERSION           = 1,  ///< The library version targeted does not match the one you claim you support
+	SP_ERROR_API_INITIALIZATION_FAILED = 2,  ///< Initialization of library failed - are cache locations etc. valid?
+	SP_ERROR_TRACK_NOT_PLAYABLE        = 3,  ///< The track specified for playing cannot be played
+	SP_ERROR_BAD_APPLICATION_KEY       = 5,  ///< The application key is invalid
+	SP_ERROR_BAD_USERNAME_OR_PASSWORD  = 6,  ///< Login failed because of bad username and/or password
+	SP_ERROR_USER_BANNED               = 7,  ///< The specified username is banned
+	SP_ERROR_UNABLE_TO_CONTACT_SERVER  = 8,  ///< Cannot connect to the Spotify backend system
+	SP_ERROR_CLIENT_TOO_OLD            = 9,  ///< Client is too old, library will need to be updated
+	SP_ERROR_OTHER_PERMANENT           = 10, ///< Some other error occurred, and it is permanent (e.g. trying to relogin will not help)
+	SP_ERROR_BAD_USER_AGENT            = 11, ///< The user agent string is invalid or too long
+	SP_ERROR_MISSING_CALLBACK          = 12, ///< No valid callback registered to handle events
+	SP_ERROR_INVALID_INDATA            = 13, ///< Input data was either missing or invalid
+	SP_ERROR_INDEX_OUT_OF_RANGE        = 14, ///< Index out of range
+	SP_ERROR_USER_NEEDS_PREMIUM        = 15, ///< The specified user needs a premium account
+	SP_ERROR_OTHER_TRANSIENT           = 16, ///< A transient error occurred.
+	SP_ERROR_IS_LOADING                = 17, ///< The resource is currently loading
+	SP_ERROR_NO_STREAM_AVAILABLE       = 18, ///< Could not find any suitable stream to play
+	SP_ERROR_PERMISSION_DENIED         = 19, ///< Requested operation is not allowed
+	SP_ERROR_INBOX_IS_FULL             = 20, ///< Target inbox is full
+	SP_ERROR_NO_CACHE                  = 21, ///< Cache is not enabled
+	SP_ERROR_NO_SUCH_USER              = 22, ///< Requested user does not exist
+	SP_ERROR_NO_CREDENTIALS            = 23, ///< No credentials are stored
+	SP_ERROR_NETWORK_DISABLED          = 24, ///< Network disabled
+	SP_ERROR_INVALID_DEVICE_ID         = 25, ///< Invalid device ID
+	SP_ERROR_CANT_OPEN_TRACE_FILE      = 26, ///< Unable to open trace file
+	SP_ERROR_APPLICATION_BANNED        = 27, ///< This application is no longer allowed to use the Spotify service
+
+	SP_ERROR_OFFLINE_TOO_MANY_TRACKS   = 31, ///< Reached the device limit for number of tracks to download
+	SP_ERROR_OFFLINE_DISK_CACHE        = 32, ///< Disk cache is full so no more tracks can be downloaded to offline mode
+	SP_ERROR_OFFLINE_EXPIRED           = 33, ///< Offline key has expired, the user needs to go online again
+	SP_ERROR_OFFLINE_NOT_ALLOWED       = 34, ///< This user is not allowed to use offline mode
+	SP_ERROR_OFFLINE_LICENSE_LOST      = 35, ///< The license for this device has been lost. Most likely because the user used offline on three other device
+	SP_ERROR_OFFLINE_LICENSE_ERROR     = 36, ///< The Spotify license server does not respond correctly
+} sp_error;
+
+/**
+ * Convert a numeric libspotify error code to a text string
+ *
+ * @param[in]   error   The error code to lookup
+ */
+SP_LIBEXPORT(const char*) sp_error_message(sp_error error);
+
+/** @} */
+
+
+/**
+ * @defgroup session Session handling
+ *
+ * The concept of a session is fundamental for all communication with the Spotify ecosystem - it is the
+ * object responsible for communicating with the Spotify service. You will need to instantiate a
+ * session that then can be used to request artist information, perform searches etc.
+ *
+ * @{
+ */
+
+/**
+ * Current version of the application interface, that is, the API described by this file.
+ *
+ * This value should be set in the sp_session_config struct passed to sp_session_create().
+ *
+ * If an (upgraded) library is no longer compatible with this version the error #SP_ERROR_BAD_API_VERSION will be
+ * returned from sp_session_create(). Future versions of the library will provide you with some kind of mechanism
+ * to request an updated version of the library.
+ */
+#define SPOTIFY_API_VERSION 10
+
+/**
+ * Describes the current state of the connection
+ */
+typedef enum sp_connectionstate {
+	SP_CONNECTION_STATE_LOGGED_OUT   = 0, ///< User not yet logged in
+	SP_CONNECTION_STATE_LOGGED_IN    = 1, ///< Logged in against a Spotify access point
+	SP_CONNECTION_STATE_DISCONNECTED = 2, ///< Was logged in, but has now been disconnected
+	SP_CONNECTION_STATE_UNDEFINED    = 3, ///< The connection state is undefined
+	SP_CONNECTION_STATE_OFFLINE		 = 4  ///< Logged in in offline mode
+} sp_connectionstate;
+
+
+/**
+ * Sample type descriptor
+ */
+typedef enum sp_sampletype {
+	SP_SAMPLETYPE_INT16_NATIVE_ENDIAN = 0, ///< 16-bit signed integer samples
+} sp_sampletype;
+
+/**
+ * Audio format descriptor
+ */
+typedef struct sp_audioformat {
+	sp_sampletype sample_type;   ///< Sample type enum,
+	int sample_rate;             ///< Audio sample rate, in samples per second.
+	int channels;                ///< Number of channels. Currently 1 or 2.
+} sp_audioformat;
+
+/**
+ * Bitrate definitions for music streaming
+ */
+typedef enum sp_bitrate {
+  SP_BITRATE_160k = 0,
+  SP_BITRATE_320k = 1,
+  SP_BITRATE_96k = 2,
+} sp_bitrate;
+
+/**
+ * Playlist types
+ */
+typedef enum sp_playlist_type {
+	SP_PLAYLIST_TYPE_PLAYLIST     = 0, ///< A normal playlist.
+	SP_PLAYLIST_TYPE_START_FOLDER = 1, ///< Marks a folder starting point,
+	SP_PLAYLIST_TYPE_END_FOLDER   = 2, ///< and ending point.
+	SP_PLAYLIST_TYPE_PLACEHOLDER  = 3, ///< Unknown entry.
+} sp_playlist_type;
+
+/**
+ * Playlist offline status
+ */
+typedef enum sp_playlist_offline_status {
+	SP_PLAYLIST_OFFLINE_STATUS_NO          = 0, ///< Playlist is not offline enabled
+	SP_PLAYLIST_OFFLINE_STATUS_YES         = 1, ///< Playlist is synchronized to local storage
+	SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING = 2, ///< This playlist is currently downloading. Only one playlist can be in this state any given time
+	SP_PLAYLIST_OFFLINE_STATUS_WAITING     = 3, ///< Playlist is queued for download
+} sp_playlist_offline_status;
+
+/**
+ * Track availability
+ */
+typedef enum sp_availability {
+	SP_TRACK_AVAILABILITY_UNAVAILABLE = 0, ///< Track is not available
+	SP_TRACK_AVAILABILITY_AVAILABLE   = 1, ///< Track is available and can be played
+	SP_TRACK_AVAILABILITY_NOT_STREAMABLE = 2, ///< Track can not be streamed using this account
+	SP_TRACK_AVAILABILITY_BANNED_BY_ARTIST = 3, ///< Track not available on artist's reqeust
+} sp_track_availability;
+
+/**
+ * Track offline status
+ */
+typedef enum sp_track_offline_status {
+	SP_TRACK_OFFLINE_NO             = 0, ///< Not marked for offline
+	SP_TRACK_OFFLINE_WAITING        = 1, ///< Waiting for download
+	SP_TRACK_OFFLINE_DOWNLOADING    = 2, ///< Currently downloading
+	SP_TRACK_OFFLINE_DONE           = 3, ///< Downloaded OK and can be played
+	SP_TRACK_OFFLINE_ERROR          = 4, ///< Error during download
+	SP_TRACK_OFFLINE_DONE_EXPIRED   = 5, ///< Downloaded OK but not playable due to expiery
+	SP_TRACK_OFFLINE_LIMIT_EXCEEDED = 6, ///< Waiting because device have reached max number of allowed tracks
+	SP_TRACK_OFFLINE_DONE_RESYNC    = 7, ///< Downloaded OK and available but scheduled for re-download
+} sp_track_offline_status;
+
+/**
+ * Buffer stats used by get_audio_buffer_stats callback
+ */
+typedef struct sp_audio_buffer_stats {
+	int samples;                      ///< Samples in buffer
+	int stutter;                      ///< Number of stutters (audio dropouts) since last query
+} sp_audio_buffer_stats;
+
+/**
+ * List of subscribers returned by sp_playlist_subscribers()
+ */
+typedef struct sp_subscribers {
+	unsigned int count;    ///< Number of elements in 'subscribers'
+	char *subscribers[1];  ///< Actual size is 'count'. Array of pointers to canonical usernames
+} sp_subscribers;
+
+
+/**
+ * Current connection type set using sp_session_set_connection_type()
+ */
+typedef enum sp_connection_type {
+	SP_CONNECTION_TYPE_UNKNOWN        = 0, ///< Connection type unknown (Default)
+	SP_CONNECTION_TYPE_NONE           = 1, ///< No connection
+	SP_CONNECTION_TYPE_MOBILE         = 2, ///< Mobile data (EDGE, 3G, etc)
+	SP_CONNECTION_TYPE_MOBILE_ROAMING = 3, ///< Roamed mobile data (EDGE, 3G, etc)
+	SP_CONNECTION_TYPE_WIFI           = 4, ///< Wireless connection
+	SP_CONNECTION_TYPE_WIRED          = 5, ///< Ethernet cable, etc
+} sp_connection_type;
+
+
+/**
+ * Connection rules, bitwise OR of flags
+ *
+ * The default is SP_CONNECTION_RULE_NETWORK | SP_CONNECTION_RULE_ALLOW_SYNC
+ */
+typedef enum sp_connection_rules {
+	SP_CONNECTION_RULE_NETWORK                = 0x1, ///< Allow network traffic. When not set libspotify will force itself into offline mode
+	SP_CONNECTION_RULE_NETWORK_IF_ROAMING     = 0x2, ///< Allow network traffic even if roaming
+	SP_CONNECTION_RULE_ALLOW_SYNC_OVER_MOBILE = 0x4, ///< Set to allow syncing of offline content over mobile connections
+	SP_CONNECTION_RULE_ALLOW_SYNC_OVER_WIFI   = 0x8, ///< Set to allow syncing of offline content over WiFi
+} sp_connection_rules;
+
+
+/**
+ * Controls the type of data that will be included in artist browse queries
+ */
+typedef enum sp_artistbrowse_type {
+	SP_ARTISTBROWSE_FULL,         /**< All information */
+	SP_ARTISTBROWSE_NO_TRACKS,    /**< Only albums and data about them, no tracks.
+					   In other words, sp_artistbrowse_num_tracks() will return 0
+				      */
+	SP_ARTISTBROWSE_NO_ALBUMS,    /**< Only return data about the artist (artist name, similar artist
+					   biography, etc
+					   No tracks or album will be abailable.
+					   sp_artistbrowse_num_tracks() and sp_artistbrowse_num_albums()
+					   will both return 0
+				      */
+} sp_artistbrowse_type;
+
+
+/**
+ * Offline sync status
+ */
+typedef struct sp_offline_sync_status {
+	/**
+	 * Queued tracks/bytes is things left to sync in current sync
+	 * operation
+	 */
+	int queued_tracks;
+	sp_uint64 queued_bytes;
+
+	/**
+	 * Done tracks/bytes is things marked for sync that existed on
+	 * device before current sync operation
+	 */
+	int done_tracks;
+	sp_uint64 done_bytes;
+
+	/**
+	 * Copied tracks/bytes is things that has been copied in
+	 * current sync operation
+	 */
+	int copied_tracks;
+	sp_uint64 copied_bytes;
+
+	/**
+	 * Tracks that are marked as synced but will not be copied
+	 * (for various reasons)
+	 */
+	int willnotcopy_tracks;
+
+	/**
+	 * A track is counted as error when something goes wrong while
+	 * syncing the track
+	 */
+	int error_tracks;
+
+	/**
+	 * Set if sync operation is in progress
+	 */
+	bool syncing;
+
+} sp_offline_sync_status;
+
+
+/**
+ * Session callbacks
+ *
+ * Registered when you create a session.
+ * If some callbacks should not be of interest, set them to NULL.
+ */
+typedef struct sp_session_callbacks {
+
+	/**
+	 * Called when login has been processed and was successful
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      One of the following errors, from ::sp_error
+	 *                        SP_ERROR_OK
+	 *                        SP_ERROR_CLIENT_TOO_OLD
+	 *                        SP_ERROR_UNABLE_TO_CONTACT_SERVER
+	 *                        SP_ERROR_BAD_USERNAME_OR_PASSWORD
+	 *                        SP_ERROR_USER_BANNED
+	 *                        SP_ERROR_USER_NEEDS_PREMIUM
+	 *                        SP_ERROR_OTHER_TRANSIENT
+	 *                        SP_ERROR_OTHER_PERMANENT
+	 */
+	void (SP_CALLCONV *logged_in)(sp_session *session, sp_error error);
+
+	/**
+	 * Called when logout has been processed. Either called explicitly
+	 * if you initialize a logout operation, or implicitly if there
+	 * is a permanent connection error
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *logged_out)(sp_session *session);
+
+	/**
+	 * Called whenever metadata has been updated
+	 *
+	 * If you have metadata cached outside of libspotify, you should purge
+	 * your caches and fetch new versions.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *metadata_updated)(sp_session *session);
+
+	/**
+	 * Called when there is a connection error, and the library has problems
+	 * reconnecting to the Spotify service. Could be called multiple times (as
+	 * long as the problem is present)
+	 *
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      One of the following errors, from ::sp_error
+	 *                        SP_ERROR_OK
+	 *                        SP_ERROR_CLIENT_TOO_OLD
+	 *                        SP_ERROR_UNABLE_TO_CONTACT_SERVER
+	 *                        SP_ERROR_BAD_USERNAME_OR_PASSWORD
+	 *                        SP_ERROR_USER_BANNED
+	 *                        SP_ERROR_USER_NEEDS_PREMIUM
+	 *                        SP_ERROR_OTHER_TRANSIENT
+	 *                        SP_ERROR_OTHER_PERMANENT
+	 */
+	void (SP_CALLCONV *connection_error)(sp_session *session, sp_error error);
+
+	/**
+	 * Called when the access point wants to display a message to the user
+	 *
+	 * In the desktop client, these are shown in a blueish toolbar just below the
+	 * search box.
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  message    String in UTF-8 format.
+	 */
+	void (SP_CALLCONV *message_to_user)(sp_session *session, const char *message);
+
+	/**
+	 * Called when processing needs to take place on the main thread.
+	 *
+	 * You need to call sp_session_process_events() in the main thread to get
+	 * libspotify to do more work. Failure to do so may cause request timeouts,
+	 * or a lost connection.
+	 *
+	 * @param[in]  session    Session
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 */
+	void (SP_CALLCONV *notify_main_thread)(sp_session *session);
+
+	/**
+	 * Called when there is decompressed audio data available.
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  format     Audio format descriptor sp_audioformat
+	 * @param[in]  frames     Points to raw PCM data as described by \p format
+	 * @param[in]  num_frames Number of available samples in \p frames.
+	 *                        If this is 0, a discontinuity has occurred (such as after a seek). The application
+	 *                        should flush its audio fifos, etc.
+	 *
+	 * @return                Number of frames consumed.
+	 *                        This value can be used to rate limit the output from the library if your
+	 *                        output buffers are saturated. The library will retry delivery in about 100ms.
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block. If your output buffers are full you must return 0 to signal
+	 *       that the library should retry delivery in a short while.
+	 */
+	int (SP_CALLCONV *music_delivery)(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames);
+
+	/**
+	 * Music has been paused because only one account may play music at the same time.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *play_token_lost)(sp_session *session);
+
+	/**
+	 * Logging callback.
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  data       Log data
+	 */
+	void (SP_CALLCONV *log_message)(sp_session *session, const char *data);
+
+	/**
+	 * End of track.
+	 * Called when the currently played track has reached its end.
+	 *
+	 * @note This function is invoked from the same internal thread
+	 * as the music delivery callback
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *end_of_track)(sp_session *session);
+
+	/**
+	 * Streaming error.
+	 * Called when streaming cannot start or continue
+	 *
+	 * @note This function is invoked from the main thread
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      One of the following errors, from ::sp_error
+	 *                        SP_ERROR_NO_STREAM_AVAILABLE
+	 *                        SP_ERROR_OTHER_TRANSIENT
+	 *                        SP_ERROR_OTHER_PERMANENT
+	 */
+	void (SP_CALLCONV *streaming_error)(sp_session *session, sp_error error);
+
+	/**
+	 * Called after user info (anything related to sp_user objects) have been updated.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *userinfo_updated)(sp_session *session);
+
+	/**
+	 * Called when audio playback should start
+	 *
+	 * @note For this to work correctly the application must also implement get_audio_buffer_stats()
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *start_playback)(sp_session *session);
+
+
+	/**
+	 * Called when audio playback should stop
+	 *
+	 * @note For this to work correctly the application must also implement get_audio_buffer_stats()
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *stop_playback)(sp_session *session);
+
+	/**
+	 * Called to query application about its audio buffer
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block.
+	 *
+	 * @param[in]  session    Session
+	 * @param[out] stats      Stats struct to be filled by application
+	 */
+	void (SP_CALLCONV *get_audio_buffer_stats)(sp_session *session, sp_audio_buffer_stats *stats);
+
+	/**
+	 * Called when offline synchronization status is updated
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *offline_status_updated)(sp_session *session);
+
+	/**
+	 * Called when offline synchronization status is updated
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      Offline error. Will be SP_ERROR_OK if the offline synchronization
+	 *                        error state has cleared
+	 */
+	void (SP_CALLCONV *offline_error)(sp_session *session, sp_error error);
+
+
+} sp_session_callbacks;
+
+/**
+ * Session config
+ */
+typedef struct sp_session_config {
+	int api_version;                       ///< The version of the Spotify API your application is compiled with. Set to #SPOTIFY_API_VERSION
+	const char *cache_location;            /**< The location where Spotify will write cache files.
+						*   This cache include tracks, cached browse results and coverarts.
+	                                        *   Set to empty string ("") to disable cache
+						*/
+	const char *settings_location;         /**< The location where Spotify will write setting files and per-user
+						*   cache items. This includes playlists, track metadata, etc.
+						*   'settings_location' may be the same path as 'cache_location'.
+						*   'settings_location' folder will not be created (unlike 'cache_location'),
+						*   if you don't want to create the folder yourself, you can set 'settings_location' to 'cache_location'.
+						*/
+	const void *application_key;           ///< Your application key
+	size_t application_key_size;           ///< The size of the application key in bytes
+	const char *user_agent;                /**< "User-Agent" for your application - max 255 characters long
+						     The User-Agent should be a relevant, customer facing identification of your application
+					       */
+
+	const sp_session_callbacks *callbacks; ///< Delivery callbacks for session events, or NULL if you are not interested in any callbacks (not recommended!)
+	void *userdata;                        ///< User supplied data for your application
+
+	/**
+	 * Compress local copy of playlists, reduces disk space usage
+	 */
+	bool compress_playlists;
+
+	/**
+	 * Don't save metadata for local copies of playlists
+	 * Reduces disk space usage at the expense of needing
+	 * to request metadata from Spotify backend when loading list
+	 */
+	bool dont_save_metadata_for_playlists;
+
+	/**
+	 * Avoid loading playlists into RAM on startup.
+	 * See sp_playlist_is_in_ram() for more details.
+	 */
+	bool initially_unload_playlists;
+
+	/**
+	 * Device ID for offline synchronization
+	 */
+	const char *device_id;
+
+	/**
+	 * Path to API trace file
+	 */
+	const char *tracefile;
+
+} sp_session_config;
+
+/**
+ * Initialize a session. The session returned will be initialized, but you will need
+ * to log in before you can perform any other operation
+ * Currently it is not supported to have multiple active sessions, and it's recommended to only call this once per process.
+ *
+ * Here is a snippet from \c spshell.c:
+ * @dontinclude spshell.c
+ * @skip config.api_version
+ * @until }
+ *
+ * @param[in]   config    The configuration to use for the session
+ * @param[out]  sess      If successful, a new session - otherwise NULL
+ *
+ * @return                One of the following errors, from ::sp_error
+ *                        SP_ERROR_OK
+ *                        SP_ERROR_BAD_API_VERSION
+ *                        SP_ERROR_BAD_USER_AGENT
+ *                        SP_ERROR_BAD_APPLICATION_KEY
+ *                        SP_ERROR_API_INITIALIZATION_FAILED
+ *                        SP_ERROR_INVALID_DEVICE_ID
+ */
+SP_LIBEXPORT(sp_error) sp_session_create(const sp_session_config *config, sp_session **sess);
+
+/**
+ * Release the session. This will clean up all data and connections associated with the session
+ *
+ * @param[in]   sess      Session object returned from sp_session_create()
+ */
+SP_LIBEXPORT(void) sp_session_release(sp_session *sess);
+
+
+/**
+ * Logs in the specified username/password combo. This initiates the login in the background.
+ * A callback is called when login is complete
+ *
+ * An application MUST NEVER store the user's password in clear text.
+ * If automatic relogin is required, use sp_session_relogin()
+ *
+ * Here is a snippet from \c spshell.c:
+ * @dontinclude spshell.c
+ * @skip sp_session_login
+ * @until }
+ *
+ * @param[in]   session             Your session object
+ * @param[in]   username            The username to log in
+ * @param[in]   password            The password for the specified username
+ * @param[in]   remember_me         If set, the username / password will be remembered by libspotify
+ */
+SP_LIBEXPORT(void) sp_session_login(sp_session *session, const char *username, const char *password, bool remember_me);
+
+
+/**
+ * Log in the remembered user if last user that logged in logged in with remember_me set.
+ * If no credentials are stored, this will return SP_ERROR_NO_CREDENTIALS.
+ *
+ * @param[in]   session      Your session object
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_OK
+ *                         SP_ERROR_NO_CREDENTIALS
+ */
+SP_LIBEXPORT(sp_error) sp_session_relogin(sp_session *session);
+
+
+/**
+ * Get username of the user that will be logged in via sp_session_relogin()
+ *
+ * @param[in]   session      Your session object
+ * @param[out]  buffer       The buffer to hold the username
+ * @param[in]   buffer_size  The max size of the buffer that will hold the username.
+ *                           The resulting string is guaranteed to always be null terminated if
+ *                           buffer_size > 0
+ *
+ * @return                   The number of characters in the username.
+ *                           If value is greater or equal than \p buffer_size, output was truncated.
+ *                           If returned value is -1 no credentials are stored in libspotify.
+ */
+SP_LIBEXPORT(int) sp_session_remembered_user(sp_session *session, char *buffer, size_t buffer_size);
+
+
+/**
+ * Remove stored credentials in libspotify. If no credentials are currently stored, nothing will happen.
+ *
+ * @param[in]   session      Your session object
+ *
+ */
+SP_LIBEXPORT(void) sp_session_forget_me(sp_session *session);
+
+
+/**
+ * Fetches the currently logged in user
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 The logged in user (or NULL if not logged in)
+ */
+SP_LIBEXPORT(sp_user *) sp_session_user(sp_session *session);
+
+/**
+ * Logs out the currently logged in user
+ *
+ * Always call this before terminating the application and libspotify is currently
+ * logged in. Otherwise, the settings and cache may be lost.
+ *
+ * @param[in]   session    Your session object
+ */
+SP_LIBEXPORT(void) sp_session_logout(sp_session *session);
+
+/**
+ * The connection state of the specified session.
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 The connection state - see the sp_connectionstate enum for possible values
+ */
+SP_LIBEXPORT(sp_connectionstate) sp_session_connectionstate(sp_session *session);
+
+/**
+ * The userdata associated with the session
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 The userdata that was passed in on session creation
+ */
+SP_LIBEXPORT(void *) sp_session_userdata(sp_session *session);
+
+/**
+ * Set maximum cache size.
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   size       Maximum cache size in megabytes.
+ *                         Setting it to 0 (the default) will let libspotify automatically
+ *                         resize the cache (10% of disk free space)
+ */
+SP_LIBEXPORT(void) sp_session_set_cache_size(sp_session *session, size_t size);
+
+/**
+ * Make the specified session process any pending events
+ *
+ * @param[in]   session         Your session object
+ * @param[out]  next_timeout    Stores the time (in milliseconds) until you should call this function again
+ */
+SP_LIBEXPORT(void) sp_session_process_events(sp_session *session, int *next_timeout);
+
+/**
+ * Loads the specified track
+ *
+ * After successfully loading the track, you have the option of running
+ * sp_session_player_play() directly, or using sp_session_player_seek() first.
+ * When this call returns, the track will have been loaded, unless an error occurred.
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   track      The track to be loaded
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_OK
+ *                         SP_ERROR_MISSING_CALLBACK
+ *                         SP_ERROR_RESOURCE_NOT_LOADED
+ *                         SP_ERROR_TRACK_NOT_PLAYABLE
+ *
+ */
+SP_LIBEXPORT(sp_error) sp_session_player_load(sp_session *session, sp_track *track);
+
+/**
+ * Seek to position in the currently loaded track
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   offset     Track position, in milliseconds.
+ *
+ */
+SP_LIBEXPORT(void) sp_session_player_seek(sp_session *session, int offset);
+
+/**
+ * Play or pause the currently loaded track
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   play       If set to true, playback will occur. If set to false, the playback will be paused.
+ *
+ */
+SP_LIBEXPORT(void) sp_session_player_play(sp_session *session, bool play);
+
+/**
+ * Stops the currently playing track
+ *
+ * This frees some resources held by libspotify to identify the currently
+ * playing track.
+ *
+ * @param[in]   session    Your session object
+ *
+ */
+SP_LIBEXPORT(void) sp_session_player_unload(sp_session *session);
+
+/**
+ * Prefetch a track
+ *
+ * Instruct libspotify to start loading of a track into its cache.
+ * This could be done by an application just before the current track ends.
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   track      The track to be prefetched
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_NO_CACHE
+ *                         SP_ERROR_OK
+ *
+ * @note Prefetching is only possible if a cache is configured
+ *
+ */
+SP_LIBEXPORT(sp_error) sp_session_player_prefetch(sp_session *session, sp_track *track);
+
+/**
+ * Returns the playlist container for the currently logged in user.
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 Playlist container object, NULL if not logged in
+ */
+SP_LIBEXPORT(sp_playlistcontainer *) sp_session_playlistcontainer(sp_session *session);
+
+/**
+ * Returns an inbox playlist for the currently logged in user
+ *
+ * @param[in]  session        Session object
+ *
+ * @return     A playlist or NULL if no user is logged in
+ * @note You need to release the playlist when you are done with it.
+ * @see sp_playlist_release()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_session_inbox_create(sp_session *session);
+
+/**
+ * Returns the starred list for the current user
+ *
+ * @param[in]  session        Session object
+ *
+ * @return     A playlist or NULL if no user is logged in
+ * @note You need to release the playlist when you are done with it.
+ * @see sp_playlist_release()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_session_starred_create(sp_session *session);
+
+/**
+ * Returns the starred list for a user
+ *
+ * @param[in]  session        Session object
+ * @param[in]  canonical_username       Canonical username
+ *
+ * @return     A playlist or NULL if no user is logged in
+ * @note You need to release the playlist when you are done with it.
+ * @see sp_playlist_release()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_session_starred_for_user_create(sp_session *session, const char *canonical_username);
+
+/**
+ * Return the published container for a given @a canonical_username,
+ * or the currently logged in user if @a canonical_username is NULL.
+ *
+ * When done with the list you should call sp_playlistconatiner_release() to
+ * decrese the reference you own by having created it.
+ *
+ * @param[in]   session    Your session object.
+ * @param[in]   canonical_username   The canonical username, or NULL.
+ *
+ * @return Playlist container object, NULL if not logged in.
+ */
+SP_LIBEXPORT(sp_playlistcontainer *) sp_session_publishedcontainer_for_user_create(sp_session *session, const char *canonical_username);
+
+
+/**
+ * Set preferred bitrate for music streaming
+ *
+ * @param[in]  session        Session object
+ * @param[in]  bitrate        Preferred bitrate, see ::sp_bitrate for possible values
+ *
+ */
+SP_LIBEXPORT(void) sp_session_preferred_bitrate(sp_session *session, sp_bitrate bitrate);
+
+
+/**
+ * Set preferred bitrate for offline sync
+ *
+ * @param[in]  session        Session object
+ * @param[in]  bitrate        Preferred bitrate, see ::sp_bitrate for possible values
+ * @param[in]  allow_resync   Set to true if libspotify should resynchronize already synchronized tracks. Usually you should set this to false.
+ *
+ */
+SP_LIBEXPORT(void) sp_session_preferred_offline_bitrate(sp_session *session, sp_bitrate bitrate, bool allow_resync);
+
+
+/**
+ * Return status of volume normalization
+ *
+ * @param[in]  session        Session object
+ *
+ * @return true iff volume normalization is enabled
+ *
+ */
+SP_LIBEXPORT(bool) sp_session_get_volume_normalization(sp_session *session);
+
+
+/**
+ * Set volume normalization
+ *
+ * @param[in]  session        Session object
+ * @param[in]  on             True iff volume normalization should be enabled
+ *
+ */
+SP_LIBEXPORT(void) sp_session_set_volume_normalization(sp_session *session, bool on);
+
+
+
+/**
+ * Set to true if the connection is currently routed over a roamed connectivity
+ *
+ * @param[in]  session        Session object
+ * @param[in]  type           Connection type
+ *
+ * @note       Used in conjunction with sp_session_set_connection_rules() to control
+ *             how libspotify should behave in respect to network activity and offline
+ *             synchronization.
+ */
+SP_LIBEXPORT(void) sp_session_set_connection_type(sp_session *session, sp_connection_type type);
+
+
+/**
+ * Set rules for how libspotify connects to Spotify servers and synchronizes offline content
+ *
+ * @param[in]  session        Session object
+ * @param[in]  rules          Connection rules
+ *
+ * @note       Used in conjunction with sp_session_set_connection_type() to control
+ *             how libspotify should behave in respect to network activity and offline
+ *             synchronization.
+ */
+SP_LIBEXPORT(void) sp_session_set_connection_rules(sp_session *session, sp_connection_rules rules);
+
+
+
+/**
+ * Get total number of tracks that needs download before everything
+ * from all playlists that is marked for offline is fully synchronized
+ *
+ * @param[in]  session        Session object
+ *
+ * @return Number of tracks
+ */
+SP_LIBEXPORT(int) sp_offline_tracks_to_sync(sp_session *session);
+
+/**
+ * Return number of playlisys that is marked for offline synchronization
+ *
+ * @param[in]  session        Session object
+ *
+ * @return Number of playlists
+ */
+SP_LIBEXPORT(int) sp_offline_num_playlists(sp_session *session);
+
+/**
+ * Return offline synchronization status. When the internal status is
+ * updated the offline_status_updated() callback will be invoked.
+ *
+ * @param[in]  session        Session object
+ * @param[out] status         Status object that will be filled with info
+ *
+ * @return false if no synching is in progress (in which case the contents
+ *               of status is undefined)
+ *
+ */
+SP_LIBEXPORT(bool) sp_offline_sync_get_status(sp_session *session, sp_offline_sync_status *status);
+
+/**
+ * Return remaining time (in seconds) until the offline key store expires
+ * and the user is required to relogin
+ *
+ * @param[in]  session        Session object
+ * @return                    Seconds until expiration
+ *
+ */
+SP_LIBEXPORT(int) sp_offline_time_left(sp_session *session);
+
+/**
+ * Get currently logged in users country
+ * updated the offline_status_updated() callback will be invoked.
+ *
+ * @param[in]  session        Session object
+ *
+ * @return  Country encoded in an integer 'SE' = 'S' << 8 | 'E'
+ */
+SP_LIBEXPORT(int) sp_session_user_country(sp_session *session);
+
+
+/** @} */
+
+
+/**
+ * @defgroup link Links (Spotify URIs)
+ *
+ * These functions handle links to Spotify entities in a way that allows you to
+ * not care about the textual representation of the link.
+ * @{
+ */
+
+/**
+ * Link types
+ */
+typedef enum {
+	SP_LINKTYPE_INVALID  = 0, ///< Link type not valid - default until the library has parsed the link, or when parsing failed
+	SP_LINKTYPE_TRACK    = 1, ///< Link type is track
+	SP_LINKTYPE_ALBUM    = 2, ///< Link type is album
+	SP_LINKTYPE_ARTIST   = 3, ///< Link type is artist
+	SP_LINKTYPE_SEARCH   = 4, ///< Link type is search
+	SP_LINKTYPE_PLAYLIST = 5, ///< Link type is playlist
+	SP_LINKTYPE_PROFILE  = 6, ///< Link type is profile
+	SP_LINKTYPE_STARRED  = 7, ///< Link type is starred
+	SP_LINKTYPE_LOCALTRACK  = 8, ///< Link type is a local file
+	SP_LINKTYPE_IMAGE = 9, ///< Link type is an image
+} sp_linktype;
+
+/**
+ * Create a Spotify link given a string
+ *
+ * @param[in]   link       A string representation of a Spotify link
+ *
+ * @return                 A link representation of the given string representation.
+ *                         If the link could not be parsed, this function returns NULL.
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_type()
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_string(const char *link);
+
+/**
+ * Generates a link object from a track
+ *
+ * @param[in]   track        A track object
+ * @param[in]   offset       Offset in track in ms.
+ *
+ * @return                   A link representing the track
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_track(sp_track *track, int offset);
+
+/**
+ * Create a link object from an album
+ *
+ * @param[in]   album      An album object
+ *
+ * @return                 A link representing the album
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_album(sp_album *album);
+
+/**
+ * Create an image link object from an album
+ *
+ * @param[in]   album      An album object
+ *
+ * @return                 A link representing the album cover. Type is set to SP_LINKTYPE_IMAGE
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_album_cover(sp_album *album);
+
+/**
+ * Creates a link object from an artist
+ *
+ * @param[in]   artist     An artist object
+ *
+ * @return                 A link object representing the artist
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_artist(sp_artist *artist);
+
+/**
+ * Creates a link object pointing to an artist portrait
+ *
+ * @param[in]   artist     Artist browse object
+ *
+ * @return                 A link object representing an image
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ * @see sp_artistbrowse_num_portraits()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_artist_portrait(sp_artist *artist);
+
+
+/**
+ * Creates a link object from an artist portrait
+ *
+ * @param[in]   arb        Artist browse object
+ * @param[in]   index      The index of the portrait. Should be in the interval [0, sp_artistbrowse_num_portraits() - 1]
+ *
+ * @return                 A link object representing an image
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ * @see sp_artistbrowse_num_portraits()
+ *
+ * @note The difference from sp_link_create_from_artist_portrait() is
+ * that the artist browse object may contain multiple portraits.
+ *
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_artistbrowse_portrait(sp_artistbrowse *arb, int index);
+
+
+/**
+ * Generate a link object representing the current search
+ *
+ * @param[in]  search       Search object
+ *
+ * @return                  A link representing the search
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_search(sp_search *search);
+
+/**
+ * Create a link object representing the given playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return                    A link representing the playlist
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ *
+ * @note Due to reasons in the playlist backend design and the Spotify URI
+ * scheme you need to wait for the playlist to be loaded before you can
+ * successfully construct an URI. If sp_link_create_from_playlist() returns
+ * NULL, try again after teh playlist_state_changed callback has fired.
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_playlist(sp_playlist *playlist);
+
+/**
+ * Create a link object representing the given playlist
+ *
+ * @param[in]  user       User object
+ *
+ * @return                    A link representing the profile.
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_user(sp_user *user);
+
+/**
+ * Create a link object representing the given image
+ *
+ * @param[in]  image          Image object
+ *
+ * @return                    A link representing the image.
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_image(sp_image *image);
+
+/**
+ * Create a string representation of the given Spotify link
+ *
+ * @param[in]   link         The Spotify link whose string representation you are interested in
+ * @param[out]  buffer       The buffer to hold the string representation of link
+ * @param[in]   buffer_size  The max size of the buffer that will hold the string representation
+ *                           The resulting string is guaranteed to always be null terminated if
+ *                           buffer_size > 0
+ *
+ * @return                   The number of characters in the string representation of the link. If this
+ *                           value is greater or equal than \p buffer_size, output was truncated.
+ */
+SP_LIBEXPORT(int) sp_link_as_string(sp_link *link, char *buffer, int buffer_size);
+
+/**
+ * The link type of the specified link
+ *
+ * @param[in]   link       The Spotify link whose type you are interested in
+ *
+ * @return                 The link type of the specified link - see the sp_linktype enum for possible values
+ */
+SP_LIBEXPORT(sp_linktype) sp_link_type(sp_link *link);
+
+/**
+ * The track representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose track you are interested in
+ *
+ * @return                 The track representation of the given track link
+ *                         If the link is not of track type then NULL is returned.
+ */
+SP_LIBEXPORT(sp_track *) sp_link_as_track(sp_link *link);
+
+/**
+ * The track and offset into track representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose track you are interested in
+ * @param[out]  offset     Pointer to offset into track (in milliseconds). If the link
+ *                         does not contain an offset this will be set to 0.
+ *
+ * @return                 The track representation of the given track link
+ *                         If the link is not of track type then NULL is returned.
+ */
+SP_LIBEXPORT(sp_track *) sp_link_as_track_and_offset(sp_link *link, int *offset);
+
+/**
+ * The album representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose album you are interested in
+ *
+ * @return                 The album representation of the given album link
+ *                         If the link is not of album type then NULL is returned
+ */
+SP_LIBEXPORT(sp_album *) sp_link_as_album(sp_link *link);
+
+/**
+ * The artist representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose artist you are interested in
+ *
+ * @return                 The artist representation of the given link
+ *                         If the link is not of artist type then NULL is returned
+ */
+SP_LIBEXPORT(sp_artist *) sp_link_as_artist(sp_link *link);
+
+
+/**
+ * The user representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose user you are interested in
+ *
+ * @return                 The user representation of the given link
+ *                         If the link is not of user type then NULL is returned
+ */
+SP_LIBEXPORT(sp_user *) sp_link_as_user(sp_link *link);
+
+
+/**
+ * Increase the reference count of a link
+ *
+ * @param[in]   link       The link object
+ */
+SP_LIBEXPORT(void) sp_link_add_ref(sp_link *link);
+
+/**
+ * Decrease the reference count of a link
+ *
+ * @param[in]   link       The link object
+ */
+SP_LIBEXPORT(void) sp_link_release(sp_link *link);
+
+/** @} */
+
+
+
+/**
+ * @defgroup track Track subsystem
+ * @{
+ */
+
+/**
+ * Return whether or not the track metadata is loaded.
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is loaded
+ *
+ * @note  This is equivalent to checking if sp_track_error() not returns SP_ERROR_IS_LOADING.
+ */
+SP_LIBEXPORT(bool) sp_track_is_loaded(sp_track *track);
+
+/**
+ * Return an error code associated with a track. For example if it could not load
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_OK
+ *                         SP_ERROR_IS_LOADING
+ *                         SP_ERROR_OTHER_PERMANENT
+ */
+SP_LIBEXPORT(sp_error) sp_track_error(sp_track *track);
+
+
+/**
+ * Return offline status for a track. sp_session_callbacks::metadata_updated() will be invoked when
+ * offline status of a track changes
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 Stats as described by ::sp_track_offline_status
+ *
+ */
+SP_LIBEXPORT(sp_track_offline_status) sp_track_offline_get_status(sp_track *track);
+
+/**
+ * Return availability for a track
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 Availability status, see ::sp_track_availability
+ *
+ * @note The track must be loaded or this function will always SP_TRACK_AVAILABILITY_UNAVAILABLE
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(sp_track_availability) sp_track_get_availability(sp_session *session, sp_track *track);
+
+/**
+ * Return true if the track is a local file.
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is a local file.
+ *
+ * @note The track must be loaded or this function will always return false.
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_track_is_local(sp_session *session, sp_track *track);
+
+/**
+ * Return true if the track is autolinked to another track.
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is autolinked.
+ *
+ * @note The track must be loaded or this function will always return false.
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_track_is_autolinked(sp_session *session, sp_track *track);
+
+/**
+ * Return true if the track is a placeholder. Placeholder tracks are used
+ * to store other objects than tracks in the playlist. Currently this is
+ * used in the inbox to store artists, albums and playlists.
+ *
+ * Use sp_link_create_from_track() to get a link object that points
+ * to the real object this "track" points to.
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is a placeholder
+ *
+ * @note Contrary to most functions the track does not have to be
+ *       loaded for this function to return correct value
+ */
+SP_LIBEXPORT(bool) sp_track_is_placeholder(sp_track *track);
+
+
+/**
+ * Return true if the track is starred by the currently logged in user.
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is starred.
+ *
+ * @note The track must be loaded or this function will always return false.
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_track_is_starred(sp_session *session, sp_track *track);
+
+/**
+ * Star/Unstar the specified track
+ *
+ * @param[in]   session    Session
+ * @param[in]   tracks     Array of pointer to tracks.
+ * @param[in]   num_tracks Length of \p tracks array
+ * @param[in]   star       Starred status of the track
+ *
+ * @note This will fail silently if playlists are disabled.
+ * @see sp_set_playlists_enabled()
+ */
+SP_LIBEXPORT(void) sp_track_set_starred(sp_session *session, sp_track *const*tracks, int num_tracks, bool star);
+
+/**
+ * The number of artists performing on the specified track
+ *
+ * @param[in]   track     The track whose number of participating artists you are interested in
+ *
+ * @return                The number of artists performing on the specified track.
+ *                        If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(int) sp_track_num_artists(sp_track *track);
+
+/**
+ * The artist matching the specified index performing on the current track.
+ *
+ * @param[in]   track      The track whose participating artist you are interested in
+ * @param[in]   index      The index for the participating artist. Should be in the interval [0, sp_track_num_artists() - 1]
+ *
+ * @return                 The participating artist, or NULL if invalid index
+ */
+SP_LIBEXPORT(sp_artist *) sp_track_artist(sp_track *track, int index);
+
+/**
+ * The album of the specified track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 The album of the given track. You need to increase the refcount
+ *                         if you want to keep the pointer around.
+ *                         If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(sp_album *) sp_track_album(sp_track *track);
+
+/**
+ * The string representation of the specified track's name
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 The string representation of the specified track's name.
+ *                         Returned string is valid as long as the album object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ *                         If no metadata is available for the track yet, this function returns empty string.
+ */
+SP_LIBEXPORT(const char *) sp_track_name(sp_track *track);
+
+/**
+ * The duration, in milliseconds, of the specified track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 The duration of the specified track, in milliseconds
+ *                         If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(int) sp_track_duration(sp_track *track);
+
+/**
+ * Returns popularity for track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 Popularity in range 0 to 100, 0 if undefined.
+ *                         If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(int) sp_track_popularity(sp_track *track);
+
+/**
+ * Returns the disc number for a track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 Disc index. Possible values are [1, total number of discs on album]
+ *                         This function returns valid data only for tracks appearing in a browse
+ *                         artist or browse album result (otherwise returns 0).
+ */
+SP_LIBEXPORT(int) sp_track_disc(sp_track *track);
+
+/**
+ * Returns the position of a track on its disc
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 Track position, starts at 1 (relative the corresponding disc)
+ *                         This function returns valid data only for tracks appearing in a browse
+ *                         artist or browse album result (otherwise returns 0).
+ */
+SP_LIBEXPORT(int) sp_track_index(sp_track *track);
+
+/**
+ * Returns the newly created local track
+ *
+ * @param[in]   artist     Name of the artist
+ * @param[in]   title      Song title
+ * @param[in]   album      Name of the album, or an empty string if not available
+ * @param[in]   length      Length in MS, or -1 if not available.
+ *
+ * @return                 A track.
+ */
+SP_LIBEXPORT(sp_track *) sp_localtrack_create(const char *artist, const char *title, const char *album, int length);
+
+/**
+ * Increase the reference count of a track
+ *
+ * @param[in]   track       The track object
+ */
+SP_LIBEXPORT(void) sp_track_add_ref(sp_track *track);
+
+/**
+ * Decrease the reference count of a track
+ *
+ * @param[in]   track       The track object
+ */
+SP_LIBEXPORT(void) sp_track_release(sp_track *track);
+
+/** @} */
+
+
+
+/**
+ * @defgroup album Album subsystem
+ * @{
+ */
+
+/**
+ * Album types
+ */
+typedef enum {
+	SP_ALBUMTYPE_ALBUM       = 0, ///< Normal album
+	SP_ALBUMTYPE_SINGLE      = 1, ///< Single
+	SP_ALBUMTYPE_COMPILATION = 2, ///< Compilation
+	SP_ALBUMTYPE_UNKNOWN     = 3, ///< Unknown type
+} sp_albumtype;
+
+/**
+ * Check if the album object is populated with data
+ *
+ * @param[in]  album       Album object
+ * @return True if metadata is present, false if not
+ */
+SP_LIBEXPORT(bool) sp_album_is_loaded(sp_album *album);
+
+
+/**
+ * Return true if the album is available in the current region.
+ *
+ * @param[in]   album      The album
+ *
+ * @return                 True if album is available for playback, otherwise false.
+ *
+ * @note The album must be loaded or this function will always return false.
+ * @see sp_album_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_album_is_available(sp_album *album);
+
+/**
+ * Get the artist associated with the given album
+ *
+ * @param[in]  album       Album object
+ * @return A reference to the artist. NULL if the metadata has not been loaded yet
+ */
+SP_LIBEXPORT(sp_artist *) sp_album_artist(sp_album *album);
+
+/**
+ * Return image ID representing the album's coverart.
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 ID byte sequence that can be passed to sp_image_create()
+ *                         If the album has no image or the metadata for the album is not
+ *                         loaded yet, this function returns NULL.
+ *
+ * @see sp_image_create
+ */
+SP_LIBEXPORT(const s_byte *) sp_album_cover(sp_album *album);
+
+/**
+ * Return name of album
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 Name of album.
+ *                         Returned string is valid as long as the album object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_album_name(sp_album *album);
+
+/**
+ * Return release year of specified album
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 Release year
+ */
+SP_LIBEXPORT(int) sp_album_year(sp_album *album);
+
+
+/**
+ * Return type of specified album
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 sp_albumtype
+ */
+SP_LIBEXPORT(sp_albumtype) sp_album_type(sp_album *album);
+
+
+/**
+ * Increase the reference count of an album
+ *
+ * @param[in]   album       The album object
+ */
+SP_LIBEXPORT(void) sp_album_add_ref(sp_album *album);
+
+/**
+ * Decrease the reference count of an album
+ *
+ * @param[in]   album       The album object
+ */
+SP_LIBEXPORT(void) sp_album_release(sp_album *album);
+
+/** @} */
+
+
+
+/**
+ * @defgroup artist Artist subsystem
+ * @{
+ */
+
+/**
+ * Return name of artist
+ *
+ * @param[in]   artist     Artist object
+ *
+ * @return                 Name of artist.
+ *                         Returned string is valid as long as the artist object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_artist_name(sp_artist *artist);
+
+/**
+ * Check if the artist object is populated with data
+ *
+ * @param[in]   artist     An artist object
+ *
+ * @return                 True if metadata is present, false if not
+ *
+ */
+SP_LIBEXPORT(bool) sp_artist_is_loaded(sp_artist *artist);
+
+/**
+ * Return portrait for artist
+ *
+ * @param[in]   artist       The artist object
+ *
+ * @return                 ID byte sequence that can be passed to sp_image_create()
+ *                         If the album has no image or the metadata for the album is not
+ *                         loaded yet, this function returns NULL.
+ *
+ */
+SP_LIBEXPORT(const s_byte *) sp_artist_portrait(sp_artist *artist);
+
+/**
+ * Increase the reference count of a artist
+ *
+ * @param[in]   artist       The artist object
+ */
+SP_LIBEXPORT(void) sp_artist_add_ref(sp_artist *artist);
+
+/**
+ * Decrease the reference count of a artist
+ *
+ * @param[in]   artist       The artist object
+ */
+SP_LIBEXPORT(void) sp_artist_release(sp_artist *artist);
+
+/** @} */
+
+
+/**
+ * @defgroup albumbrowse Album browsing
+ *
+ * Browsing adds additional information to what an ::sp_album holds. It retrieves
+ * copyrights, reviews and tracks of the album.
+ *
+ * @{
+ */
+
+/**
+ * The type of a callback used in sp_albumbrowse_create()
+ *
+ * When the callback is called, the metadata of all tracks belonging to it will have
+ * been loaded, so sp_track_is_loaded() will return non-zero. The ::sp_artist of the
+ * album will also have been fully loaded.
+ *
+ * @param[in]   result          The same pointer returned by sp_albumbrowse_create()
+ * @param[in]   userdata        The opaque pointer given to sp_albumbrowse_create()
+ */
+typedef void SP_CALLCONV albumbrowse_complete_cb(sp_albumbrowse *result, void *userdata);
+
+/**
+ * Initiate a request for browsing an album
+ *
+ * The user is responsible for freeing the returned album browse using sp_albumbrowse_release(). This can be done in the callback.
+ *
+ * @param[in]   session         Session object
+ * @param[in]   album           Album to be browsed. The album metadata does not have to be loaded
+ * @param[in]   callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.
+ * @param[in]   userdata        Userdata passed to callback.
+ *
+ * @return                      Album browse object
+ *
+ * @see ::albumbrowse_complete_cb
+ */
+SP_LIBEXPORT(sp_albumbrowse *) sp_albumbrowse_create(sp_session *session, sp_album *album, albumbrowse_complete_cb *callback, void *userdata);
+
+/**
+ * Check if an album browse request is completed
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 True if browsing is completed, false if not
+ */
+SP_LIBEXPORT(bool) sp_albumbrowse_is_loaded(sp_albumbrowse *alb);
+
+
+/**
+* Check if browsing returned an error code.
+*
+* @param[in]   alb        Album browse object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_albumbrowse_error(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return the pointer to its album object
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Album object
+ */
+SP_LIBEXPORT(sp_album *) sp_albumbrowse_album(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return the pointer to its artist object
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Artist object
+ */
+SP_LIBEXPORT(sp_artist *) sp_albumbrowse_artist(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return number of copyright strings
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Number of copyright strings available, 0 if unknown
+ */
+SP_LIBEXPORT(int) sp_albumbrowse_num_copyrights(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return one of its copyright strings
+ *
+ * @param[in]   alb           Album browse object
+ * @param[in]   index         The index for the copyright string. Should be in the interval [0, sp_albumbrowse_num_copyrights() - 1]
+ *
+ * @return                    Copyright string in UTF-8 format, or NULL if the index is invalid.
+ *                            Returned string is valid as long as the album object stays allocated
+ *                            and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_albumbrowse_copyright(sp_albumbrowse *alb, int index);
+
+/**
+ * Given an album browse object, return number of tracks
+ *
+ * @param[in]   alb         Album browse object
+ *
+ * @return                  Number of tracks on album
+ */
+SP_LIBEXPORT(int) sp_albumbrowse_num_tracks(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return a pointer to one of its tracks
+ *
+ * @param[in]   alb        Album browse object
+ * @param[in]   index      The index for the track. Should be in the interval [0, sp_albumbrowse_num_tracks() - 1]
+ *
+ * @return                 A track.
+ *
+ * @see track
+ */
+SP_LIBEXPORT(sp_track *) sp_albumbrowse_track(sp_albumbrowse *alb, int index);
+
+/**
+ * Given an album browse object, return its review
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Review string in UTF-8 format.
+ *                         Returned string is valid as long as the album object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_albumbrowse_review(sp_albumbrowse *alb);
+
+/**
+ * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request
+ *
+ * @param[in] alb         Album browse object
+ *
+ * @return                -1 if the request was served from the local cache
+ *                        If the result is not yet loaded the return value is undefined
+ */
+SP_LIBEXPORT(int) sp_albumbrowse_backend_request_duration(sp_albumbrowse *alb);
+
+
+/**
+ * Increase the reference count of an album browse result
+ *
+ * @param[in]   alb       The album browse result object
+ */
+SP_LIBEXPORT(void) sp_albumbrowse_add_ref(sp_albumbrowse *alb);
+
+/**
+ * Decrease the reference count of an album browse result
+ *
+ * @param[in]   alb       The album browse result object
+ */
+SP_LIBEXPORT(void) sp_albumbrowse_release(sp_albumbrowse *alb);
+
+/** @} */
+
+
+/**
+ * @defgroup artistbrowse Artist browsing
+ *
+ * Artist browsing initiates the fetching of information for a certain artist.
+ *
+ * @note   There is currently no built-in functionality available for getting the albums belonging
+ *         to an artist. For now, just iterate over all tracks and note the album to build a list of all albums.
+ *         This feature will be added in a future version of the library.
+ *
+ * @{
+ */
+
+/**
+ * The type of a callback used in sp_artistbrowse_create()
+ *
+ * When the callback is called, the metadata of all tracks belonging to it will have
+ * been loaded, so sp_track_is_loaded() will return non-zero. The same goes for the
+ * similar artist data.
+ *
+ * @param[in]   result          The same pointer returned by sp_artistbrowse_create()
+ * @param[in]   userdata        The opaque pointer given to sp_artistbrowse_create()
+ */
+typedef void SP_CALLCONV artistbrowse_complete_cb(sp_artistbrowse *result, void *userdata);
+
+/**
+ * Initiate a request for browsing an artist
+ *
+ * The user is responsible for freeing the returned artist browse using sp_artistbrowse_release(). This can be done in the callback.
+ *
+ * @param[in] session         Session object
+ * @param[in] artist          Artist to be browsed. The artist metadata does not have to be loaded
+ * @param[in] type            Type of data requested, see the sp_artistbrowse_type enum for details
+ * @param[in] callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.
+ * @param[in] userdata        Userdata passed to callback.
+ *
+ * @return                    Artist browse object
+ *
+ * @see ::artistbrowse_complete_cb
+ */
+SP_LIBEXPORT(sp_artistbrowse *) sp_artistbrowse_create(sp_session *session, sp_artist *artist, sp_artistbrowse_type type, artistbrowse_complete_cb *callback, void *userdata);
+
+/**
+ * Check if an artist browse request is completed
+ *
+ * @param[in]   arb        Artist browse object
+ *
+ * @return                 True if browsing is completed, false if not
+ */
+SP_LIBEXPORT(bool) sp_artistbrowse_is_loaded(sp_artistbrowse *arb);
+
+/**
+* Check if browsing returned an error code.
+*
+* @param[in]   arb        Artist browse object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_artistbrowse_error(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return a pointer to its artist object
+ *
+ * @param[in]   arb        Artist browse object
+ *
+ * @return                 Artist object
+ */
+SP_LIBEXPORT(sp_artist *) sp_artistbrowse_artist(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return number of portraits available
+ *
+ * @param[in]   arb        Artist browse object
+ *
+ * @return                 Number of portraits for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_portraits(sp_artistbrowse *arb);
+
+/**
+ * Return image ID representing a portrait of the artist
+ *
+ * @param[in] arb             Artist object
+ * @param[in] index           The index of the portrait. Should be in the interval [0, sp_artistbrowse_num_portraits() - 1]
+ *
+ * @return                    ID byte sequence that can be passed to sp_image_create()
+ *
+ * @see sp_image_create
+ */
+SP_LIBEXPORT(const s_byte *) sp_artistbrowse_portrait(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return number of tracks
+ *
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Number of tracks for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_tracks(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return one of its tracks
+ *
+ * @param[in] arb             Album browse object
+ * @param[in] index           The index for the track. Should be in the interval [0, sp_artistbrowse_num_tracks() - 1]
+ *
+ * @return                    A track object, or NULL if the index is out of range.
+ *
+ * @see track
+ */
+SP_LIBEXPORT(sp_track *) sp_artistbrowse_track(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return number of albums
+ *
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Number of albums for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_albums(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return one of its albums
+ *
+ * @param[in] arb             Album browse object
+ * @param[in] index           The index for the album. Should be in the interval [0, sp_artistbrowse_num_albums() - 1]
+ *
+ * @return                    A album object, or NULL if the index is out of range.
+ *
+ * @see album
+ */
+SP_LIBEXPORT(sp_album *) sp_artistbrowse_album(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return number of similar artists
+ *
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Number of similar artists for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_similar_artists(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return a similar artist by index
+ *
+ * @param[in] arb             Album browse object
+ * @param[in] index           The index for the artist. Should be in the interval [0, sp_artistbrowse_num_similar_artists() - 1]
+ *
+ * @return                    A pointer to an artist object.
+ *
+ * @see artist
+ */
+SP_LIBEXPORT(sp_artist *) sp_artistbrowse_similar_artist(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return the artists biography
+ *
+ * @note This function must be called from the same thread that did sp_session_create()
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Biography string in UTF-8 format.
+ *                            Returned string is valid as long as the album object stays allocated
+ *                            and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_artistbrowse_biography(sp_artistbrowse *arb);
+
+/**
+ * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request
+ *
+ * @param[in] arb         Artist browse object
+ *
+ * @return                -1 if the request was served from the local cache
+ *                        If the result is not yet loaded the return value is undefined
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_backend_request_duration(sp_artistbrowse *arb);
+
+
+/**
+ * Increase the reference count of an artist browse result
+ *
+ * @param[in]   arb       The artist browse result object
+ */
+SP_LIBEXPORT(void) sp_artistbrowse_add_ref(sp_artistbrowse *arb);
+
+/**
+ * Decrease the reference count of an artist browse result
+ *
+ * @param[in]   arb       The artist browse result object
+ */
+SP_LIBEXPORT(void) sp_artistbrowse_release(sp_artistbrowse *arb);
+
+/** @} */
+
+
+
+/**
+ * @defgroup image Image handling
+ * @{
+ */
+
+/**
+ * Image format
+ */
+typedef enum {
+	SP_IMAGE_FORMAT_UNKNOWN = -1, ///< Unknown image format
+	SP_IMAGE_FORMAT_JPEG   = 0,   ///< JPEG image
+} sp_imageformat;
+
+/**
+ * The type of a callback used to notify the application that an image
+ * is done loading.
+ */
+typedef void SP_CALLCONV image_loaded_cb(sp_image *image, void *userdata);
+
+/**
+ * Create an image object
+ *
+ * @param[in]  session    Session
+ * @param[in]  image_id   Spotify image ID
+ *
+ * @return                Pointer to an image object. To free the object, use
+ *                        sp_image_release()
+ *
+ * @see sp_album_cover
+ * @see sp_artistbrowse_portrait
+ */
+SP_LIBEXPORT(sp_image *) sp_image_create(sp_session *session, const s_byte image_id[20]);
+
+/**
+ * Create an image object from a link
+ *
+ * @param[in]  session    Session
+ * @param[in]  l          Spotify link object. This must be of SP_LINKTYPE_IMAGE type
+ *
+ * @return                Pointer to an image object. To free the object, use
+ *                        sp_image_release()
+ *
+ * @see sp_image_create
+ */
+SP_LIBEXPORT(sp_image *) sp_image_create_from_link(sp_session *session, sp_link *l);
+
+/**
+ * Add a callback that will be invoked when the image is loaded
+ *
+ * If an image is loaded, and loading fails, the image will behave like an
+ * empty image.
+ *
+ * @param[in]  image      Image object
+ * @param[in]  callback   Callback that will be called when image has been
+ *                        fetched.
+ * @param[in]  userdata   Opaque pointer passed to \p callback
+ *
+ */
+SP_LIBEXPORT(void) sp_image_add_load_callback(sp_image *image, image_loaded_cb *callback, void *userdata);
+
+/**
+ * Remove an image load callback previously added with sp_image_add_load_callback()
+ *
+ * @param[in]  image      Image object
+ * @param[in]  callback   Callback that will not be called when image has been
+ *                        fetched.
+ * @param[in]  userdata   Opaque pointer passed to \p callback
+ *
+ */
+SP_LIBEXPORT(void) sp_image_remove_load_callback(sp_image *image, image_loaded_cb *callback, void *userdata);
+
+/**
+ * Check if an image is loaded. Before the image is loaded, the rest of the
+ * methods will behave as if the image is empty.
+ *
+ * @param[in]  image      Image object
+ *
+ * @return                True if image is loaded, false otherwise
+ */
+SP_LIBEXPORT(bool) sp_image_is_loaded(sp_image *image);
+
+/**
+* Check if image retrieval returned an error code.
+*
+* @param[in]   image      Image object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_image_error(sp_image *image);
+
+/**
+ * Get image format
+ *
+ * @param[in]  image      Image object
+ *
+ * @return                Image format as described by sp_imageformat
+ */
+SP_LIBEXPORT(sp_imageformat) sp_image_format(sp_image *image);
+
+/**
+* Get image data
+*
+* @param[in]  image      Image object
+* @param[out] data_size  Size of raw image data
+*
+* @return                Pointer to raw image data
+*/
+
+SP_LIBEXPORT(const void *) sp_image_data(sp_image *image, size_t *data_size);
+
+/**
+ * Get image ID
+ *
+ * @param[in]  image      Image object
+ *
+ * @return                Image ID
+ */
+SP_LIBEXPORT(const s_byte *) sp_image_image_id(sp_image *image);
+
+
+/**
+ * Increase the reference count of an image
+ *
+ * @param[in]   image     The image object
+ */
+SP_LIBEXPORT(void) sp_image_add_ref(sp_image *image);
+
+/**
+ * Decrease the reference count of an image
+ *
+ * @param[in]   image     The image object
+ */
+SP_LIBEXPORT(void) sp_image_release(sp_image *image);
+
+/** @} */
+
+
+
+
+/**
+ * @defgroup search Search subsystem
+ * @{
+ */
+
+/**
+ * List of genres for radio query. Multiple genres can be combined by OR:ing the genres together
+ */
+typedef enum sp_radio_genre {
+  SP_RADIO_GENRE_ALT_POP_ROCK = 0x1,
+  SP_RADIO_GENRE_BLUES        = 0x2,
+  SP_RADIO_GENRE_COUNTRY      = 0x4,
+  SP_RADIO_GENRE_DISCO        = 0x8,
+  SP_RADIO_GENRE_FUNK         = 0x10,
+  SP_RADIO_GENRE_HARD_ROCK    = 0x20,
+  SP_RADIO_GENRE_HEAVY_METAL  = 0x40,
+  SP_RADIO_GENRE_RAP          = 0x80,
+  SP_RADIO_GENRE_HOUSE        = 0x100,
+  SP_RADIO_GENRE_JAZZ         = 0x200,
+  SP_RADIO_GENRE_NEW_WAVE     = 0x400,
+  SP_RADIO_GENRE_RNB          = 0x800,
+  SP_RADIO_GENRE_POP          = 0x1000,
+  SP_RADIO_GENRE_PUNK         = 0x2000,
+  SP_RADIO_GENRE_REGGAE       = 0x4000,
+  SP_RADIO_GENRE_POP_ROCK     = 0x8000,
+  SP_RADIO_GENRE_SOUL         = 0x10000,
+  SP_RADIO_GENRE_TECHNO       = 0x20000,
+} sp_radio_genre;
+
+/**
+ * The type of a callback used in sp_search_create()
+ *
+ * When this callback is called, the sp_track_is_loaded(), sp_album_is_loaded(),
+ * and sp_artist_is_loaded() functions will return non-zero for the objects
+ * contained in the search result.
+ *
+ * @param[in]   result          The same pointer returned by sp_search_create()
+ * @param[in]   userdata        The opaque pointer given to sp_search_create()
+ */
+typedef void SP_CALLCONV search_complete_cb(sp_search *result, void *userdata);
+
+/**
+ * Create a search object from the given query
+ *
+ * @param[in]  session    Session
+ * @param[in]  query      Query search string, e.g. 'The Rolling Stones' or 'album:"The Black Album"'
+ * @param[in]  track_offset     The offset among the tracks of the result
+ * @param[in]  track_count      The number of tracks to ask for
+ * @param[in]  album_offset     The offset among the albums of the result
+ * @param[in]  album_count      The number of albums to ask for
+ * @param[in]  artist_offset    The offset among the artists of the result
+ * @param[in]  artist_count      The number of artists to ask for
+ * @param[in]  callback   Callback that will be called once the search operation is complete. Pass NULL if you are not interested in this event.
+ * @param[in]  userdata   Opaque pointer passed to \p callback
+ *
+ * @return                Pointer to a search object. To free the object, use sp_search_release()
+ */
+SP_LIBEXPORT(sp_search *) sp_search_create(sp_session *session, const char *query, int track_offset, int track_count, int album_offset, int album_count, int artist_offset, int artist_count, search_complete_cb *callback, void *userdata);
+
+/**
+ * Create a search object from the radio channel
+ *
+ * @param[in]  session          Session
+ * @param[in]  from_year        Include tracks starting from this year
+ * @param[in]  to_year          Include tracks up to this year
+ * @param[in]  genres           Bitmask of genres to include
+ * @param[in]  callback         Callback that will be called once the search operation is complete. Pass NULL if you are not interested in this event.
+ * @param[in]  userdata         Opaque pointer passed to \p callback
+ *
+ * @return                      Pointer to a search object. To free the object, use sp_search_release()
+ */
+SP_LIBEXPORT(sp_search *) sp_radio_search_create(sp_session *session, unsigned int from_year, unsigned int to_year, sp_radio_genre genres, search_complete_cb *callback, void *userdata);
+
+
+/**
+ * Get load status for the specified search. Before it is loaded, it will behave as an empty search result.
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              True if search is loaded, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_search_is_loaded(sp_search *search);
+
+/**
+* Check if search returned an error code.
+*
+* @param[in]   search     Search object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_search_error(sp_search *search);
+
+/**
+ * Get the number of tracks for the specified search
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              The number of tracks for the specified search
+ */
+SP_LIBEXPORT(int) sp_search_num_tracks(sp_search *search);
+
+/**
+ * Return the track at the given index in the given search object
+ *
+ * @param[in]  search     Search object
+ * @param[in]  index      Index of the wanted track. Should be in the interval [0, sp_search_num_tracks() - 1]
+ *
+ * @return                The track at the given index in the given search object
+ */
+SP_LIBEXPORT(sp_track *) sp_search_track(sp_search *search, int index);
+
+/**
+ * Get the number of albums for the specified search
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              The number of albums for the specified search
+ */
+SP_LIBEXPORT(int) sp_search_num_albums(sp_search *search);
+
+/**
+ * Return the album at the given index in the given search object
+ *
+ * @param[in]  search     Search object
+ * @param[in]  index      Index of the wanted album. Should be in the interval [0, sp_search_num_albums() - 1]
+ *
+ * @return                The album at the given index in the given search object
+ */
+SP_LIBEXPORT(sp_album *) sp_search_album(sp_search *search, int index);
+
+/**
+ * Get the number of artists for the specified search
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              The number of artists for the specified search
+ */
+SP_LIBEXPORT(int) sp_search_num_artists(sp_search *search);
+
+/**
+ * Return the artist at the given index in the given search object
+ *
+ * @param[in]  search     Search object
+ * @param[in]  index      Index of the wanted artist. Should be in the interval [0, sp_search_num_artists() - 1]
+ *
+ * @return                The artist at the given index in the given search object
+ */
+SP_LIBEXPORT(sp_artist *) sp_search_artist(sp_search *search, int index);
+
+/**
+ * Return the search query for the given search object
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The search query for the given search object
+ */
+SP_LIBEXPORT(const char *) sp_search_query(sp_search *search);
+
+/**
+ * Return the "Did you mean" query for the given search object
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The "Did you mean" query for the given search object, or the empty string if no such info is available
+ */
+SP_LIBEXPORT(const char *) sp_search_did_you_mean(sp_search *search);
+
+/**
+ * Return the total number of tracks for the search query - regardless of the interval requested at creation.
+ * If this value is larger than the interval specified at creation of the search object, more search results are available.
+ * To fetch these, create a new search object with a new interval.
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The total number of tracks matching the original query
+ */
+SP_LIBEXPORT(int) sp_search_total_tracks(sp_search *search);
+
+/**
+ * Return the total number of albums for the search query - regardless of the interval requested at creation.
+ * If this value is larger than the interval specified at creation of the search object, more search results are available.
+ * To fetch these, create a new search object with a new interval.
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The total number of albums matching the original query
+ */
+SP_LIBEXPORT(int) sp_search_total_albums(sp_search *search);
+
+/**
+ * Return the total number of artists for the search query - regardless of the interval requested at creation.
+ * If this value is larger than the interval specified at creation of the search object, more search results are available.
+ * To fetch these, create a new search object with a new interval.
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The total number of artists matching the original query
+ */
+SP_LIBEXPORT(int) sp_search_total_artists(sp_search *search);
+
+/**
+ * Increase the reference count of a search result
+ *
+ * @param[in]   search    The search result object
+ */
+SP_LIBEXPORT(void) sp_search_add_ref(sp_search *search);
+
+/**
+ * Decrease the reference count of a search result
+ *
+ * @param[in]   search    The search result object
+ */
+SP_LIBEXPORT(void) sp_search_release(sp_search *search);
+
+/** @} */
+
+
+
+/**
+ * @defgroup playlist Playlist subsystem
+ *
+ * The playlist subsystem handles playlists and playlist containers (list of playlists).
+ *
+ * The playlist container functions are always valid, but your playlists are not
+ * guaranteed to be loaded until the sp_session_callbacks#logged_in callback has
+ * been issued.
+ *
+ * @{
+ */
+
+/**
+ * Playlist callbacks
+ *
+ * Used to get notifications when playlists are updated.
+ * If some callbacks should not be of interest, set them to NULL.
+ */
+typedef struct sp_playlist_callbacks {
+
+	/**
+	 * Called when one or more tracks have been added to a playlist
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  tracks     Array of pointers to track objects
+	 * @param[in]  num_tracks Number of entries in \p tracks
+	 * @param[in]  position   Position in the playlist for the first track.
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *tracks_added)(sp_playlist *pl, sp_track * const *tracks, int num_tracks, int position, void *userdata);
+
+	/**
+	 * Called when one or more tracks have been removed from a playlist
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  tracks     Array of positions representing the tracks that were removed
+	 * @param[in]  num_tracks Number of entries in \p tracks
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *tracks_removed)(sp_playlist *pl, const int *tracks, int num_tracks, void *userdata);
+
+	/**
+	 * Called when one or more tracks have been moved within a playlist
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  tracks     Array of positions representing the tracks that were moved
+	 * @param[in]  num_tracks Number of entries in \p tracks
+	 * @param[in]  position   New position in the playlist for the first track.
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *tracks_moved)(sp_playlist *pl, const int *tracks, int num_tracks, int new_position, void *userdata);
+
+	/**
+	 * Called when a playlist has been renamed. sp_playlist_name() can be used to find out the new name
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_renamed)(sp_playlist *pl, void *userdata);
+
+	/**
+	 * Called when state changed for a playlist.
+	 *
+	 * There are three states that trigger this callback:
+	 * - Collaboration for this playlist has been turned on or off
+	 * - The playlist started having pending changes, or all pending changes have now been committed
+	 * - The playlist started loading, or finished loading
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 * @sa sp_playlist_is_collaborative
+	 * @sa sp_playlist_has_pending_changes
+	 * @sa sp_playlist_is_loaded
+	 */
+	void (SP_CALLCONV *playlist_state_changed)(sp_playlist *pl, void *userdata);
+
+	/**
+	 * Called when a playlist is updating or is done updating
+	 *
+	 * This is called before and after a series of changes are applied to the
+	 * playlist. It allows e.g. the user interface to defer updating until the
+	 * entire operation is complete.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  done       True iff the update is completed
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_update_in_progress)(sp_playlist *pl, bool done, void *userdata);
+
+	/**
+	 * Called when metadata for one or more tracks in a playlist has been updated.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_metadata_updated)(sp_playlist *pl, void *userdata);
+
+	/**
+	 * Called when create time and/or creator for a playlist entry changes
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  position   Position in playlist
+	 * @param[in]  user       User object
+	 * @param[in]  time       When entry was created, seconds since the unix epoch.
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *track_created_changed)(sp_playlist *pl, int position, sp_user *user, int when, void *userdata);
+
+	/**
+	 * Called when seen attribute for a playlist entry changes.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  position   Position in playlist
+	 * @param[in]  seen       Set if entry it marked as seen
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *track_seen_changed)(sp_playlist *pl, int position, bool seen, void *userdata);
+
+	/**
+	 * Called when playlist description has changed
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  desc       New description
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *description_changed)(sp_playlist *pl, const char *desc, void *userdata);
+
+
+	/**
+	 * Called when playlist image has changed
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  image      New image
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *image_changed)(sp_playlist *pl, const s_byte *image, void *userdata);
+
+
+	/**
+	 * Called when message attribute for a playlist entry changes.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  position   Position in playlist
+	 * @param[in]  message    UTF-8 encoded message
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *track_message_changed)(sp_playlist *pl, int position, const char *message, void *userdata);
+
+
+	/**
+	 * Called when playlist subscribers changes (count or list of names)
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *subscribers_changed)(sp_playlist *pl, void *userdata);
+
+} sp_playlist_callbacks;
+
+
+/**
+ * Get load status for the specified playlist. If it's false, you have to wait until
+ * playlist_state_changed happens, and check again if is_loaded has changed
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                True if playlist is loaded, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_playlist_is_loaded(sp_playlist *playlist);
+
+/**
+ * Register interest in the given playlist
+ *
+ * Here is a snippet from \c jukebox.c:
+ * @dontinclude jukebox.c
+ * @skipline sp_playlist_add_callbacks
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  callbacks  Callbacks, see #sp_playlist_callbacks
+ * @param[in]  userdata   Userdata to be passed to callbacks
+ * @sa sp_playlist_remove_callbacks
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_add_callbacks(sp_playlist *playlist, sp_playlist_callbacks *callbacks, void *userdata);
+
+/**
+ * Unregister interest in the given playlist
+ *
+ * The combination of (\p callbacks, \p userdata) is used to find the entry to be removed
+ *
+ * Here is a snippet from \c jukebox.c:
+ * @dontinclude jukebox.c
+ * @skipline sp_playlist_remove_callbacks
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  callbacks  Callbacks, see #sp_playlist_callbacks
+ * @param[in]  userdata   Userdata to be passed to callbacks
+ * @sa sp_playlist_add_callbacks
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_remove_callbacks(sp_playlist *playlist, sp_playlist_callbacks *callbacks, void *userdata);
+
+/**
+ * Return number of tracks in the given playlist
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                The number of tracks in the playlist
+ */
+SP_LIBEXPORT(int) sp_playlist_num_tracks(sp_playlist *playlist);
+
+/**
+ * Return the track at the given index in a playlist
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                The track at the given index
+ */
+SP_LIBEXPORT(sp_track *) sp_playlist_track(sp_playlist *playlist, int index);
+
+/**
+ * Return when the given index was added to the playlist
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                Time, Seconds since unix epoch.
+ */
+SP_LIBEXPORT(int) sp_playlist_track_create_time(sp_playlist *playlist, int index);
+
+/**
+ * Return user that added the given index in the playlist
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                User object
+ */
+SP_LIBEXPORT(sp_user *) sp_playlist_track_creator(sp_playlist *playlist, int index);
+
+/**
+ * Return if a playlist entry is marked as seen or not
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                Seen state
+ */
+SP_LIBEXPORT(bool) sp_playlist_track_seen(sp_playlist *playlist, int index);
+
+/**
+ * Set seen status of a playlist entry
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ * @param[in]  seen       Seen status to be set
+ *
+ * @return     error     One of the following errors, from ::sp_error
+ *                       SP_ERROR_OK
+ *                       SP_ERROR_INDEX_OUT_OF_RANGE
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_track_set_seen(sp_playlist *playlist, int index, bool seen);
+
+/**
+ * Return a message attached to a playlist item. Typically used on inbox.
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                UTF-8 encoded message, or NULL if no message is present
+ */
+SP_LIBEXPORT(const char *) sp_playlist_track_message(sp_playlist *playlist, int index);
+
+/**
+ * Return name of given playlist
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                The name of the given playlist
+ */
+SP_LIBEXPORT(const char *) sp_playlist_name(sp_playlist *playlist);
+
+/**
+ * Rename the given playlist
+ * The name must not consist of only spaces and it must be shorter than 256 characters.
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  new_name   New name for playlist
+ *
+ * @return                One of the following errors, from ::sp_error
+ *                        SP_ERROR_OK
+ *                        SP_ERROR_INVALID_INDATA
+ *                        SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_rename(sp_playlist *playlist, const char *new_name);
+
+/**
+ * Return a pointer to the user for the given playlist
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                User object
+ */
+SP_LIBEXPORT(sp_user *) sp_playlist_owner(sp_playlist *playlist);
+
+/**
+ * Return collaborative status for a playlist.
+ *
+ * A playlist in collaborative state can be modifed by all users, not only the user owning the list
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                true if playlist is collaborative, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_playlist_is_collaborative(sp_playlist *playlist);
+
+/**
+ * Set collaborative status for a playlist.
+ *
+ * A playlist in collaborative state can be modified by all users, not only the user owning the list
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  collaborative  True or false
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_set_collaborative(sp_playlist *playlist, bool collaborative);
+
+/**
+ * Set autolinking state for a playlist.
+ *
+ * If a playlist is autolinked, unplayable tracks will be made playable
+ * by linking them to other Spotify tracks, where possible.
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  link           True or false
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_set_autolink_tracks(sp_playlist *playlist, bool link);
+
+
+/**
+ * Get description for a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return                    Playlist description or NULL if unset
+ *
+ */
+SP_LIBEXPORT(const char *) sp_playlist_get_description(sp_playlist *playlist);
+
+
+/**
+ * Get description for a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[out] image          20 byte image id
+
+ * @return                    TRUE if playlist has an image, FALSE if not
+ *
+ */
+SP_LIBEXPORT(bool) sp_playlist_get_image(sp_playlist *playlist, s_byte image[20]);
+
+
+/**
+ * Check if a playlist has pending changes
+ *
+ * Pending changes are local changes that have not yet been acknowledged by the server.
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return                    A flag representing if there are pending changes or not
+ */
+SP_LIBEXPORT(bool) sp_playlist_has_pending_changes(sp_playlist *playlist);
+
+/**
+ * Add tracks to a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  tracks         Array of pointer to tracks.
+ * @param[in]  num_tracks     Length of \p tracks array
+ * @param[in]  position       Start position in playlist where to insert the tracks
+ * @param[in]  session        Your session object
+ *
+ * @return                One of the following errors, from ::sp_error
+ *                        SP_ERROR_OK
+ *                        SP_ERROR_INVALID_INDATA - position is > current playlist length
+ *                        SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_add_tracks(sp_playlist *playlist, sp_track *const*tracks, int num_tracks, int position, sp_session *session);
+
+/**
+ * Remove tracks from a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  tracks         Array of pointer to track indices.
+ *                            A certain track index should be present at most once, e.g. [0, 1, 2] is valid indata,
+ *                            whereas [0, 1, 1] is invalid.
+ * @param[in]  num_tracks     Length of \p tracks array
+ *
+ * @return                    One of the following errors, from ::sp_error
+ *                            SP_ERROR_OK
+ *                            SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_remove_tracks(sp_playlist *playlist, const int *tracks, int num_tracks);
+
+/**
+ * Move tracks in playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  tracks         Array of pointer to track indices to be moved.
+ *                            A certain track index should be present at most once, e.g. [0, 1, 2] is valid indata,
+ *                            whereas [0, 1, 1] is invalid.
+ * @param[in]  num_tracks     Length of \p tracks array
+ * @param[in]  new_position   New position for tracks
+ *
+ * @return                    One of the following errors, from ::sp_error
+ *                            SP_ERROR_OK
+ *                            SP_ERROR_INVALID_INDATA - position is > current playlist length
+ *                            SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_reorder_tracks(sp_playlist *playlist, const int *tracks, int num_tracks, int new_position);
+
+
+/**
+ * Return number of subscribers for a given playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return     Number of subscribers
+ *
+ */
+SP_LIBEXPORT(unsigned int) sp_playlist_num_subscribers(sp_playlist *playlist);
+
+/**
+ * Return subscribers for a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return     sp_subscribers struct with array of canonical usernames.
+ *             This object should be free'd using sp_playlist_subscribers_free()
+ *
+ * @note       The count returned for this function may be less than those
+ *             returned by sp_playlist_num_subscribers(). Spotify does not
+ *             track each user subscribed to a playlist for playlist with
+ *             many (>500) subscribers.
+ */
+SP_LIBEXPORT(sp_subscribers *) sp_playlist_subscribers(sp_playlist *playlist);
+
+/**
+ * Free object returned from sp_playlist_subscribers()
+ *
+ * @param[in] subscribers   Subscribers object
+ */
+SP_LIBEXPORT(void) sp_playlist_subscribers_free(sp_subscribers *subscribers);
+
+/**
+ * Ask library to update the subscription count for a playlist
+ *
+ * When the subscription info has been fetched from the Spotify backend
+ * the playlist subscribers_changed() callback will be invoked.
+ * In that callback use sp_playlist_num_subscribers() and/or
+ * sp_playlist_subscribers() to get information about the subscribers.
+ * You can call those two functions anytime you want but the information
+ * might not be up to date in such cases
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ */
+SP_LIBEXPORT(void) sp_playlist_update_subscribers(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Return whether a playlist is loaded in RAM (as opposed to only
+ * stored on disk)
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ *
+ * @return True iff playlist is in RAM, False otherwise
+ *
+ * @note       When a playlist is no longer in RAM it will appear empty.
+ *             However, libspotify will retain information about the
+ *             list metadata  (owner, title, picture, etc) in RAM.
+ *             There is one caveat tough: If libspotify has never seen the
+ *             playlist before this metadata will also be unset.
+ *             In order for libspotify to get the metadata the playlist
+ *             needs to be loaded at least once.
+ *             In order words, if libspotify starts with an empty playlist
+ *             cache and the application has set 'initially_unload_playlists'
+ *             config parameter to True all playlists will be empty.
+ *             It will not be possible to generate URI's to the playlists
+ *             nor extract playlist title until the application calls
+ *             sp_playlist_set_in_ram(..., true). So an application
+ *             that needs to stay within a low memory profile would need to
+ *             cycle thru all new playlists in order to extract metadata.
+ *
+ *             The easiest way to detect this case is when
+ *             sp_playlist_is_in_ram() returns false and
+ *             sp_link_create_from_playlist() returns NULL
+ */
+SP_LIBEXPORT(bool) sp_playlist_is_in_ram(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Return whether a playlist is loaded in RAM (as opposed to only
+ * stored on disk)
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ * @param[in]  in_ram         Controls whether or not to keep the list in RAM
+ */
+SP_LIBEXPORT(void) sp_playlist_set_in_ram(sp_session *session, sp_playlist *playlist, bool in_ram);
+
+/**
+ * Load an already existing playlist without adding it to a playlistcontainer.
+ *
+ * @param[in]  session        Session object
+ * @param[in]  link           Link object referring to a playlist
+ *
+ * @return     A playlist. The reference is owned by the caller and should be released with sp_playlist_release()
+ *
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlist_create(sp_session *session, sp_link *link);
+
+/**
+ * Mark a playlist to be synchronized for offline playback.
+ * The playlist must be in the users playlistcontainer
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ * @param[in]  offline        True iff playlist should be offline, false otherwise
+ */
+SP_LIBEXPORT(void) sp_playlist_set_offline_mode(sp_session *session, sp_playlist *playlist, bool offline);
+
+/**
+ * Get offline status for a playlist
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ *
+ * @return sp_playlist_offline_status
+ *
+ * @see When in SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING mode the
+ *      sp_playlist_get_offline_download_completed() method can be used to query
+ *      progress of the download
+ */
+SP_LIBEXPORT(sp_playlist_offline_status) sp_playlist_get_offline_status(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Get download progress for an offline playlist
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ *
+ * @return Value from 0 - 100 that indicates amount of playlist that is downloaded
+ * or 0 if the playlist is not in the SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING mode.
+ *
+ * @see sp_playlist_offline_status()
+ */
+SP_LIBEXPORT(int) sp_playlist_get_offline_download_completed(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Increase the reference count of a playlist
+ *
+ * @param[in]   playlist       The playlist object
+ */
+SP_LIBEXPORT(void) sp_playlist_add_ref(sp_playlist *playlist);
+
+/**
+ * Decrease the reference count of a playlist
+ *
+ * @param[in]   playlist       The playlist object
+ */
+SP_LIBEXPORT(void) sp_playlist_release(sp_playlist *playlist);
+
+
+/**
+ * Playlist container callbacks.
+ * If some callbacks should not be of interest, set them to NULL.
+ *
+ * @see sp_playlistcontainer_add_callbacks
+ * @see sp_playlistcontainer_remove_callbacks
+ */
+typedef struct sp_playlistcontainer_callbacks {
+	/**
+	 * Called when a new playlist has been added to the playlist container.
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  playlist   Playlist object.
+	 * @param[in]  position   Position in list
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_added)(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata);
+
+
+	/**
+	 * Called when a new playlist has been removed from playlist container
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  playlist   Playlist object.
+	 * @param[in]  position   Position in list
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_removed)(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata);
+
+
+	/**
+	 * Called when a playlist has been moved in the playlist container
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  playlist   Playlist object.
+	 * @param[in]  position   Previous position in playlist container list
+	 * @param[in]  new_position   New position in playlist container list
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_moved)(sp_playlistcontainer *pc, sp_playlist *playlist, int position, int new_position, void *userdata);
+
+	/**
+	 * Called when the playlist container is loaded
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *container_loaded)(sp_playlistcontainer *pc, void *userdata);
+} sp_playlistcontainer_callbacks;
+
+
+/**
+ * Register interest in changes to a playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  callbacks Callbacks, see sp_playlistcontainer_callbacks
+ * @param[in]  userdata  Opaque value passed to callbacks.
+ *
+ * @note Every sp_playlistcontainer_add_callbacks() needs to be paired with a corresponding
+ *       sp_playlistcontainer_remove_callbacks() that is invoked before releasing the
+ *       last reference you own for the container. In other words, you must make sure
+ *       to have removed all the callbacks before the container gets destroyed.
+ *
+ * @sa sp_session_playlistcontainer()
+ * @sa sp_playlistcontainer_remove_callbacks
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_add_callbacks(sp_playlistcontainer *pc, sp_playlistcontainer_callbacks *callbacks, void *userdata);
+
+
+/**
+ * Unregister interest in changes to a playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  callbacks Callbacks, see sp_playlistcontainer_callbacks
+ * @param[in]  userdata  Opaque value passed to callbacks.
+ *
+ * @sa sp_session_playlistcontainer()
+ * @sa sp_playlistcontainer_add_callbacks
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_remove_callbacks(sp_playlistcontainer *pc, sp_playlistcontainer_callbacks *callbacks, void *userdata);
+
+/**
+ * Return the number of playlists in the given playlist container
+ *
+ * @param[in]  pc        Playlist container
+ *
+ * @return               Number of playlists, -1 if undefined
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(int) sp_playlistcontainer_num_playlists(sp_playlistcontainer *pc);
+
+/**
+ * Return true if the playlistcontainer is fully loaded
+ *
+ * @param[in]  pc        Playlist container
+ *
+ * @return               True if container is loaded
+ *
+ * @note The container_loaded callback will be invoked when this flips to true
+ */
+SP_LIBEXPORT(bool) sp_playlistcontainer_is_loaded(sp_playlistcontainer *pc);
+
+/**
+ * Return a pointer to the playlist at a specific index
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]
+ *
+ * @return               The playlist object
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlistcontainer_playlist(sp_playlistcontainer *pc, int index);
+
+/**
+ * Return the type of the playlist at a @a index
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]
+ *
+ * @return               Type of the playlist, @see sp_playlist_type
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_playlist_type) sp_playlistcontainer_playlist_type(sp_playlistcontainer *pc, int index);
+
+/**
+ * Return the folder name at @a index
+ *
+ * @param[in]  pc           Playlist container
+ * @param[in]  index        Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1].
+ *                          Index should point at a start-folder entry, otherwise the empty string is written to buffer.
+ * @param[in]  buffer       Pointer to char[] where to store folder name
+ * @param[in]  buffer_size  Size of array
+ *
+ * @return                  One of the following errors, from ::sp_error
+ *                          SP_ERROR_OK
+ *                          SP_ERROR_INDEX_OUT_OF_RANGE
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_playlist_folder_name(sp_playlistcontainer *pc, int index, char *buffer, int buffer_size);
+
+/**
+ * Return the folder id at @a index
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]
+ *
+ * @return               The group ID of the folder. Returns 0 on index out of range, pc being NULL or indexed item not being a folder
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_uint64) sp_playlistcontainer_playlist_folder_id(sp_playlistcontainer *pc, int index);
+
+/**
+ * Add an empty playlist at the end of the playlist container.
+ * The name must not consist of only spaces and it must be shorter than 256 characters.
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  name      Name of new playlist
+ *
+ * @return               Pointer to the new playlist. Can be NULL if the operation fails.
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlistcontainer_add_new_playlist(sp_playlistcontainer *pc, const char *name);
+
+/**
+ * Add an existing playlist at the end of the given playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  link      Link object pointing to a playlist
+ *
+ * @return               Pointer to the new playlist. Will be NULL if the playlist already exists.
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlistcontainer_add_playlist(sp_playlistcontainer *pc, sp_link *link);
+
+/**
+ * Remove playlist at index from the given playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index of playlist to be removed
+ *
+ * @return     error     One of the following errors, from ::sp_error
+ *                       SP_ERROR_OK
+ *                       SP_ERROR_INDEX_OUT_OF_RANGE
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_remove_playlist(sp_playlistcontainer *pc, int index);
+
+/**
+ * Move a playlist in the playlist container
+ *
+ * @param[in]  pc           Playlist container
+ * @param[in]  index        Index of playlist to be moved
+ * @param[in]  new_position New position for the playlist
+ * @param[in]  dry_run      Do not execute the move, only check if it possible
+
+ * @return     error        One of the following errors, from ::sp_error
+ *                          SP_ERROR_OK
+ *                          SP_ERROR_INDEX_OUT_OF_RANGE
+ *                          SP_ERROR_INVALID_INDATA - If trying to move a folder into itself
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_move_playlist(sp_playlistcontainer *pc, int index, int new_position, bool dry_run);
+
+
+/**
+ * Add a playlist folder
+ *
+ * @param[in]  pc           Playlist container
+ * @param[in]  index        Position of SP_PLAYLIST_TYPE_START_FOLDER entry
+ * @param[in]  name         Name of group
+
+ * @return     error        One of the following errors, from ::sp_error
+ *                          SP_ERROR_OK
+ *                          SP_ERROR_INDEX_OUT_OF_RANGE
+ *
+ * @note This operation will actually create two playlists. One of
+ * type SP_PLAYLIST_TYPE_START_FOLDER and immediately following a
+ * SP_PLAYLIST_TYPE_END_FOLDER one.
+ *
+ * To remove a playlist folder both of these must be deleted or the list
+ * will be left in an inconsistant state.
+ *
+ * There is no way to rename a playlist folder. Instead you need to remove
+ * the folder and recreate it again.
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_add_folder(sp_playlistcontainer *pc, int index, const char *name);
+
+
+/**
+ * Return a pointer to the user object of the owner.
+ *
+ * @param[in]  pc   Playlist container.
+ * @return          The user object or NULL if unknown or none.
+ */
+SP_LIBEXPORT(sp_user *) sp_playlistcontainer_owner(sp_playlistcontainer *pc);
+
+
+/**
+ * Increase reference count on playlistconatiner object
+ *
+ * @param[in]  pc   Playlist container.
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_add_ref(sp_playlistcontainer *pc);
+
+/**
+ * Release reference count on playlistconatiner object
+ *
+ * @param[in]  pc   Playlist container.
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_release(sp_playlistcontainer *pc);
+
+/** @} */
+
+
+/**
+ * @defgroup user User handling
+ * @{
+ */
+
+
+/**
+ * User relation type
+ */
+typedef enum sp_relation_type {
+  SP_RELATION_TYPE_UNKNOWN = 0,          ///< Not yet known
+  SP_RELATION_TYPE_NONE = 1,             ///< No relation
+  SP_RELATION_TYPE_UNIDIRECTIONAL = 2,   ///< The currently logged in user is following this uer
+  SP_RELATION_TYPE_BIDIRECTIONAL = 3,    ///< Bidirectional friendship established
+} sp_relation_type;
+
+
+
+/**
+ * Get a pointer to a string representing the user's canonical username.
+ *
+ * @param[in]   user         The Spotify user whose canonical username you would like a string representation of
+ *
+ * @return                   A string representing the canonical username.
+ */
+SP_LIBEXPORT(const char *) sp_user_canonical_name(sp_user *user);
+
+/**
+ * Get a pointer to a string representing the user's displayable username.
+ * If there is no difference between the canonical username and the display name,
+ * or if the library does not know about the display name yet, the canonical username will
+ * be returned.
+ *
+ * @param[in]   user         The Spotify user whose displayable username you would like a string representation of
+ *
+ * @return                   A string
+ */
+SP_LIBEXPORT(const char *) sp_user_display_name(sp_user *user);
+
+/**
+ * Get load status for a user object. Before it is loaded, only the user's canonical username
+ * is known.
+ *
+ * @param[in]   user         Spotify user object
+ *
+ * @return                   True if user object is loaded, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_user_is_loaded(sp_user *user);
+
+
+
+/**
+ * Increase the reference count of an user
+ *
+ * @param[in]   user       The user object
+ */
+SP_LIBEXPORT(void) sp_user_add_ref(sp_user *user);
+
+/**
+ * Decrease the reference count of an user
+ *
+ * @param[in]   user       The user object
+ */
+SP_LIBEXPORT(void) sp_user_release(sp_user *user);
+
+/** @} */
+
+
+/**
+ * @defgroup toplist Toplist handling
+ * @{
+ */
+
+/**
+ * Toplist types
+ */
+typedef enum {
+	SP_TOPLIST_TYPE_ARTISTS = 0, ///< Top artists
+	SP_TOPLIST_TYPE_ALBUMS  = 1, ///< Top albums
+	SP_TOPLIST_TYPE_TRACKS  = 2, ///< Top tracks
+} sp_toplisttype;
+
+
+/**
+ * Convenience macro to create a toplist region. Toplist regions are ISO 3166-1
+ * country codes (in uppercase) encoded in an integer. There are also some reserved
+ * codes used to denote non-country regions. See sp_toplistregion
+ *
+ * Example: SP_TOPLIST_REGION('S', 'E') for Sweden
+ */
+#define SP_TOPLIST_REGION(a, b) ((a) << 8 | (b))
+
+/**
+ * Special toplist regions
+ */
+typedef enum {
+	SP_TOPLIST_REGION_EVERYWHERE = 0, ///< Global toplist
+	SP_TOPLIST_REGION_USER = 1,       ///< Toplist for a given user
+} sp_toplistregion;
+
+
+/**
+ * The type of a callback used in sp_toplistbrowse_create()
+ *
+ * When the callback is called, the metadata of all tracks belonging to it will have
+ * been loaded, so sp_track_is_loaded() will return non-zero. The same goes for the
+ * similar toplist data.
+ *
+ * @param[in]   result          The same pointer returned by sp_toplistbrowse_create()
+ * @param[in]   userdata        The opaque pointer given to sp_toplistbrowse_create()
+ */
+typedef void SP_CALLCONV toplistbrowse_complete_cb(sp_toplistbrowse *result, void *userdata);
+
+/**
+ * Initiate a request for browsing an toplist
+ *
+ * The user is responsible for freeing the returned toplist browse using sp_toplistbrowse_release(). This can be done in the callback.
+ *
+ * @param[in]   session         Session object
+ * @param[in]   type            Type of toplist to be browsed. see the sp_toplisttype enum for possible values
+ * @param[in]   region          Region. see sp_toplistregion enum. Country specific regions are coded as two chars in an integer.
+ *                              Sweden would correspond to 'S' << 8 | 'E'
+ * @param[in]   username        If region is SP_TOPLIST_REGION_USER this specifies which user to get toplists for. NULL means the logged in user.
+ * @param[in]   callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.
+ * @param[in]   userdata        Userdata passed to callback.
+ *
+ * @return                      Toplist browse object
+ *
+ * @see ::toplistbrowse_complete_cb
+ */
+SP_LIBEXPORT(sp_toplistbrowse *) sp_toplistbrowse_create(sp_session *session, sp_toplisttype type, sp_toplistregion region, const char *username, toplistbrowse_complete_cb *callback, void *userdata);
+
+
+/**
+ * Check if an toplist browse request is completed
+ *
+ * @param[in]   tlb        Toplist browse object
+ *
+ * @return                 True if browsing is completed, false if not
+ */
+SP_LIBEXPORT(bool) sp_toplistbrowse_is_loaded(sp_toplistbrowse *tlb);
+
+/**
+* Check if browsing returned an error code.
+*
+* @param[in]   tlb        Toplist browse object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_toplistbrowse_error(sp_toplistbrowse *tlb);
+
+
+
+/**
+ * Increase the reference count of an toplist browse result
+ *
+ * @param[in]   tlb       The toplist browse result object
+ */
+SP_LIBEXPORT(void) sp_toplistbrowse_add_ref(sp_toplistbrowse *tlb);
+
+/**
+ * Decrease the reference count of an toplist browse result
+ *
+ * @param[in]   tlb       The toplist browse result object
+ */
+SP_LIBEXPORT(void) sp_toplistbrowse_release(sp_toplistbrowse *tlb);
+
+/**
+ * Given an toplist browse object, return number of artists
+ *
+ * @param[in]   tlb         Toplist browse object
+ *
+ * @return                  Number of artists on toplist
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_num_artists(sp_toplistbrowse *tlb);
+
+/**
+ * Return the artist at the given index in the given toplist browse object
+ *
+ * @param[in]  tlb        Toplist object
+ * @param[in]  index      Index of the wanted artist. Should be in the interval [0, sp_toplistbrowse_num_artists() - 1]
+ *
+ * @return                The artist at the given index in the given toplist browse object
+ */
+SP_LIBEXPORT(sp_artist *) sp_toplistbrowse_artist(sp_toplistbrowse *tlb, int index);
+
+
+/**
+ * Given an toplist browse object, return number of albums
+ *
+ * @param[in]   tlb         Toplist browse object
+ *
+ * @return                  Number of albums on toplist
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_num_albums(sp_toplistbrowse *tlb);
+
+
+/**
+ * Return the album at the given index in the given toplist browse object
+ *
+ * @param[in]  tlb        Toplist object
+ * @param[in]  index      Index of the wanted album. Should be in the interval [0, sp_toplistbrowse_num_albums() - 1]
+ *
+ * @return                The album at the given index in the given toplist browse object
+ */
+SP_LIBEXPORT(sp_album *) sp_toplistbrowse_album(sp_toplistbrowse *tlb, int index);
+
+
+/**
+ * Given an toplist browse object, return number of tracks
+ *
+ * @param[in]   tlb         Toplist browse object
+ *
+ * @return                  Number of tracks on toplist
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_num_tracks(sp_toplistbrowse *tlb);
+
+
+/**
+ * Return the track at the given index in the given toplist browse object
+ *
+ * @param[in]  tlb        Toplist object
+ * @param[in]  index      Index of the wanted track. Should be in the interval [0, sp_toplistbrowse_num_tracks() - 1]
+ *
+ * @return                The track at the given index in the given toplist browse object
+ */
+SP_LIBEXPORT(sp_track *) sp_toplistbrowse_track(sp_toplistbrowse *tlb, int index);
+
+/**
+ * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request
+ *
+ * @param[in]  tlb        Toplist object
+ *
+ * @return                -1 if the request was served from the local cache
+ *                        If the result is not yet loaded the return value is undefined
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_backend_request_duration(sp_toplistbrowse *tlb);
+
+
+/** @} */
+
+/**
+ * @defgroup inbox Inbox subsystem
+ * @{
+ */
+
+/**
+ * The type of a callback used in sp_inbox_post()
+ *
+ * When this callback is called, the sp_track_is_loaded(), sp_album_is_loaded(),
+ * and sp_artist_is_loaded() functions will return non-zero for the objects
+ * contained in the search result.
+ *
+ * @param[in]   result          The same pointer returned by sp_search_create()
+ * @param[in]   userdata        The opaque pointer given to sp_search_create()
+ */
+typedef void SP_CALLCONV inboxpost_complete_cb(sp_inbox *result, void *userdata);
+
+/**
+ * Add to inbox
+ *
+ * @param[in]  session    Session object
+ * @param[in]  user       Canonical username of recipient
+ * @param[in]  tracks     Array of tracks to post
+ * @param[in]  num_tracks Number of tracks in \p tracks
+ * @param[in]  message    Message to attach to tracks. UTF-8
+ * @param[in]  callback   Callback to be invoked when the request has completed
+ * @param[in]  userdata   Userdata passed to callback
+ *
+ * @return                sp_inbox object if the request has been sent, NULL if request failed to initialize
+ */
+SP_LIBEXPORT(sp_inbox *) sp_inbox_post_tracks(sp_session *session, const char *user, sp_track * const *tracks, int num_tracks, const char *message, inboxpost_complete_cb *callback, void *userdata);
+
+
+/**
+* Check if inbox operation returned an error code.
+*
+* @param[in]   inbox      Inbox object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_OTHER_TRANSIENT
+*                         SP_ERROR_PERMISSION_DENIED
+*                         SP_ERROR_INVALID_INDATA
+*                         SP_ERROR_INBOX_IS_FULL
+*                         SP_ERROR_NO_SUCH_USER
+*                         SP_ERROR_OTHER_PERMANENT
+*/
+SP_LIBEXPORT(sp_error) sp_inbox_error(sp_inbox *inbox);
+
+/**
+ * Increase the reference count of a inbox result
+ *
+ * @param[in]   inbox    The inbox result object
+ */
+SP_LIBEXPORT(void) sp_inbox_add_ref(sp_inbox *inbox);
+
+/**
+ * Decrease the reference count of a inbox result
+ *
+ * @param[in]   inbox    The inbox result object
+ */
+SP_LIBEXPORT(void) sp_inbox_release(sp_inbox *inbox);
+
+/** @} */
+
+/**
+ * Return the libspotify build ID
+ *
+ * This might be useful to have available for display somewhere in your
+ * user interface.
+ */
+SP_LIBEXPORT(const char *) sp_build_id(void);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PUBLIC_API_H */
+/**
+ * @example browse.c
+ *
+ * The browse.c example shows how you can use the album, artist, and browse functions.
+ * The example also include some rudimentary playlist browsing.
+ * It is part of the spshell program
+ */
+/**
+ * @example search.c
+ *
+ * The search.c example shows how you can use search functions.
+ * It is part of the spshell program
+ */
+/**
+ * @example toplist.c
+ *
+ * The toplist.c example shows how you can use toplist functions.
+ * It is part of the spshell program
+ */
+/**
+ * @example jukebox.c
+ *
+ * The jukebox.c example shows how you can use playback and playlist functions.
+ */
diff --git a/lib/libspotify/include/libspotify/api.h b/lib/libspotify/include/libspotify/api.h
new file mode 100644
index 0000000..052fc62
--- /dev/null
+++ b/lib/libspotify/include/libspotify/api.h
@@ -0,0 +1,3577 @@
+/*
+ * Copyright (c) 2006-2010 Spotify Ltd
+ *
+ * The terms of use for this and related files can be read in
+ * the associated LICENSE file, usually stored in share/doc/libspotify/LICENSE.
+ */
+
+/**
+ * @file   api.h    Public API for libspotify
+ *
+ * @note   All input strings are expected to be in UTF-8
+ * @note   All output strings are in UTF-8.
+ *
+ * @note   All usernames are valid XMPP nodeprep identifiers:
+ *         http://tools.ietf.org/html/rfc3920#appendix-A
+ *         If you need to store user data, we strongly advise you
+ *         to use the canonical form of the username.
+ */
+
+#ifndef PUBLIC_API_H
+#define PUBLIC_API_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef SP_CALLCONV
+#ifdef _WIN32
+#define SP_CALLCONV __stdcall
+#else
+#define SP_CALLCONV
+#endif
+#endif
+
+#ifndef SP_LIBEXPORT
+#ifdef _WIN32
+#define SP_LIBEXPORT(x) x __stdcall
+#else
+#define SP_LIBEXPORT(x) x
+#endif
+#endif
+
+/* Includes */
+#include <stddef.h>
+
+
+
+#ifdef _WIN32
+typedef unsigned __int64 sp_uint64;
+#else
+#include <stdint.h>
+typedef uint64_t sp_uint64;
+#endif
+
+/* General types */
+
+#if !defined(__cplusplus) && !defined(__bool_true_false_are_defined)
+typedef unsigned char bool;
+#endif
+
+typedef unsigned char s_byte;
+
+/**
+ * @defgroup types Spotify types & structs
+ *
+ * @{
+ */
+
+typedef struct sp_session sp_session; ///< Representation of a session
+typedef struct sp_track sp_track; ///< A track handle
+typedef struct sp_album sp_album; ///< An album handle
+typedef struct sp_artist sp_artist; ///< An artist handle
+typedef struct sp_artistbrowse sp_artistbrowse; ///< A handle to an artist browse result
+typedef struct sp_albumbrowse sp_albumbrowse; ///< A handle to an album browse result
+typedef struct sp_toplistbrowse sp_toplistbrowse; ///< A handle to a toplist browse result
+typedef struct sp_search sp_search; ///< A handle to a search result
+typedef struct sp_link sp_link; ///< A handle to the libspotify internal representation of a URI
+typedef struct sp_image sp_image; ///< A handle to an image
+typedef struct sp_user sp_user; ///< A handle to a user
+typedef struct sp_playlist sp_playlist; ///< A playlist handle
+typedef struct sp_playlistcontainer sp_playlistcontainer; ///< A playlist container (playlist containing other playlists) handle
+typedef struct sp_inbox sp_inbox; ///< Add to inbox request handle
+/** @} */
+
+/**
+ * @defgroup error Error Handling
+ *
+ * All functions in libspotify use the same set of error codes. Most of them return
+ * an error code, and let the result of the operation be stored in an out-parameter.
+ *
+ * @{
+ */
+
+/**
+ * Error codes returned by various functions
+ */
+typedef enum sp_error {
+	SP_ERROR_OK                        = 0,  ///< No errors encountered
+	SP_ERROR_BAD_API_VERSION           = 1,  ///< The library version targeted does not match the one you claim you support
+	SP_ERROR_API_INITIALIZATION_FAILED = 2,  ///< Initialization of library failed - are cache locations etc. valid?
+	SP_ERROR_TRACK_NOT_PLAYABLE        = 3,  ///< The track specified for playing cannot be played
+	SP_ERROR_BAD_APPLICATION_KEY       = 5,  ///< The application key is invalid
+	SP_ERROR_BAD_USERNAME_OR_PASSWORD  = 6,  ///< Login failed because of bad username and/or password
+	SP_ERROR_USER_BANNED               = 7,  ///< The specified username is banned
+	SP_ERROR_UNABLE_TO_CONTACT_SERVER  = 8,  ///< Cannot connect to the Spotify backend system
+	SP_ERROR_CLIENT_TOO_OLD            = 9,  ///< Client is too old, library will need to be updated
+	SP_ERROR_OTHER_PERMANENT           = 10, ///< Some other error occurred, and it is permanent (e.g. trying to relogin will not help)
+	SP_ERROR_BAD_USER_AGENT            = 11, ///< The user agent string is invalid or too long
+	SP_ERROR_MISSING_CALLBACK          = 12, ///< No valid callback registered to handle events
+	SP_ERROR_INVALID_INDATA            = 13, ///< Input data was either missing or invalid
+	SP_ERROR_INDEX_OUT_OF_RANGE        = 14, ///< Index out of range
+	SP_ERROR_USER_NEEDS_PREMIUM        = 15, ///< The specified user needs a premium account
+	SP_ERROR_OTHER_TRANSIENT           = 16, ///< A transient error occurred.
+	SP_ERROR_IS_LOADING                = 17, ///< The resource is currently loading
+	SP_ERROR_NO_STREAM_AVAILABLE       = 18, ///< Could not find any suitable stream to play
+	SP_ERROR_PERMISSION_DENIED         = 19, ///< Requested operation is not allowed
+	SP_ERROR_INBOX_IS_FULL             = 20, ///< Target inbox is full
+	SP_ERROR_NO_CACHE                  = 21, ///< Cache is not enabled
+	SP_ERROR_NO_SUCH_USER              = 22, ///< Requested user does not exist
+	SP_ERROR_NO_CREDENTIALS            = 23, ///< No credentials are stored
+	SP_ERROR_NETWORK_DISABLED          = 24, ///< Network disabled
+	SP_ERROR_INVALID_DEVICE_ID         = 25, ///< Invalid device ID
+	SP_ERROR_CANT_OPEN_TRACE_FILE      = 26, ///< Unable to open trace file
+	SP_ERROR_APPLICATION_BANNED        = 27, ///< This application is no longer allowed to use the Spotify service
+
+	SP_ERROR_OFFLINE_TOO_MANY_TRACKS   = 31, ///< Reached the device limit for number of tracks to download
+	SP_ERROR_OFFLINE_DISK_CACHE        = 32, ///< Disk cache is full so no more tracks can be downloaded to offline mode
+	SP_ERROR_OFFLINE_EXPIRED           = 33, ///< Offline key has expired, the user needs to go online again
+	SP_ERROR_OFFLINE_NOT_ALLOWED       = 34, ///< This user is not allowed to use offline mode
+	SP_ERROR_OFFLINE_LICENSE_LOST      = 35, ///< The license for this device has been lost. Most likely because the user used offline on three other device
+	SP_ERROR_OFFLINE_LICENSE_ERROR     = 36, ///< The Spotify license server does not respond correctly
+} sp_error;
+
+/**
+ * Convert a numeric libspotify error code to a text string
+ *
+ * @param[in]   error   The error code to lookup
+ */
+SP_LIBEXPORT(const char*) sp_error_message(sp_error error);
+
+/** @} */
+
+
+/**
+ * @defgroup session Session handling
+ *
+ * The concept of a session is fundamental for all communication with the Spotify ecosystem - it is the
+ * object responsible for communicating with the Spotify service. You will need to instantiate a
+ * session that then can be used to request artist information, perform searches etc.
+ *
+ * @{
+ */
+
+/**
+ * Current version of the application interface, that is, the API described by this file.
+ *
+ * This value should be set in the sp_session_config struct passed to sp_session_create().
+ *
+ * If an (upgraded) library is no longer compatible with this version the error #SP_ERROR_BAD_API_VERSION will be
+ * returned from sp_session_create(). Future versions of the library will provide you with some kind of mechanism
+ * to request an updated version of the library.
+ */
+#define SPOTIFY_API_VERSION 10
+
+/**
+ * Describes the current state of the connection
+ */
+typedef enum sp_connectionstate {
+	SP_CONNECTION_STATE_LOGGED_OUT   = 0, ///< User not yet logged in
+	SP_CONNECTION_STATE_LOGGED_IN    = 1, ///< Logged in against a Spotify access point
+	SP_CONNECTION_STATE_DISCONNECTED = 2, ///< Was logged in, but has now been disconnected
+	SP_CONNECTION_STATE_UNDEFINED    = 3, ///< The connection state is undefined
+	SP_CONNECTION_STATE_OFFLINE		 = 4  ///< Logged in in offline mode
+} sp_connectionstate;
+
+
+/**
+ * Sample type descriptor
+ */
+typedef enum sp_sampletype {
+	SP_SAMPLETYPE_INT16_NATIVE_ENDIAN = 0, ///< 16-bit signed integer samples
+} sp_sampletype;
+
+/**
+ * Audio format descriptor
+ */
+typedef struct sp_audioformat {
+	sp_sampletype sample_type;   ///< Sample type enum,
+	int sample_rate;             ///< Audio sample rate, in samples per second.
+	int channels;                ///< Number of channels. Currently 1 or 2.
+} sp_audioformat;
+
+/**
+ * Bitrate definitions for music streaming
+ */
+typedef enum sp_bitrate {
+  SP_BITRATE_160k = 0,
+  SP_BITRATE_320k = 1,
+  SP_BITRATE_96k = 2,
+} sp_bitrate;
+
+/**
+ * Playlist types
+ */
+typedef enum sp_playlist_type {
+	SP_PLAYLIST_TYPE_PLAYLIST     = 0, ///< A normal playlist.
+	SP_PLAYLIST_TYPE_START_FOLDER = 1, ///< Marks a folder starting point,
+	SP_PLAYLIST_TYPE_END_FOLDER   = 2, ///< and ending point.
+	SP_PLAYLIST_TYPE_PLACEHOLDER  = 3, ///< Unknown entry.
+} sp_playlist_type;
+
+/**
+ * Playlist offline status
+ */
+typedef enum sp_playlist_offline_status {
+	SP_PLAYLIST_OFFLINE_STATUS_NO          = 0, ///< Playlist is not offline enabled
+	SP_PLAYLIST_OFFLINE_STATUS_YES         = 1, ///< Playlist is synchronized to local storage
+	SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING = 2, ///< This playlist is currently downloading. Only one playlist can be in this state any given time
+	SP_PLAYLIST_OFFLINE_STATUS_WAITING     = 3, ///< Playlist is queued for download
+} sp_playlist_offline_status;
+
+/**
+ * Track availability
+ */
+typedef enum sp_availability {
+	SP_TRACK_AVAILABILITY_UNAVAILABLE = 0, ///< Track is not available
+	SP_TRACK_AVAILABILITY_AVAILABLE   = 1, ///< Track is available and can be played
+	SP_TRACK_AVAILABILITY_NOT_STREAMABLE = 2, ///< Track can not be streamed using this account
+	SP_TRACK_AVAILABILITY_BANNED_BY_ARTIST = 3, ///< Track not available on artist's reqeust
+} sp_track_availability;
+
+/**
+ * Track offline status
+ */
+typedef enum sp_track_offline_status {
+	SP_TRACK_OFFLINE_NO             = 0, ///< Not marked for offline
+	SP_TRACK_OFFLINE_WAITING        = 1, ///< Waiting for download
+	SP_TRACK_OFFLINE_DOWNLOADING    = 2, ///< Currently downloading
+	SP_TRACK_OFFLINE_DONE           = 3, ///< Downloaded OK and can be played
+	SP_TRACK_OFFLINE_ERROR          = 4, ///< Error during download
+	SP_TRACK_OFFLINE_DONE_EXPIRED   = 5, ///< Downloaded OK but not playable due to expiery
+	SP_TRACK_OFFLINE_LIMIT_EXCEEDED = 6, ///< Waiting because device have reached max number of allowed tracks
+	SP_TRACK_OFFLINE_DONE_RESYNC    = 7, ///< Downloaded OK and available but scheduled for re-download
+} sp_track_offline_status;
+
+/**
+ * Buffer stats used by get_audio_buffer_stats callback
+ */
+typedef struct sp_audio_buffer_stats {
+	int samples;                      ///< Samples in buffer
+	int stutter;                      ///< Number of stutters (audio dropouts) since last query
+} sp_audio_buffer_stats;
+
+/**
+ * List of subscribers returned by sp_playlist_subscribers()
+ */
+typedef struct sp_subscribers {
+	unsigned int count;    ///< Number of elements in 'subscribers'
+	char *subscribers[1];  ///< Actual size is 'count'. Array of pointers to canonical usernames
+} sp_subscribers;
+
+
+/**
+ * Current connection type set using sp_session_set_connection_type()
+ */
+typedef enum sp_connection_type {
+	SP_CONNECTION_TYPE_UNKNOWN        = 0, ///< Connection type unknown (Default)
+	SP_CONNECTION_TYPE_NONE           = 1, ///< No connection
+	SP_CONNECTION_TYPE_MOBILE         = 2, ///< Mobile data (EDGE, 3G, etc)
+	SP_CONNECTION_TYPE_MOBILE_ROAMING = 3, ///< Roamed mobile data (EDGE, 3G, etc)
+	SP_CONNECTION_TYPE_WIFI           = 4, ///< Wireless connection
+	SP_CONNECTION_TYPE_WIRED          = 5, ///< Ethernet cable, etc
+} sp_connection_type;
+
+
+/**
+ * Connection rules, bitwise OR of flags
+ *
+ * The default is SP_CONNECTION_RULE_NETWORK | SP_CONNECTION_RULE_ALLOW_SYNC
+ */
+typedef enum sp_connection_rules {
+	SP_CONNECTION_RULE_NETWORK                = 0x1, ///< Allow network traffic. When not set libspotify will force itself into offline mode
+	SP_CONNECTION_RULE_NETWORK_IF_ROAMING     = 0x2, ///< Allow network traffic even if roaming
+	SP_CONNECTION_RULE_ALLOW_SYNC_OVER_MOBILE = 0x4, ///< Set to allow syncing of offline content over mobile connections
+	SP_CONNECTION_RULE_ALLOW_SYNC_OVER_WIFI   = 0x8, ///< Set to allow syncing of offline content over WiFi
+} sp_connection_rules;
+
+
+/**
+ * Controls the type of data that will be included in artist browse queries
+ */
+typedef enum sp_artistbrowse_type {
+	SP_ARTISTBROWSE_FULL,         /**< All information */
+	SP_ARTISTBROWSE_NO_TRACKS,    /**< Only albums and data about them, no tracks.
+					   In other words, sp_artistbrowse_num_tracks() will return 0
+				      */
+	SP_ARTISTBROWSE_NO_ALBUMS,    /**< Only return data about the artist (artist name, similar artist
+					   biography, etc
+					   No tracks or album will be abailable.
+					   sp_artistbrowse_num_tracks() and sp_artistbrowse_num_albums()
+					   will both return 0
+				      */
+} sp_artistbrowse_type;
+
+
+/**
+ * Offline sync status
+ */
+typedef struct sp_offline_sync_status {
+	/**
+	 * Queued tracks/bytes is things left to sync in current sync
+	 * operation
+	 */
+	int queued_tracks;
+	sp_uint64 queued_bytes;
+
+	/**
+	 * Done tracks/bytes is things marked for sync that existed on
+	 * device before current sync operation
+	 */
+	int done_tracks;
+	sp_uint64 done_bytes;
+
+	/**
+	 * Copied tracks/bytes is things that has been copied in
+	 * current sync operation
+	 */
+	int copied_tracks;
+	sp_uint64 copied_bytes;
+
+	/**
+	 * Tracks that are marked as synced but will not be copied
+	 * (for various reasons)
+	 */
+	int willnotcopy_tracks;
+
+	/**
+	 * A track is counted as error when something goes wrong while
+	 * syncing the track
+	 */
+	int error_tracks;
+
+	/**
+	 * Set if sync operation is in progress
+	 */
+	bool syncing;
+
+} sp_offline_sync_status;
+
+
+/**
+ * Session callbacks
+ *
+ * Registered when you create a session.
+ * If some callbacks should not be of interest, set them to NULL.
+ */
+typedef struct sp_session_callbacks {
+
+	/**
+	 * Called when login has been processed and was successful
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      One of the following errors, from ::sp_error
+	 *                        SP_ERROR_OK
+	 *                        SP_ERROR_CLIENT_TOO_OLD
+	 *                        SP_ERROR_UNABLE_TO_CONTACT_SERVER
+	 *                        SP_ERROR_BAD_USERNAME_OR_PASSWORD
+	 *                        SP_ERROR_USER_BANNED
+	 *                        SP_ERROR_USER_NEEDS_PREMIUM
+	 *                        SP_ERROR_OTHER_TRANSIENT
+	 *                        SP_ERROR_OTHER_PERMANENT
+	 */
+	void (SP_CALLCONV *logged_in)(sp_session *session, sp_error error);
+
+	/**
+	 * Called when logout has been processed. Either called explicitly
+	 * if you initialize a logout operation, or implicitly if there
+	 * is a permanent connection error
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *logged_out)(sp_session *session);
+
+	/**
+	 * Called whenever metadata has been updated
+	 *
+	 * If you have metadata cached outside of libspotify, you should purge
+	 * your caches and fetch new versions.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *metadata_updated)(sp_session *session);
+
+	/**
+	 * Called when there is a connection error, and the library has problems
+	 * reconnecting to the Spotify service. Could be called multiple times (as
+	 * long as the problem is present)
+	 *
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      One of the following errors, from ::sp_error
+	 *                        SP_ERROR_OK
+	 *                        SP_ERROR_CLIENT_TOO_OLD
+	 *                        SP_ERROR_UNABLE_TO_CONTACT_SERVER
+	 *                        SP_ERROR_BAD_USERNAME_OR_PASSWORD
+	 *                        SP_ERROR_USER_BANNED
+	 *                        SP_ERROR_USER_NEEDS_PREMIUM
+	 *                        SP_ERROR_OTHER_TRANSIENT
+	 *                        SP_ERROR_OTHER_PERMANENT
+	 */
+	void (SP_CALLCONV *connection_error)(sp_session *session, sp_error error);
+
+	/**
+	 * Called when the access point wants to display a message to the user
+	 *
+	 * In the desktop client, these are shown in a blueish toolbar just below the
+	 * search box.
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  message    String in UTF-8 format.
+	 */
+	void (SP_CALLCONV *message_to_user)(sp_session *session, const char *message);
+
+	/**
+	 * Called when processing needs to take place on the main thread.
+	 *
+	 * You need to call sp_session_process_events() in the main thread to get
+	 * libspotify to do more work. Failure to do so may cause request timeouts,
+	 * or a lost connection.
+	 *
+	 * @param[in]  session    Session
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 */
+	void (SP_CALLCONV *notify_main_thread)(sp_session *session);
+
+	/**
+	 * Called when there is decompressed audio data available.
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  format     Audio format descriptor sp_audioformat
+	 * @param[in]  frames     Points to raw PCM data as described by \p format
+	 * @param[in]  num_frames Number of available samples in \p frames.
+	 *                        If this is 0, a discontinuity has occurred (such as after a seek). The application
+	 *                        should flush its audio fifos, etc.
+	 *
+	 * @return                Number of frames consumed.
+	 *                        This value can be used to rate limit the output from the library if your
+	 *                        output buffers are saturated. The library will retry delivery in about 100ms.
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block. If your output buffers are full you must return 0 to signal
+	 *       that the library should retry delivery in a short while.
+	 */
+	int (SP_CALLCONV *music_delivery)(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames);
+
+	/**
+	 * Music has been paused because only one account may play music at the same time.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *play_token_lost)(sp_session *session);
+
+	/**
+	 * Logging callback.
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  data       Log data
+	 */
+	void (SP_CALLCONV *log_message)(sp_session *session, const char *data);
+
+	/**
+	 * End of track.
+	 * Called when the currently played track has reached its end.
+	 *
+	 * @note This function is invoked from the same internal thread
+	 * as the music delivery callback
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *end_of_track)(sp_session *session);
+
+	/**
+	 * Streaming error.
+	 * Called when streaming cannot start or continue
+	 *
+	 * @note This function is invoked from the main thread
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      One of the following errors, from ::sp_error
+	 *                        SP_ERROR_NO_STREAM_AVAILABLE
+	 *                        SP_ERROR_OTHER_TRANSIENT
+	 *                        SP_ERROR_OTHER_PERMANENT
+	 */
+	void (SP_CALLCONV *streaming_error)(sp_session *session, sp_error error);
+
+	/**
+	 * Called after user info (anything related to sp_user objects) have been updated.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *userinfo_updated)(sp_session *session);
+
+	/**
+	 * Called when audio playback should start
+	 *
+	 * @note For this to work correctly the application must also implement get_audio_buffer_stats()
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *start_playback)(sp_session *session);
+
+
+	/**
+	 * Called when audio playback should stop
+	 *
+	 * @note For this to work correctly the application must also implement get_audio_buffer_stats()
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block.
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *stop_playback)(sp_session *session);
+
+	/**
+	 * Called to query application about its audio buffer
+	 *
+	 * @note This function is called from an internal session thread - you need to have proper synchronization!
+	 *
+	 * @note This function must never block.
+	 *
+	 * @param[in]  session    Session
+	 * @param[out] stats      Stats struct to be filled by application
+	 */
+	void (SP_CALLCONV *get_audio_buffer_stats)(sp_session *session, sp_audio_buffer_stats *stats);
+
+	/**
+	 * Called when offline synchronization status is updated
+	 *
+	 * @param[in]  session    Session
+	 */
+	void (SP_CALLCONV *offline_status_updated)(sp_session *session);
+
+	/**
+	 * Called when offline synchronization status is updated
+	 *
+	 * @param[in]  session    Session
+	 * @param[in]  error      Offline error. Will be SP_ERROR_OK if the offline synchronization
+	 *                        error state has cleared
+	 */
+	void (SP_CALLCONV *offline_error)(sp_session *session, sp_error error);
+
+
+} sp_session_callbacks;
+
+/**
+ * Session config
+ */
+typedef struct sp_session_config {
+	int api_version;                       ///< The version of the Spotify API your application is compiled with. Set to #SPOTIFY_API_VERSION
+	const char *cache_location;            /**< The location where Spotify will write cache files.
+						*   This cache include tracks, cached browse results and coverarts.
+	                                        *   Set to empty string ("") to disable cache
+						*/
+	const char *settings_location;         /**< The location where Spotify will write setting files and per-user
+						*   cache items. This includes playlists, track metadata, etc.
+						*   'settings_location' may be the same path as 'cache_location'.
+						*   'settings_location' folder will not be created (unlike 'cache_location'),
+						*   if you don't want to create the folder yourself, you can set 'settings_location' to 'cache_location'.
+						*/
+	const void *application_key;           ///< Your application key
+	size_t application_key_size;           ///< The size of the application key in bytes
+	const char *user_agent;                /**< "User-Agent" for your application - max 255 characters long
+						     The User-Agent should be a relevant, customer facing identification of your application
+					       */
+
+	const sp_session_callbacks *callbacks; ///< Delivery callbacks for session events, or NULL if you are not interested in any callbacks (not recommended!)
+	void *userdata;                        ///< User supplied data for your application
+
+	/**
+	 * Compress local copy of playlists, reduces disk space usage
+	 */
+	bool compress_playlists;
+
+	/**
+	 * Don't save metadata for local copies of playlists
+	 * Reduces disk space usage at the expense of needing
+	 * to request metadata from Spotify backend when loading list
+	 */
+	bool dont_save_metadata_for_playlists;
+
+	/**
+	 * Avoid loading playlists into RAM on startup.
+	 * See sp_playlist_is_in_ram() for more details.
+	 */
+	bool initially_unload_playlists;
+
+	/**
+	 * Device ID for offline synchronization
+	 */
+	const char *device_id;
+
+	/**
+	 * Path to API trace file
+	 */
+	const char *tracefile;
+
+} sp_session_config;
+
+/**
+ * Initialize a session. The session returned will be initialized, but you will need
+ * to log in before you can perform any other operation
+ * Currently it is not supported to have multiple active sessions, and it's recommended to only call this once per process.
+ *
+ * Here is a snippet from \c spshell.c:
+ * @dontinclude spshell.c
+ * @skip config.api_version
+ * @until }
+ *
+ * @param[in]   config    The configuration to use for the session
+ * @param[out]  sess      If successful, a new session - otherwise NULL
+ *
+ * @return                One of the following errors, from ::sp_error
+ *                        SP_ERROR_OK
+ *                        SP_ERROR_BAD_API_VERSION
+ *                        SP_ERROR_BAD_USER_AGENT
+ *                        SP_ERROR_BAD_APPLICATION_KEY
+ *                        SP_ERROR_API_INITIALIZATION_FAILED
+ *                        SP_ERROR_INVALID_DEVICE_ID
+ */
+SP_LIBEXPORT(sp_error) sp_session_create(const sp_session_config *config, sp_session **sess);
+
+/**
+ * Release the session. This will clean up all data and connections associated with the session
+ *
+ * @param[in]   sess      Session object returned from sp_session_create()
+ */
+SP_LIBEXPORT(void) sp_session_release(sp_session *sess);
+
+
+/**
+ * Logs in the specified username/password combo. This initiates the login in the background.
+ * A callback is called when login is complete
+ *
+ * An application MUST NEVER store the user's password in clear text.
+ * If automatic relogin is required, use sp_session_relogin()
+ *
+ * Here is a snippet from \c spshell.c:
+ * @dontinclude spshell.c
+ * @skip sp_session_login
+ * @until }
+ *
+ * @param[in]   session             Your session object
+ * @param[in]   username            The username to log in
+ * @param[in]   password            The password for the specified username
+ * @param[in]   remember_me         If set, the username / password will be remembered by libspotify
+ */
+SP_LIBEXPORT(void) sp_session_login(sp_session *session, const char *username, const char *password, bool remember_me);
+
+
+/**
+ * Log in the remembered user if last user that logged in logged in with remember_me set.
+ * If no credentials are stored, this will return SP_ERROR_NO_CREDENTIALS.
+ *
+ * @param[in]   session      Your session object
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_OK
+ *                         SP_ERROR_NO_CREDENTIALS
+ */
+SP_LIBEXPORT(sp_error) sp_session_relogin(sp_session *session);
+
+
+/**
+ * Get username of the user that will be logged in via sp_session_relogin()
+ *
+ * @param[in]   session      Your session object
+ * @param[out]  buffer       The buffer to hold the username
+ * @param[in]   buffer_size  The max size of the buffer that will hold the username.
+ *                           The resulting string is guaranteed to always be null terminated if
+ *                           buffer_size > 0
+ *
+ * @return                   The number of characters in the username.
+ *                           If value is greater or equal than \p buffer_size, output was truncated.
+ *                           If returned value is -1 no credentials are stored in libspotify.
+ */
+SP_LIBEXPORT(int) sp_session_remembered_user(sp_session *session, char *buffer, size_t buffer_size);
+
+
+/**
+ * Remove stored credentials in libspotify. If no credentials are currently stored, nothing will happen.
+ *
+ * @param[in]   session      Your session object
+ *
+ */
+SP_LIBEXPORT(void) sp_session_forget_me(sp_session *session);
+
+
+/**
+ * Fetches the currently logged in user
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 The logged in user (or NULL if not logged in)
+ */
+SP_LIBEXPORT(sp_user *) sp_session_user(sp_session *session);
+
+/**
+ * Logs out the currently logged in user
+ *
+ * Always call this before terminating the application and libspotify is currently
+ * logged in. Otherwise, the settings and cache may be lost.
+ *
+ * @param[in]   session    Your session object
+ */
+SP_LIBEXPORT(void) sp_session_logout(sp_session *session);
+
+/**
+ * The connection state of the specified session.
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 The connection state - see the sp_connectionstate enum for possible values
+ */
+SP_LIBEXPORT(sp_connectionstate) sp_session_connectionstate(sp_session *session);
+
+/**
+ * The userdata associated with the session
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 The userdata that was passed in on session creation
+ */
+SP_LIBEXPORT(void *) sp_session_userdata(sp_session *session);
+
+/**
+ * Set maximum cache size.
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   size       Maximum cache size in megabytes.
+ *                         Setting it to 0 (the default) will let libspotify automatically
+ *                         resize the cache (10% of disk free space)
+ */
+SP_LIBEXPORT(void) sp_session_set_cache_size(sp_session *session, size_t size);
+
+/**
+ * Make the specified session process any pending events
+ *
+ * @param[in]   session         Your session object
+ * @param[out]  next_timeout    Stores the time (in milliseconds) until you should call this function again
+ */
+SP_LIBEXPORT(void) sp_session_process_events(sp_session *session, int *next_timeout);
+
+/**
+ * Loads the specified track
+ *
+ * After successfully loading the track, you have the option of running
+ * sp_session_player_play() directly, or using sp_session_player_seek() first.
+ * When this call returns, the track will have been loaded, unless an error occurred.
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   track      The track to be loaded
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_OK
+ *                         SP_ERROR_MISSING_CALLBACK
+ *                         SP_ERROR_RESOURCE_NOT_LOADED
+ *                         SP_ERROR_TRACK_NOT_PLAYABLE
+ *
+ */
+SP_LIBEXPORT(sp_error) sp_session_player_load(sp_session *session, sp_track *track);
+
+/**
+ * Seek to position in the currently loaded track
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   offset     Track position, in milliseconds.
+ *
+ */
+SP_LIBEXPORT(void) sp_session_player_seek(sp_session *session, int offset);
+
+/**
+ * Play or pause the currently loaded track
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   play       If set to true, playback will occur. If set to false, the playback will be paused.
+ *
+ */
+SP_LIBEXPORT(void) sp_session_player_play(sp_session *session, bool play);
+
+/**
+ * Stops the currently playing track
+ *
+ * This frees some resources held by libspotify to identify the currently
+ * playing track.
+ *
+ * @param[in]   session    Your session object
+ *
+ */
+SP_LIBEXPORT(void) sp_session_player_unload(sp_session *session);
+
+/**
+ * Prefetch a track
+ *
+ * Instruct libspotify to start loading of a track into its cache.
+ * This could be done by an application just before the current track ends.
+ *
+ * @param[in]   session    Your session object
+ * @param[in]   track      The track to be prefetched
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_NO_CACHE
+ *                         SP_ERROR_OK
+ *
+ * @note Prefetching is only possible if a cache is configured
+ *
+ */
+SP_LIBEXPORT(sp_error) sp_session_player_prefetch(sp_session *session, sp_track *track);
+
+/**
+ * Returns the playlist container for the currently logged in user.
+ *
+ * @param[in]   session    Your session object
+ *
+ * @return                 Playlist container object, NULL if not logged in
+ */
+SP_LIBEXPORT(sp_playlistcontainer *) sp_session_playlistcontainer(sp_session *session);
+
+/**
+ * Returns an inbox playlist for the currently logged in user
+ *
+ * @param[in]  session        Session object
+ *
+ * @return     A playlist or NULL if no user is logged in
+ * @note You need to release the playlist when you are done with it.
+ * @see sp_playlist_release()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_session_inbox_create(sp_session *session);
+
+/**
+ * Returns the starred list for the current user
+ *
+ * @param[in]  session        Session object
+ *
+ * @return     A playlist or NULL if no user is logged in
+ * @note You need to release the playlist when you are done with it.
+ * @see sp_playlist_release()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_session_starred_create(sp_session *session);
+
+/**
+ * Returns the starred list for a user
+ *
+ * @param[in]  session        Session object
+ * @param[in]  canonical_username       Canonical username
+ *
+ * @return     A playlist or NULL if no user is logged in
+ * @note You need to release the playlist when you are done with it.
+ * @see sp_playlist_release()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_session_starred_for_user_create(sp_session *session, const char *canonical_username);
+
+/**
+ * Return the published container for a given @a canonical_username,
+ * or the currently logged in user if @a canonical_username is NULL.
+ *
+ * When done with the list you should call sp_playlistconatiner_release() to
+ * decrese the reference you own by having created it.
+ *
+ * @param[in]   session    Your session object.
+ * @param[in]   canonical_username   The canonical username, or NULL.
+ *
+ * @return Playlist container object, NULL if not logged in.
+ */
+SP_LIBEXPORT(sp_playlistcontainer *) sp_session_publishedcontainer_for_user_create(sp_session *session, const char *canonical_username);
+
+
+/**
+ * Set preferred bitrate for music streaming
+ *
+ * @param[in]  session        Session object
+ * @param[in]  bitrate        Preferred bitrate, see ::sp_bitrate for possible values
+ *
+ */
+SP_LIBEXPORT(void) sp_session_preferred_bitrate(sp_session *session, sp_bitrate bitrate);
+
+
+/**
+ * Set preferred bitrate for offline sync
+ *
+ * @param[in]  session        Session object
+ * @param[in]  bitrate        Preferred bitrate, see ::sp_bitrate for possible values
+ * @param[in]  allow_resync   Set to true if libspotify should resynchronize already synchronized tracks. Usually you should set this to false.
+ *
+ */
+SP_LIBEXPORT(void) sp_session_preferred_offline_bitrate(sp_session *session, sp_bitrate bitrate, bool allow_resync);
+
+
+/**
+ * Return status of volume normalization
+ *
+ * @param[in]  session        Session object
+ *
+ * @return true iff volume normalization is enabled
+ *
+ */
+SP_LIBEXPORT(bool) sp_session_get_volume_normalization(sp_session *session);
+
+
+/**
+ * Set volume normalization
+ *
+ * @param[in]  session        Session object
+ * @param[in]  on             True iff volume normalization should be enabled
+ *
+ */
+SP_LIBEXPORT(void) sp_session_set_volume_normalization(sp_session *session, bool on);
+
+
+
+/**
+ * Set to true if the connection is currently routed over a roamed connectivity
+ *
+ * @param[in]  session        Session object
+ * @param[in]  type           Connection type
+ *
+ * @note       Used in conjunction with sp_session_set_connection_rules() to control
+ *             how libspotify should behave in respect to network activity and offline
+ *             synchronization.
+ */
+SP_LIBEXPORT(void) sp_session_set_connection_type(sp_session *session, sp_connection_type type);
+
+
+/**
+ * Set rules for how libspotify connects to Spotify servers and synchronizes offline content
+ *
+ * @param[in]  session        Session object
+ * @param[in]  rules          Connection rules
+ *
+ * @note       Used in conjunction with sp_session_set_connection_type() to control
+ *             how libspotify should behave in respect to network activity and offline
+ *             synchronization.
+ */
+SP_LIBEXPORT(void) sp_session_set_connection_rules(sp_session *session, sp_connection_rules rules);
+
+
+
+/**
+ * Get total number of tracks that needs download before everything
+ * from all playlists that is marked for offline is fully synchronized
+ *
+ * @param[in]  session        Session object
+ *
+ * @return Number of tracks
+ */
+SP_LIBEXPORT(int) sp_offline_tracks_to_sync(sp_session *session);
+
+/**
+ * Return number of playlisys that is marked for offline synchronization
+ *
+ * @param[in]  session        Session object
+ *
+ * @return Number of playlists
+ */
+SP_LIBEXPORT(int) sp_offline_num_playlists(sp_session *session);
+
+/**
+ * Return offline synchronization status. When the internal status is
+ * updated the offline_status_updated() callback will be invoked.
+ *
+ * @param[in]  session        Session object
+ * @param[out] status         Status object that will be filled with info
+ *
+ * @return false if no synching is in progress (in which case the contents
+ *               of status is undefined)
+ *
+ */
+SP_LIBEXPORT(bool) sp_offline_sync_get_status(sp_session *session, sp_offline_sync_status *status);
+
+/**
+ * Return remaining time (in seconds) until the offline key store expires
+ * and the user is required to relogin
+ *
+ * @param[in]  session        Session object
+ * @return                    Seconds until expiration
+ *
+ */
+SP_LIBEXPORT(int) sp_offline_time_left(sp_session *session);
+
+/**
+ * Get currently logged in users country
+ * updated the offline_status_updated() callback will be invoked.
+ *
+ * @param[in]  session        Session object
+ *
+ * @return  Country encoded in an integer 'SE' = 'S' << 8 | 'E'
+ */
+SP_LIBEXPORT(int) sp_session_user_country(sp_session *session);
+
+
+/** @} */
+
+
+/**
+ * @defgroup link Links (Spotify URIs)
+ *
+ * These functions handle links to Spotify entities in a way that allows you to
+ * not care about the textual representation of the link.
+ * @{
+ */
+
+/**
+ * Link types
+ */
+typedef enum {
+	SP_LINKTYPE_INVALID  = 0, ///< Link type not valid - default until the library has parsed the link, or when parsing failed
+	SP_LINKTYPE_TRACK    = 1, ///< Link type is track
+	SP_LINKTYPE_ALBUM    = 2, ///< Link type is album
+	SP_LINKTYPE_ARTIST   = 3, ///< Link type is artist
+	SP_LINKTYPE_SEARCH   = 4, ///< Link type is search
+	SP_LINKTYPE_PLAYLIST = 5, ///< Link type is playlist
+	SP_LINKTYPE_PROFILE  = 6, ///< Link type is profile
+	SP_LINKTYPE_STARRED  = 7, ///< Link type is starred
+	SP_LINKTYPE_LOCALTRACK  = 8, ///< Link type is a local file
+	SP_LINKTYPE_IMAGE = 9, ///< Link type is an image
+} sp_linktype;
+
+/**
+ * Create a Spotify link given a string
+ *
+ * @param[in]   link       A string representation of a Spotify link
+ *
+ * @return                 A link representation of the given string representation.
+ *                         If the link could not be parsed, this function returns NULL.
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_type()
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_string(const char *link);
+
+/**
+ * Generates a link object from a track
+ *
+ * @param[in]   track        A track object
+ * @param[in]   offset       Offset in track in ms.
+ *
+ * @return                   A link representing the track
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_track(sp_track *track, int offset);
+
+/**
+ * Create a link object from an album
+ *
+ * @param[in]   album      An album object
+ *
+ * @return                 A link representing the album
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_album(sp_album *album);
+
+/**
+ * Create an image link object from an album
+ *
+ * @param[in]   album      An album object
+ *
+ * @return                 A link representing the album cover. Type is set to SP_LINKTYPE_IMAGE
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_album_cover(sp_album *album);
+
+/**
+ * Creates a link object from an artist
+ *
+ * @param[in]   artist     An artist object
+ *
+ * @return                 A link object representing the artist
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_artist(sp_artist *artist);
+
+/**
+ * Creates a link object pointing to an artist portrait
+ *
+ * @param[in]   artist     Artist browse object
+ *
+ * @return                 A link object representing an image
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ * @see sp_artistbrowse_num_portraits()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_artist_portrait(sp_artist *artist);
+
+
+/**
+ * Creates a link object from an artist portrait
+ *
+ * @param[in]   arb        Artist browse object
+ * @param[in]   index      The index of the portrait. Should be in the interval [0, sp_artistbrowse_num_portraits() - 1]
+ *
+ * @return                 A link object representing an image
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ * @see sp_artistbrowse_num_portraits()
+ *
+ * @note The difference from sp_link_create_from_artist_portrait() is
+ * that the artist browse object may contain multiple portraits.
+ *
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_artistbrowse_portrait(sp_artistbrowse *arb, int index);
+
+
+/**
+ * Generate a link object representing the current search
+ *
+ * @param[in]  search       Search object
+ *
+ * @return                  A link representing the search
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_search(sp_search *search);
+
+/**
+ * Create a link object representing the given playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return                    A link representing the playlist
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ *
+ * @note Due to reasons in the playlist backend design and the Spotify URI
+ * scheme you need to wait for the playlist to be loaded before you can
+ * successfully construct an URI. If sp_link_create_from_playlist() returns
+ * NULL, try again after teh playlist_state_changed callback has fired.
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_playlist(sp_playlist *playlist);
+
+/**
+ * Create a link object representing the given playlist
+ *
+ * @param[in]  user       User object
+ *
+ * @return                    A link representing the profile.
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_user(sp_user *user);
+
+/**
+ * Create a link object representing the given image
+ *
+ * @param[in]  image          Image object
+ *
+ * @return                    A link representing the image.
+ *
+ * @note You need to release the link when you are done with it.
+ * @see sp_link_release()
+ */
+SP_LIBEXPORT(sp_link *) sp_link_create_from_image(sp_image *image);
+
+/**
+ * Create a string representation of the given Spotify link
+ *
+ * @param[in]   link         The Spotify link whose string representation you are interested in
+ * @param[out]  buffer       The buffer to hold the string representation of link
+ * @param[in]   buffer_size  The max size of the buffer that will hold the string representation
+ *                           The resulting string is guaranteed to always be null terminated if
+ *                           buffer_size > 0
+ *
+ * @return                   The number of characters in the string representation of the link. If this
+ *                           value is greater or equal than \p buffer_size, output was truncated.
+ */
+SP_LIBEXPORT(int) sp_link_as_string(sp_link *link, char *buffer, int buffer_size);
+
+/**
+ * The link type of the specified link
+ *
+ * @param[in]   link       The Spotify link whose type you are interested in
+ *
+ * @return                 The link type of the specified link - see the sp_linktype enum for possible values
+ */
+SP_LIBEXPORT(sp_linktype) sp_link_type(sp_link *link);
+
+/**
+ * The track representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose track you are interested in
+ *
+ * @return                 The track representation of the given track link
+ *                         If the link is not of track type then NULL is returned.
+ */
+SP_LIBEXPORT(sp_track *) sp_link_as_track(sp_link *link);
+
+/**
+ * The track and offset into track representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose track you are interested in
+ * @param[out]  offset     Pointer to offset into track (in milliseconds). If the link
+ *                         does not contain an offset this will be set to 0.
+ *
+ * @return                 The track representation of the given track link
+ *                         If the link is not of track type then NULL is returned.
+ */
+SP_LIBEXPORT(sp_track *) sp_link_as_track_and_offset(sp_link *link, int *offset);
+
+/**
+ * The album representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose album you are interested in
+ *
+ * @return                 The album representation of the given album link
+ *                         If the link is not of album type then NULL is returned
+ */
+SP_LIBEXPORT(sp_album *) sp_link_as_album(sp_link *link);
+
+/**
+ * The artist representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose artist you are interested in
+ *
+ * @return                 The artist representation of the given link
+ *                         If the link is not of artist type then NULL is returned
+ */
+SP_LIBEXPORT(sp_artist *) sp_link_as_artist(sp_link *link);
+
+
+/**
+ * The user representation for the given link
+ *
+ * @param[in]   link       The Spotify link whose user you are interested in
+ *
+ * @return                 The user representation of the given link
+ *                         If the link is not of user type then NULL is returned
+ */
+SP_LIBEXPORT(sp_user *) sp_link_as_user(sp_link *link);
+
+
+/**
+ * Increase the reference count of a link
+ *
+ * @param[in]   link       The link object
+ */
+SP_LIBEXPORT(void) sp_link_add_ref(sp_link *link);
+
+/**
+ * Decrease the reference count of a link
+ *
+ * @param[in]   link       The link object
+ */
+SP_LIBEXPORT(void) sp_link_release(sp_link *link);
+
+/** @} */
+
+
+
+/**
+ * @defgroup track Track subsystem
+ * @{
+ */
+
+/**
+ * Return whether or not the track metadata is loaded.
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is loaded
+ *
+ * @note  This is equivalent to checking if sp_track_error() not returns SP_ERROR_IS_LOADING.
+ */
+SP_LIBEXPORT(bool) sp_track_is_loaded(sp_track *track);
+
+/**
+ * Return an error code associated with a track. For example if it could not load
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 One of the following errors, from ::sp_error
+ *                         SP_ERROR_OK
+ *                         SP_ERROR_IS_LOADING
+ *                         SP_ERROR_OTHER_PERMANENT
+ */
+SP_LIBEXPORT(sp_error) sp_track_error(sp_track *track);
+
+
+/**
+ * Return offline status for a track. sp_session_callbacks::metadata_updated() will be invoked when
+ * offline status of a track changes
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 Stats as described by ::sp_track_offline_status
+ *
+ */
+SP_LIBEXPORT(sp_track_offline_status) sp_track_offline_get_status(sp_track *track);
+
+/**
+ * Return availability for a track
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 Availability status, see ::sp_track_availability
+ *
+ * @note The track must be loaded or this function will always SP_TRACK_AVAILABILITY_UNAVAILABLE
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(sp_track_availability) sp_track_get_availability(sp_session *session, sp_track *track);
+
+/**
+ * Return true if the track is a local file.
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is a local file.
+ *
+ * @note The track must be loaded or this function will always return false.
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_track_is_local(sp_session *session, sp_track *track);
+
+/**
+ * Return true if the track is autolinked to another track.
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is autolinked.
+ *
+ * @note The track must be loaded or this function will always return false.
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_track_is_autolinked(sp_session *session, sp_track *track);
+
+/**
+ * Return true if the track is a placeholder. Placeholder tracks are used
+ * to store other objects than tracks in the playlist. Currently this is
+ * used in the inbox to store artists, albums and playlists.
+ *
+ * Use sp_link_create_from_track() to get a link object that points
+ * to the real object this "track" points to.
+ *
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is a placeholder
+ *
+ * @note Contrary to most functions the track does not have to be
+ *       loaded for this function to return correct value
+ */
+SP_LIBEXPORT(bool) sp_track_is_placeholder(sp_track *track);
+
+
+/**
+ * Return true if the track is starred by the currently logged in user.
+ *
+ * @param[in]   session    Session
+ * @param[in]   track      The track
+ *
+ * @return                 True if track is starred.
+ *
+ * @note The track must be loaded or this function will always return false.
+ * @see sp_track_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_track_is_starred(sp_session *session, sp_track *track);
+
+/**
+ * Star/Unstar the specified track
+ *
+ * @param[in]   session    Session
+ * @param[in]   tracks     Array of pointer to tracks.
+ * @param[in]   num_tracks Length of \p tracks array
+ * @param[in]   star       Starred status of the track
+ *
+ * @note This will fail silently if playlists are disabled.
+ * @see sp_set_playlists_enabled()
+ */
+SP_LIBEXPORT(void) sp_track_set_starred(sp_session *session, sp_track *const*tracks, int num_tracks, bool star);
+
+/**
+ * The number of artists performing on the specified track
+ *
+ * @param[in]   track     The track whose number of participating artists you are interested in
+ *
+ * @return                The number of artists performing on the specified track.
+ *                        If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(int) sp_track_num_artists(sp_track *track);
+
+/**
+ * The artist matching the specified index performing on the current track.
+ *
+ * @param[in]   track      The track whose participating artist you are interested in
+ * @param[in]   index      The index for the participating artist. Should be in the interval [0, sp_track_num_artists() - 1]
+ *
+ * @return                 The participating artist, or NULL if invalid index
+ */
+SP_LIBEXPORT(sp_artist *) sp_track_artist(sp_track *track, int index);
+
+/**
+ * The album of the specified track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 The album of the given track. You need to increase the refcount
+ *                         if you want to keep the pointer around.
+ *                         If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(sp_album *) sp_track_album(sp_track *track);
+
+/**
+ * The string representation of the specified track's name
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 The string representation of the specified track's name.
+ *                         Returned string is valid as long as the album object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ *                         If no metadata is available for the track yet, this function returns empty string.
+ */
+SP_LIBEXPORT(const char *) sp_track_name(sp_track *track);
+
+/**
+ * The duration, in milliseconds, of the specified track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 The duration of the specified track, in milliseconds
+ *                         If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(int) sp_track_duration(sp_track *track);
+
+/**
+ * Returns popularity for track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 Popularity in range 0 to 100, 0 if undefined.
+ *                         If no metadata is available for the track yet, this function returns 0.
+ */
+SP_LIBEXPORT(int) sp_track_popularity(sp_track *track);
+
+/**
+ * Returns the disc number for a track
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 Disc index. Possible values are [1, total number of discs on album]
+ *                         This function returns valid data only for tracks appearing in a browse
+ *                         artist or browse album result (otherwise returns 0).
+ */
+SP_LIBEXPORT(int) sp_track_disc(sp_track *track);
+
+/**
+ * Returns the position of a track on its disc
+ *
+ * @param[in]   track      A track object
+ *
+ * @return                 Track position, starts at 1 (relative the corresponding disc)
+ *                         This function returns valid data only for tracks appearing in a browse
+ *                         artist or browse album result (otherwise returns 0).
+ */
+SP_LIBEXPORT(int) sp_track_index(sp_track *track);
+
+/**
+ * Returns the newly created local track
+ *
+ * @param[in]   artist     Name of the artist
+ * @param[in]   title      Song title
+ * @param[in]   album      Name of the album, or an empty string if not available
+ * @param[in]   length      Length in MS, or -1 if not available.
+ *
+ * @return                 A track.
+ */
+SP_LIBEXPORT(sp_track *) sp_localtrack_create(const char *artist, const char *title, const char *album, int length);
+
+/**
+ * Increase the reference count of a track
+ *
+ * @param[in]   track       The track object
+ */
+SP_LIBEXPORT(void) sp_track_add_ref(sp_track *track);
+
+/**
+ * Decrease the reference count of a track
+ *
+ * @param[in]   track       The track object
+ */
+SP_LIBEXPORT(void) sp_track_release(sp_track *track);
+
+/** @} */
+
+
+
+/**
+ * @defgroup album Album subsystem
+ * @{
+ */
+
+/**
+ * Album types
+ */
+typedef enum {
+	SP_ALBUMTYPE_ALBUM       = 0, ///< Normal album
+	SP_ALBUMTYPE_SINGLE      = 1, ///< Single
+	SP_ALBUMTYPE_COMPILATION = 2, ///< Compilation
+	SP_ALBUMTYPE_UNKNOWN     = 3, ///< Unknown type
+} sp_albumtype;
+
+/**
+ * Check if the album object is populated with data
+ *
+ * @param[in]  album       Album object
+ * @return True if metadata is present, false if not
+ */
+SP_LIBEXPORT(bool) sp_album_is_loaded(sp_album *album);
+
+
+/**
+ * Return true if the album is available in the current region.
+ *
+ * @param[in]   album      The album
+ *
+ * @return                 True if album is available for playback, otherwise false.
+ *
+ * @note The album must be loaded or this function will always return false.
+ * @see sp_album_is_loaded()
+ */
+SP_LIBEXPORT(bool) sp_album_is_available(sp_album *album);
+
+/**
+ * Get the artist associated with the given album
+ *
+ * @param[in]  album       Album object
+ * @return A reference to the artist. NULL if the metadata has not been loaded yet
+ */
+SP_LIBEXPORT(sp_artist *) sp_album_artist(sp_album *album);
+
+/**
+ * Return image ID representing the album's coverart.
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 ID byte sequence that can be passed to sp_image_create()
+ *                         If the album has no image or the metadata for the album is not
+ *                         loaded yet, this function returns NULL.
+ *
+ * @see sp_image_create
+ */
+SP_LIBEXPORT(const s_byte *) sp_album_cover(sp_album *album);
+
+/**
+ * Return name of album
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 Name of album.
+ *                         Returned string is valid as long as the album object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_album_name(sp_album *album);
+
+/**
+ * Return release year of specified album
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 Release year
+ */
+SP_LIBEXPORT(int) sp_album_year(sp_album *album);
+
+
+/**
+ * Return type of specified album
+ *
+ * @param[in]   album      Album object
+ *
+ * @return                 sp_albumtype
+ */
+SP_LIBEXPORT(sp_albumtype) sp_album_type(sp_album *album);
+
+
+/**
+ * Increase the reference count of an album
+ *
+ * @param[in]   album       The album object
+ */
+SP_LIBEXPORT(void) sp_album_add_ref(sp_album *album);
+
+/**
+ * Decrease the reference count of an album
+ *
+ * @param[in]   album       The album object
+ */
+SP_LIBEXPORT(void) sp_album_release(sp_album *album);
+
+/** @} */
+
+
+
+/**
+ * @defgroup artist Artist subsystem
+ * @{
+ */
+
+/**
+ * Return name of artist
+ *
+ * @param[in]   artist     Artist object
+ *
+ * @return                 Name of artist.
+ *                         Returned string is valid as long as the artist object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_artist_name(sp_artist *artist);
+
+/**
+ * Check if the artist object is populated with data
+ *
+ * @param[in]   artist     An artist object
+ *
+ * @return                 True if metadata is present, false if not
+ *
+ */
+SP_LIBEXPORT(bool) sp_artist_is_loaded(sp_artist *artist);
+
+/**
+ * Return portrait for artist
+ *
+ * @param[in]   artist       The artist object
+ *
+ * @return                 ID byte sequence that can be passed to sp_image_create()
+ *                         If the album has no image or the metadata for the album is not
+ *                         loaded yet, this function returns NULL.
+ *
+ */
+SP_LIBEXPORT(const s_byte *) sp_artist_portrait(sp_artist *artist);
+
+/**
+ * Increase the reference count of a artist
+ *
+ * @param[in]   artist       The artist object
+ */
+SP_LIBEXPORT(void) sp_artist_add_ref(sp_artist *artist);
+
+/**
+ * Decrease the reference count of a artist
+ *
+ * @param[in]   artist       The artist object
+ */
+SP_LIBEXPORT(void) sp_artist_release(sp_artist *artist);
+
+/** @} */
+
+
+/**
+ * @defgroup albumbrowse Album browsing
+ *
+ * Browsing adds additional information to what an ::sp_album holds. It retrieves
+ * copyrights, reviews and tracks of the album.
+ *
+ * @{
+ */
+
+/**
+ * The type of a callback used in sp_albumbrowse_create()
+ *
+ * When the callback is called, the metadata of all tracks belonging to it will have
+ * been loaded, so sp_track_is_loaded() will return non-zero. The ::sp_artist of the
+ * album will also have been fully loaded.
+ *
+ * @param[in]   result          The same pointer returned by sp_albumbrowse_create()
+ * @param[in]   userdata        The opaque pointer given to sp_albumbrowse_create()
+ */
+typedef void SP_CALLCONV albumbrowse_complete_cb(sp_albumbrowse *result, void *userdata);
+
+/**
+ * Initiate a request for browsing an album
+ *
+ * The user is responsible for freeing the returned album browse using sp_albumbrowse_release(). This can be done in the callback.
+ *
+ * @param[in]   session         Session object
+ * @param[in]   album           Album to be browsed. The album metadata does not have to be loaded
+ * @param[in]   callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.
+ * @param[in]   userdata        Userdata passed to callback.
+ *
+ * @return                      Album browse object
+ *
+ * @see ::albumbrowse_complete_cb
+ */
+SP_LIBEXPORT(sp_albumbrowse *) sp_albumbrowse_create(sp_session *session, sp_album *album, albumbrowse_complete_cb *callback, void *userdata);
+
+/**
+ * Check if an album browse request is completed
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 True if browsing is completed, false if not
+ */
+SP_LIBEXPORT(bool) sp_albumbrowse_is_loaded(sp_albumbrowse *alb);
+
+
+/**
+* Check if browsing returned an error code.
+*
+* @param[in]   alb        Album browse object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_albumbrowse_error(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return the pointer to its album object
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Album object
+ */
+SP_LIBEXPORT(sp_album *) sp_albumbrowse_album(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return the pointer to its artist object
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Artist object
+ */
+SP_LIBEXPORT(sp_artist *) sp_albumbrowse_artist(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return number of copyright strings
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Number of copyright strings available, 0 if unknown
+ */
+SP_LIBEXPORT(int) sp_albumbrowse_num_copyrights(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return one of its copyright strings
+ *
+ * @param[in]   alb           Album browse object
+ * @param[in]   index         The index for the copyright string. Should be in the interval [0, sp_albumbrowse_num_copyrights() - 1]
+ *
+ * @return                    Copyright string in UTF-8 format, or NULL if the index is invalid.
+ *                            Returned string is valid as long as the album object stays allocated
+ *                            and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_albumbrowse_copyright(sp_albumbrowse *alb, int index);
+
+/**
+ * Given an album browse object, return number of tracks
+ *
+ * @param[in]   alb         Album browse object
+ *
+ * @return                  Number of tracks on album
+ */
+SP_LIBEXPORT(int) sp_albumbrowse_num_tracks(sp_albumbrowse *alb);
+
+/**
+ * Given an album browse object, return a pointer to one of its tracks
+ *
+ * @param[in]   alb        Album browse object
+ * @param[in]   index      The index for the track. Should be in the interval [0, sp_albumbrowse_num_tracks() - 1]
+ *
+ * @return                 A track.
+ *
+ * @see track
+ */
+SP_LIBEXPORT(sp_track *) sp_albumbrowse_track(sp_albumbrowse *alb, int index);
+
+/**
+ * Given an album browse object, return its review
+ *
+ * @param[in]   alb        Album browse object
+ *
+ * @return                 Review string in UTF-8 format.
+ *                         Returned string is valid as long as the album object stays allocated
+ *                         and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_albumbrowse_review(sp_albumbrowse *alb);
+
+/**
+ * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request
+ *
+ * @param[in] alb         Album browse object
+ *
+ * @return                -1 if the request was served from the local cache
+ *                        If the result is not yet loaded the return value is undefined
+ */
+SP_LIBEXPORT(int) sp_albumbrowse_backend_request_duration(sp_albumbrowse *alb);
+
+
+/**
+ * Increase the reference count of an album browse result
+ *
+ * @param[in]   alb       The album browse result object
+ */
+SP_LIBEXPORT(void) sp_albumbrowse_add_ref(sp_albumbrowse *alb);
+
+/**
+ * Decrease the reference count of an album browse result
+ *
+ * @param[in]   alb       The album browse result object
+ */
+SP_LIBEXPORT(void) sp_albumbrowse_release(sp_albumbrowse *alb);
+
+/** @} */
+
+
+/**
+ * @defgroup artistbrowse Artist browsing
+ *
+ * Artist browsing initiates the fetching of information for a certain artist.
+ *
+ * @note   There is currently no built-in functionality available for getting the albums belonging
+ *         to an artist. For now, just iterate over all tracks and note the album to build a list of all albums.
+ *         This feature will be added in a future version of the library.
+ *
+ * @{
+ */
+
+/**
+ * The type of a callback used in sp_artistbrowse_create()
+ *
+ * When the callback is called, the metadata of all tracks belonging to it will have
+ * been loaded, so sp_track_is_loaded() will return non-zero. The same goes for the
+ * similar artist data.
+ *
+ * @param[in]   result          The same pointer returned by sp_artistbrowse_create()
+ * @param[in]   userdata        The opaque pointer given to sp_artistbrowse_create()
+ */
+typedef void SP_CALLCONV artistbrowse_complete_cb(sp_artistbrowse *result, void *userdata);
+
+/**
+ * Initiate a request for browsing an artist
+ *
+ * The user is responsible for freeing the returned artist browse using sp_artistbrowse_release(). This can be done in the callback.
+ *
+ * @param[in] session         Session object
+ * @param[in] artist          Artist to be browsed. The artist metadata does not have to be loaded
+ * @param[in] type            Type of data requested, see the sp_artistbrowse_type enum for details
+ * @param[in] callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.
+ * @param[in] userdata        Userdata passed to callback.
+ *
+ * @return                    Artist browse object
+ *
+ * @see ::artistbrowse_complete_cb
+ */
+SP_LIBEXPORT(sp_artistbrowse *) sp_artistbrowse_create(sp_session *session, sp_artist *artist, sp_artistbrowse_type type, artistbrowse_complete_cb *callback, void *userdata);
+
+/**
+ * Check if an artist browse request is completed
+ *
+ * @param[in]   arb        Artist browse object
+ *
+ * @return                 True if browsing is completed, false if not
+ */
+SP_LIBEXPORT(bool) sp_artistbrowse_is_loaded(sp_artistbrowse *arb);
+
+/**
+* Check if browsing returned an error code.
+*
+* @param[in]   arb        Artist browse object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_artistbrowse_error(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return a pointer to its artist object
+ *
+ * @param[in]   arb        Artist browse object
+ *
+ * @return                 Artist object
+ */
+SP_LIBEXPORT(sp_artist *) sp_artistbrowse_artist(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return number of portraits available
+ *
+ * @param[in]   arb        Artist browse object
+ *
+ * @return                 Number of portraits for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_portraits(sp_artistbrowse *arb);
+
+/**
+ * Return image ID representing a portrait of the artist
+ *
+ * @param[in] arb             Artist object
+ * @param[in] index           The index of the portrait. Should be in the interval [0, sp_artistbrowse_num_portraits() - 1]
+ *
+ * @return                    ID byte sequence that can be passed to sp_image_create()
+ *
+ * @see sp_image_create
+ */
+SP_LIBEXPORT(const s_byte *) sp_artistbrowse_portrait(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return number of tracks
+ *
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Number of tracks for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_tracks(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return one of its tracks
+ *
+ * @param[in] arb             Album browse object
+ * @param[in] index           The index for the track. Should be in the interval [0, sp_artistbrowse_num_tracks() - 1]
+ *
+ * @return                    A track object, or NULL if the index is out of range.
+ *
+ * @see track
+ */
+SP_LIBEXPORT(sp_track *) sp_artistbrowse_track(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return number of albums
+ *
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Number of albums for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_albums(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return one of its albums
+ *
+ * @param[in] arb             Album browse object
+ * @param[in] index           The index for the album. Should be in the interval [0, sp_artistbrowse_num_albums() - 1]
+ *
+ * @return                    A album object, or NULL if the index is out of range.
+ *
+ * @see album
+ */
+SP_LIBEXPORT(sp_album *) sp_artistbrowse_album(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return number of similar artists
+ *
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Number of similar artists for given artist
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_num_similar_artists(sp_artistbrowse *arb);
+
+/**
+ * Given an artist browse object, return a similar artist by index
+ *
+ * @param[in] arb             Album browse object
+ * @param[in] index           The index for the artist. Should be in the interval [0, sp_artistbrowse_num_similar_artists() - 1]
+ *
+ * @return                    A pointer to an artist object.
+ *
+ * @see artist
+ */
+SP_LIBEXPORT(sp_artist *) sp_artistbrowse_similar_artist(sp_artistbrowse *arb, int index);
+
+/**
+ * Given an artist browse object, return the artists biography
+ *
+ * @note This function must be called from the same thread that did sp_session_create()
+ * @param[in] arb             Artist browse object
+ *
+ * @return                    Biography string in UTF-8 format.
+ *                            Returned string is valid as long as the album object stays allocated
+ *                            and no longer than the next call to sp_session_process_events()
+ */
+SP_LIBEXPORT(const char *) sp_artistbrowse_biography(sp_artistbrowse *arb);
+
+/**
+ * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request
+ *
+ * @param[in] arb         Artist browse object
+ *
+ * @return                -1 if the request was served from the local cache
+ *                        If the result is not yet loaded the return value is undefined
+ */
+SP_LIBEXPORT(int) sp_artistbrowse_backend_request_duration(sp_artistbrowse *arb);
+
+
+/**
+ * Increase the reference count of an artist browse result
+ *
+ * @param[in]   arb       The artist browse result object
+ */
+SP_LIBEXPORT(void) sp_artistbrowse_add_ref(sp_artistbrowse *arb);
+
+/**
+ * Decrease the reference count of an artist browse result
+ *
+ * @param[in]   arb       The artist browse result object
+ */
+SP_LIBEXPORT(void) sp_artistbrowse_release(sp_artistbrowse *arb);
+
+/** @} */
+
+
+
+/**
+ * @defgroup image Image handling
+ * @{
+ */
+
+/**
+ * Image format
+ */
+typedef enum {
+	SP_IMAGE_FORMAT_UNKNOWN = -1, ///< Unknown image format
+	SP_IMAGE_FORMAT_JPEG   = 0,   ///< JPEG image
+} sp_imageformat;
+
+/**
+ * The type of a callback used to notify the application that an image
+ * is done loading.
+ */
+typedef void SP_CALLCONV image_loaded_cb(sp_image *image, void *userdata);
+
+/**
+ * Create an image object
+ *
+ * @param[in]  session    Session
+ * @param[in]  image_id   Spotify image ID
+ *
+ * @return                Pointer to an image object. To free the object, use
+ *                        sp_image_release()
+ *
+ * @see sp_album_cover
+ * @see sp_artistbrowse_portrait
+ */
+SP_LIBEXPORT(sp_image *) sp_image_create(sp_session *session, const s_byte image_id[20]);
+
+/**
+ * Create an image object from a link
+ *
+ * @param[in]  session    Session
+ * @param[in]  l          Spotify link object. This must be of SP_LINKTYPE_IMAGE type
+ *
+ * @return                Pointer to an image object. To free the object, use
+ *                        sp_image_release()
+ *
+ * @see sp_image_create
+ */
+SP_LIBEXPORT(sp_image *) sp_image_create_from_link(sp_session *session, sp_link *l);
+
+/**
+ * Add a callback that will be invoked when the image is loaded
+ *
+ * If an image is loaded, and loading fails, the image will behave like an
+ * empty image.
+ *
+ * @param[in]  image      Image object
+ * @param[in]  callback   Callback that will be called when image has been
+ *                        fetched.
+ * @param[in]  userdata   Opaque pointer passed to \p callback
+ *
+ */
+SP_LIBEXPORT(void) sp_image_add_load_callback(sp_image *image, image_loaded_cb *callback, void *userdata);
+
+/**
+ * Remove an image load callback previously added with sp_image_add_load_callback()
+ *
+ * @param[in]  image      Image object
+ * @param[in]  callback   Callback that will not be called when image has been
+ *                        fetched.
+ * @param[in]  userdata   Opaque pointer passed to \p callback
+ *
+ */
+SP_LIBEXPORT(void) sp_image_remove_load_callback(sp_image *image, image_loaded_cb *callback, void *userdata);
+
+/**
+ * Check if an image is loaded. Before the image is loaded, the rest of the
+ * methods will behave as if the image is empty.
+ *
+ * @param[in]  image      Image object
+ *
+ * @return                True if image is loaded, false otherwise
+ */
+SP_LIBEXPORT(bool) sp_image_is_loaded(sp_image *image);
+
+/**
+* Check if image retrieval returned an error code.
+*
+* @param[in]   image      Image object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_image_error(sp_image *image);
+
+/**
+ * Get image format
+ *
+ * @param[in]  image      Image object
+ *
+ * @return                Image format as described by sp_imageformat
+ */
+SP_LIBEXPORT(sp_imageformat) sp_image_format(sp_image *image);
+
+/**
+* Get image data
+*
+* @param[in]  image      Image object
+* @param[out] data_size  Size of raw image data
+*
+* @return                Pointer to raw image data
+*/
+
+SP_LIBEXPORT(const void *) sp_image_data(sp_image *image, size_t *data_size);
+
+/**
+ * Get image ID
+ *
+ * @param[in]  image      Image object
+ *
+ * @return                Image ID
+ */
+SP_LIBEXPORT(const s_byte *) sp_image_image_id(sp_image *image);
+
+
+/**
+ * Increase the reference count of an image
+ *
+ * @param[in]   image     The image object
+ */
+SP_LIBEXPORT(void) sp_image_add_ref(sp_image *image);
+
+/**
+ * Decrease the reference count of an image
+ *
+ * @param[in]   image     The image object
+ */
+SP_LIBEXPORT(void) sp_image_release(sp_image *image);
+
+/** @} */
+
+
+
+
+/**
+ * @defgroup search Search subsystem
+ * @{
+ */
+
+/**
+ * List of genres for radio query. Multiple genres can be combined by OR:ing the genres together
+ */
+typedef enum sp_radio_genre {
+  SP_RADIO_GENRE_ALT_POP_ROCK = 0x1,
+  SP_RADIO_GENRE_BLUES        = 0x2,
+  SP_RADIO_GENRE_COUNTRY      = 0x4,
+  SP_RADIO_GENRE_DISCO        = 0x8,
+  SP_RADIO_GENRE_FUNK         = 0x10,
+  SP_RADIO_GENRE_HARD_ROCK    = 0x20,
+  SP_RADIO_GENRE_HEAVY_METAL  = 0x40,
+  SP_RADIO_GENRE_RAP          = 0x80,
+  SP_RADIO_GENRE_HOUSE        = 0x100,
+  SP_RADIO_GENRE_JAZZ         = 0x200,
+  SP_RADIO_GENRE_NEW_WAVE     = 0x400,
+  SP_RADIO_GENRE_RNB          = 0x800,
+  SP_RADIO_GENRE_POP          = 0x1000,
+  SP_RADIO_GENRE_PUNK         = 0x2000,
+  SP_RADIO_GENRE_REGGAE       = 0x4000,
+  SP_RADIO_GENRE_POP_ROCK     = 0x8000,
+  SP_RADIO_GENRE_SOUL         = 0x10000,
+  SP_RADIO_GENRE_TECHNO       = 0x20000,
+} sp_radio_genre;
+
+/**
+ * The type of a callback used in sp_search_create()
+ *
+ * When this callback is called, the sp_track_is_loaded(), sp_album_is_loaded(),
+ * and sp_artist_is_loaded() functions will return non-zero for the objects
+ * contained in the search result.
+ *
+ * @param[in]   result          The same pointer returned by sp_search_create()
+ * @param[in]   userdata        The opaque pointer given to sp_search_create()
+ */
+typedef void SP_CALLCONV search_complete_cb(sp_search *result, void *userdata);
+
+/**
+ * Create a search object from the given query
+ *
+ * @param[in]  session    Session
+ * @param[in]  query      Query search string, e.g. 'The Rolling Stones' or 'album:"The Black Album"'
+ * @param[in]  track_offset     The offset among the tracks of the result
+ * @param[in]  track_count      The number of tracks to ask for
+ * @param[in]  album_offset     The offset among the albums of the result
+ * @param[in]  album_count      The number of albums to ask for
+ * @param[in]  artist_offset    The offset among the artists of the result
+ * @param[in]  artist_count      The number of artists to ask for
+ * @param[in]  callback   Callback that will be called once the search operation is complete. Pass NULL if you are not interested in this event.
+ * @param[in]  userdata   Opaque pointer passed to \p callback
+ *
+ * @return                Pointer to a search object. To free the object, use sp_search_release()
+ */
+SP_LIBEXPORT(sp_search *) sp_search_create(sp_session *session, const char *query, int track_offset, int track_count, int album_offset, int album_count, int artist_offset, int artist_count, search_complete_cb *callback, void *userdata);
+
+/**
+ * Create a search object from the radio channel
+ *
+ * @param[in]  session          Session
+ * @param[in]  from_year        Include tracks starting from this year
+ * @param[in]  to_year          Include tracks up to this year
+ * @param[in]  genres           Bitmask of genres to include
+ * @param[in]  callback         Callback that will be called once the search operation is complete. Pass NULL if you are not interested in this event.
+ * @param[in]  userdata         Opaque pointer passed to \p callback
+ *
+ * @return                      Pointer to a search object. To free the object, use sp_search_release()
+ */
+SP_LIBEXPORT(sp_search *) sp_radio_search_create(sp_session *session, unsigned int from_year, unsigned int to_year, sp_radio_genre genres, search_complete_cb *callback, void *userdata);
+
+
+/**
+ * Get load status for the specified search. Before it is loaded, it will behave as an empty search result.
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              True if search is loaded, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_search_is_loaded(sp_search *search);
+
+/**
+* Check if search returned an error code.
+*
+* @param[in]   search     Search object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_search_error(sp_search *search);
+
+/**
+ * Get the number of tracks for the specified search
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              The number of tracks for the specified search
+ */
+SP_LIBEXPORT(int) sp_search_num_tracks(sp_search *search);
+
+/**
+ * Return the track at the given index in the given search object
+ *
+ * @param[in]  search     Search object
+ * @param[in]  index      Index of the wanted track. Should be in the interval [0, sp_search_num_tracks() - 1]
+ *
+ * @return                The track at the given index in the given search object
+ */
+SP_LIBEXPORT(sp_track *) sp_search_track(sp_search *search, int index);
+
+/**
+ * Get the number of albums for the specified search
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              The number of albums for the specified search
+ */
+SP_LIBEXPORT(int) sp_search_num_albums(sp_search *search);
+
+/**
+ * Return the album at the given index in the given search object
+ *
+ * @param[in]  search     Search object
+ * @param[in]  index      Index of the wanted album. Should be in the interval [0, sp_search_num_albums() - 1]
+ *
+ * @return                The album at the given index in the given search object
+ */
+SP_LIBEXPORT(sp_album *) sp_search_album(sp_search *search, int index);
+
+/**
+ * Get the number of artists for the specified search
+ *
+ * @param[in]  search   Search object
+ *
+ * @return              The number of artists for the specified search
+ */
+SP_LIBEXPORT(int) sp_search_num_artists(sp_search *search);
+
+/**
+ * Return the artist at the given index in the given search object
+ *
+ * @param[in]  search     Search object
+ * @param[in]  index      Index of the wanted artist. Should be in the interval [0, sp_search_num_artists() - 1]
+ *
+ * @return                The artist at the given index in the given search object
+ */
+SP_LIBEXPORT(sp_artist *) sp_search_artist(sp_search *search, int index);
+
+/**
+ * Return the search query for the given search object
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The search query for the given search object
+ */
+SP_LIBEXPORT(const char *) sp_search_query(sp_search *search);
+
+/**
+ * Return the "Did you mean" query for the given search object
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The "Did you mean" query for the given search object, or the empty string if no such info is available
+ */
+SP_LIBEXPORT(const char *) sp_search_did_you_mean(sp_search *search);
+
+/**
+ * Return the total number of tracks for the search query - regardless of the interval requested at creation.
+ * If this value is larger than the interval specified at creation of the search object, more search results are available.
+ * To fetch these, create a new search object with a new interval.
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The total number of tracks matching the original query
+ */
+SP_LIBEXPORT(int) sp_search_total_tracks(sp_search *search);
+
+/**
+ * Return the total number of albums for the search query - regardless of the interval requested at creation.
+ * If this value is larger than the interval specified at creation of the search object, more search results are available.
+ * To fetch these, create a new search object with a new interval.
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The total number of albums matching the original query
+ */
+SP_LIBEXPORT(int) sp_search_total_albums(sp_search *search);
+
+/**
+ * Return the total number of artists for the search query - regardless of the interval requested at creation.
+ * If this value is larger than the interval specified at creation of the search object, more search results are available.
+ * To fetch these, create a new search object with a new interval.
+ *
+ * @param[in]  search     Search object
+ *
+ * @return                The total number of artists matching the original query
+ */
+SP_LIBEXPORT(int) sp_search_total_artists(sp_search *search);
+
+/**
+ * Increase the reference count of a search result
+ *
+ * @param[in]   search    The search result object
+ */
+SP_LIBEXPORT(void) sp_search_add_ref(sp_search *search);
+
+/**
+ * Decrease the reference count of a search result
+ *
+ * @param[in]   search    The search result object
+ */
+SP_LIBEXPORT(void) sp_search_release(sp_search *search);
+
+/** @} */
+
+
+
+/**
+ * @defgroup playlist Playlist subsystem
+ *
+ * The playlist subsystem handles playlists and playlist containers (list of playlists).
+ *
+ * The playlist container functions are always valid, but your playlists are not
+ * guaranteed to be loaded until the sp_session_callbacks#logged_in callback has
+ * been issued.
+ *
+ * @{
+ */
+
+/**
+ * Playlist callbacks
+ *
+ * Used to get notifications when playlists are updated.
+ * If some callbacks should not be of interest, set them to NULL.
+ */
+typedef struct sp_playlist_callbacks {
+
+	/**
+	 * Called when one or more tracks have been added to a playlist
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  tracks     Array of pointers to track objects
+	 * @param[in]  num_tracks Number of entries in \p tracks
+	 * @param[in]  position   Position in the playlist for the first track.
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *tracks_added)(sp_playlist *pl, sp_track * const *tracks, int num_tracks, int position, void *userdata);
+
+	/**
+	 * Called when one or more tracks have been removed from a playlist
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  tracks     Array of positions representing the tracks that were removed
+	 * @param[in]  num_tracks Number of entries in \p tracks
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *tracks_removed)(sp_playlist *pl, const int *tracks, int num_tracks, void *userdata);
+
+	/**
+	 * Called when one or more tracks have been moved within a playlist
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  tracks     Array of positions representing the tracks that were moved
+	 * @param[in]  num_tracks Number of entries in \p tracks
+	 * @param[in]  position   New position in the playlist for the first track.
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *tracks_moved)(sp_playlist *pl, const int *tracks, int num_tracks, int new_position, void *userdata);
+
+	/**
+	 * Called when a playlist has been renamed. sp_playlist_name() can be used to find out the new name
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_renamed)(sp_playlist *pl, void *userdata);
+
+	/**
+	 * Called when state changed for a playlist.
+	 *
+	 * There are three states that trigger this callback:
+	 * - Collaboration for this playlist has been turned on or off
+	 * - The playlist started having pending changes, or all pending changes have now been committed
+	 * - The playlist started loading, or finished loading
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 * @sa sp_playlist_is_collaborative
+	 * @sa sp_playlist_has_pending_changes
+	 * @sa sp_playlist_is_loaded
+	 */
+	void (SP_CALLCONV *playlist_state_changed)(sp_playlist *pl, void *userdata);
+
+	/**
+	 * Called when a playlist is updating or is done updating
+	 *
+	 * This is called before and after a series of changes are applied to the
+	 * playlist. It allows e.g. the user interface to defer updating until the
+	 * entire operation is complete.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  done       True iff the update is completed
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_update_in_progress)(sp_playlist *pl, bool done, void *userdata);
+
+	/**
+	 * Called when metadata for one or more tracks in a playlist has been updated.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_metadata_updated)(sp_playlist *pl, void *userdata);
+
+	/**
+	 * Called when create time and/or creator for a playlist entry changes
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  position   Position in playlist
+	 * @param[in]  user       User object
+	 * @param[in]  time       When entry was created, seconds since the unix epoch.
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *track_created_changed)(sp_playlist *pl, int position, sp_user *user, int when, void *userdata);
+
+	/**
+	 * Called when seen attribute for a playlist entry changes.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  position   Position in playlist
+	 * @param[in]  seen       Set if entry it marked as seen
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *track_seen_changed)(sp_playlist *pl, int position, bool seen, void *userdata);
+
+	/**
+	 * Called when playlist description has changed
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  desc       New description
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *description_changed)(sp_playlist *pl, const char *desc, void *userdata);
+
+
+	/**
+	 * Called when playlist image has changed
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  image      New image
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *image_changed)(sp_playlist *pl, const s_byte *image, void *userdata);
+
+
+	/**
+	 * Called when message attribute for a playlist entry changes.
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  position   Position in playlist
+	 * @param[in]  message    UTF-8 encoded message
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *track_message_changed)(sp_playlist *pl, int position, const char *message, void *userdata);
+
+
+	/**
+	 * Called when playlist subscribers changes (count or list of names)
+	 *
+	 * @param[in]  pl         Playlist object
+	 * @param[in]  userdata   Userdata passed to sp_playlist_add_callbacks()
+	 */
+	void (SP_CALLCONV *subscribers_changed)(sp_playlist *pl, void *userdata);
+
+} sp_playlist_callbacks;
+
+
+/**
+ * Get load status for the specified playlist. If it's false, you have to wait until
+ * playlist_state_changed happens, and check again if is_loaded has changed
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                True if playlist is loaded, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_playlist_is_loaded(sp_playlist *playlist);
+
+/**
+ * Register interest in the given playlist
+ *
+ * Here is a snippet from \c jukebox.c:
+ * @dontinclude jukebox.c
+ * @skipline sp_playlist_add_callbacks
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  callbacks  Callbacks, see #sp_playlist_callbacks
+ * @param[in]  userdata   Userdata to be passed to callbacks
+ * @sa sp_playlist_remove_callbacks
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_add_callbacks(sp_playlist *playlist, sp_playlist_callbacks *callbacks, void *userdata);
+
+/**
+ * Unregister interest in the given playlist
+ *
+ * The combination of (\p callbacks, \p userdata) is used to find the entry to be removed
+ *
+ * Here is a snippet from \c jukebox.c:
+ * @dontinclude jukebox.c
+ * @skipline sp_playlist_remove_callbacks
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  callbacks  Callbacks, see #sp_playlist_callbacks
+ * @param[in]  userdata   Userdata to be passed to callbacks
+ * @sa sp_playlist_add_callbacks
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_remove_callbacks(sp_playlist *playlist, sp_playlist_callbacks *callbacks, void *userdata);
+
+/**
+ * Return number of tracks in the given playlist
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                The number of tracks in the playlist
+ */
+SP_LIBEXPORT(int) sp_playlist_num_tracks(sp_playlist *playlist);
+
+/**
+ * Return the track at the given index in a playlist
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                The track at the given index
+ */
+SP_LIBEXPORT(sp_track *) sp_playlist_track(sp_playlist *playlist, int index);
+
+/**
+ * Return when the given index was added to the playlist
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                Time, Seconds since unix epoch.
+ */
+SP_LIBEXPORT(int) sp_playlist_track_create_time(sp_playlist *playlist, int index);
+
+/**
+ * Return user that added the given index in the playlist
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                User object
+ */
+SP_LIBEXPORT(sp_user *) sp_playlist_track_creator(sp_playlist *playlist, int index);
+
+/**
+ * Return if a playlist entry is marked as seen or not
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                Seen state
+ */
+SP_LIBEXPORT(bool) sp_playlist_track_seen(sp_playlist *playlist, int index);
+
+/**
+ * Set seen status of a playlist entry
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ * @param[in]  seen       Seen status to be set
+ *
+ * @return     error     One of the following errors, from ::sp_error
+ *                       SP_ERROR_OK
+ *                       SP_ERROR_INDEX_OUT_OF_RANGE
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_track_set_seen(sp_playlist *playlist, int index, bool seen);
+
+/**
+ * Return a message attached to a playlist item. Typically used on inbox.
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  index      Index into playlist container. Should be in the interval [0, sp_playlist_num_tracks() - 1]
+ *
+ * @return                UTF-8 encoded message, or NULL if no message is present
+ */
+SP_LIBEXPORT(const char *) sp_playlist_track_message(sp_playlist *playlist, int index);
+
+/**
+ * Return name of given playlist
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                The name of the given playlist
+ */
+SP_LIBEXPORT(const char *) sp_playlist_name(sp_playlist *playlist);
+
+/**
+ * Rename the given playlist
+ * The name must not consist of only spaces and it must be shorter than 256 characters.
+ *
+ * @param[in]  playlist   Playlist object
+ * @param[in]  new_name   New name for playlist
+ *
+ * @return                One of the following errors, from ::sp_error
+ *                        SP_ERROR_OK
+ *                        SP_ERROR_INVALID_INDATA
+ *                        SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_rename(sp_playlist *playlist, const char *new_name);
+
+/**
+ * Return a pointer to the user for the given playlist
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                User object
+ */
+SP_LIBEXPORT(sp_user *) sp_playlist_owner(sp_playlist *playlist);
+
+/**
+ * Return collaborative status for a playlist.
+ *
+ * A playlist in collaborative state can be modifed by all users, not only the user owning the list
+ *
+ * @param[in]  playlist   Playlist object
+ *
+ * @return                true if playlist is collaborative, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_playlist_is_collaborative(sp_playlist *playlist);
+
+/**
+ * Set collaborative status for a playlist.
+ *
+ * A playlist in collaborative state can be modified by all users, not only the user owning the list
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  collaborative  True or false
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_set_collaborative(sp_playlist *playlist, bool collaborative);
+
+/**
+ * Set autolinking state for a playlist.
+ *
+ * If a playlist is autolinked, unplayable tracks will be made playable
+ * by linking them to other Spotify tracks, where possible.
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  link           True or false
+ *
+ */
+SP_LIBEXPORT(void) sp_playlist_set_autolink_tracks(sp_playlist *playlist, bool link);
+
+
+/**
+ * Get description for a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return                    Playlist description or NULL if unset
+ *
+ */
+SP_LIBEXPORT(const char *) sp_playlist_get_description(sp_playlist *playlist);
+
+
+/**
+ * Get description for a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[out] image          20 byte image id
+
+ * @return                    TRUE if playlist has an image, FALSE if not
+ *
+ */
+SP_LIBEXPORT(bool) sp_playlist_get_image(sp_playlist *playlist, s_byte image[20]);
+
+
+/**
+ * Check if a playlist has pending changes
+ *
+ * Pending changes are local changes that have not yet been acknowledged by the server.
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return                    A flag representing if there are pending changes or not
+ */
+SP_LIBEXPORT(bool) sp_playlist_has_pending_changes(sp_playlist *playlist);
+
+/**
+ * Add tracks to a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  tracks         Array of pointer to tracks.
+ * @param[in]  num_tracks     Length of \p tracks array
+ * @param[in]  position       Start position in playlist where to insert the tracks
+ * @param[in]  session        Your session object
+ *
+ * @return                One of the following errors, from ::sp_error
+ *                        SP_ERROR_OK
+ *                        SP_ERROR_INVALID_INDATA - position is > current playlist length
+ *                        SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_add_tracks(sp_playlist *playlist, sp_track *const*tracks, int num_tracks, int position, sp_session *session);
+
+/**
+ * Remove tracks from a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  tracks         Array of pointer to track indices.
+ *                            A certain track index should be present at most once, e.g. [0, 1, 2] is valid indata,
+ *                            whereas [0, 1, 1] is invalid.
+ * @param[in]  num_tracks     Length of \p tracks array
+ *
+ * @return                    One of the following errors, from ::sp_error
+ *                            SP_ERROR_OK
+ *                            SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_remove_tracks(sp_playlist *playlist, const int *tracks, int num_tracks);
+
+/**
+ * Move tracks in playlist
+ *
+ * @param[in]  playlist       Playlist object
+ * @param[in]  tracks         Array of pointer to track indices to be moved.
+ *                            A certain track index should be present at most once, e.g. [0, 1, 2] is valid indata,
+ *                            whereas [0, 1, 1] is invalid.
+ * @param[in]  num_tracks     Length of \p tracks array
+ * @param[in]  new_position   New position for tracks
+ *
+ * @return                    One of the following errors, from ::sp_error
+ *                            SP_ERROR_OK
+ *                            SP_ERROR_INVALID_INDATA - position is > current playlist length
+ *                            SP_ERROR_PERMISSION_DENIED
+ */
+SP_LIBEXPORT(sp_error) sp_playlist_reorder_tracks(sp_playlist *playlist, const int *tracks, int num_tracks, int new_position);
+
+
+/**
+ * Return number of subscribers for a given playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return     Number of subscribers
+ *
+ */
+SP_LIBEXPORT(unsigned int) sp_playlist_num_subscribers(sp_playlist *playlist);
+
+/**
+ * Return subscribers for a playlist
+ *
+ * @param[in]  playlist       Playlist object
+ *
+ * @return     sp_subscribers struct with array of canonical usernames.
+ *             This object should be free'd using sp_playlist_subscribers_free()
+ *
+ * @note       The count returned for this function may be less than those
+ *             returned by sp_playlist_num_subscribers(). Spotify does not
+ *             track each user subscribed to a playlist for playlist with
+ *             many (>500) subscribers.
+ */
+SP_LIBEXPORT(sp_subscribers *) sp_playlist_subscribers(sp_playlist *playlist);
+
+/**
+ * Free object returned from sp_playlist_subscribers()
+ *
+ * @param[in] subscribers   Subscribers object
+ */
+SP_LIBEXPORT(void) sp_playlist_subscribers_free(sp_subscribers *subscribers);
+
+/**
+ * Ask library to update the subscription count for a playlist
+ *
+ * When the subscription info has been fetched from the Spotify backend
+ * the playlist subscribers_changed() callback will be invoked.
+ * In that callback use sp_playlist_num_subscribers() and/or
+ * sp_playlist_subscribers() to get information about the subscribers.
+ * You can call those two functions anytime you want but the information
+ * might not be up to date in such cases
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ */
+SP_LIBEXPORT(void) sp_playlist_update_subscribers(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Return whether a playlist is loaded in RAM (as opposed to only
+ * stored on disk)
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ *
+ * @return True iff playlist is in RAM, False otherwise
+ *
+ * @note       When a playlist is no longer in RAM it will appear empty.
+ *             However, libspotify will retain information about the
+ *             list metadata  (owner, title, picture, etc) in RAM.
+ *             There is one caveat tough: If libspotify has never seen the
+ *             playlist before this metadata will also be unset.
+ *             In order for libspotify to get the metadata the playlist
+ *             needs to be loaded at least once.
+ *             In order words, if libspotify starts with an empty playlist
+ *             cache and the application has set 'initially_unload_playlists'
+ *             config parameter to True all playlists will be empty.
+ *             It will not be possible to generate URI's to the playlists
+ *             nor extract playlist title until the application calls
+ *             sp_playlist_set_in_ram(..., true). So an application
+ *             that needs to stay within a low memory profile would need to
+ *             cycle thru all new playlists in order to extract metadata.
+ *
+ *             The easiest way to detect this case is when
+ *             sp_playlist_is_in_ram() returns false and
+ *             sp_link_create_from_playlist() returns NULL
+ */
+SP_LIBEXPORT(bool) sp_playlist_is_in_ram(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Return whether a playlist is loaded in RAM (as opposed to only
+ * stored on disk)
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ * @param[in]  in_ram         Controls whether or not to keep the list in RAM
+ */
+SP_LIBEXPORT(void) sp_playlist_set_in_ram(sp_session *session, sp_playlist *playlist, bool in_ram);
+
+/**
+ * Load an already existing playlist without adding it to a playlistcontainer.
+ *
+ * @param[in]  session        Session object
+ * @param[in]  link           Link object referring to a playlist
+ *
+ * @return     A playlist. The reference is owned by the caller and should be released with sp_playlist_release()
+ *
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlist_create(sp_session *session, sp_link *link);
+
+/**
+ * Mark a playlist to be synchronized for offline playback.
+ * The playlist must be in the users playlistcontainer
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ * @param[in]  offline        True iff playlist should be offline, false otherwise
+ */
+SP_LIBEXPORT(void) sp_playlist_set_offline_mode(sp_session *session, sp_playlist *playlist, bool offline);
+
+/**
+ * Get offline status for a playlist
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ *
+ * @return sp_playlist_offline_status
+ *
+ * @see When in SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING mode the
+ *      sp_playlist_get_offline_download_completed() method can be used to query
+ *      progress of the download
+ */
+SP_LIBEXPORT(sp_playlist_offline_status) sp_playlist_get_offline_status(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Get download progress for an offline playlist
+ *
+ * @param[in]  session        Session object
+ * @param[in]  playlist       Playlist object
+ *
+ * @return Value from 0 - 100 that indicates amount of playlist that is downloaded
+ * or 0 if the playlist is not in the SP_PLAYLIST_OFFLINE_STATUS_DOWNLOADING mode.
+ *
+ * @see sp_playlist_offline_status()
+ */
+SP_LIBEXPORT(int) sp_playlist_get_offline_download_completed(sp_session *session, sp_playlist *playlist);
+
+/**
+ * Increase the reference count of a playlist
+ *
+ * @param[in]   playlist       The playlist object
+ */
+SP_LIBEXPORT(void) sp_playlist_add_ref(sp_playlist *playlist);
+
+/**
+ * Decrease the reference count of a playlist
+ *
+ * @param[in]   playlist       The playlist object
+ */
+SP_LIBEXPORT(void) sp_playlist_release(sp_playlist *playlist);
+
+
+/**
+ * Playlist container callbacks.
+ * If some callbacks should not be of interest, set them to NULL.
+ *
+ * @see sp_playlistcontainer_add_callbacks
+ * @see sp_playlistcontainer_remove_callbacks
+ */
+typedef struct sp_playlistcontainer_callbacks {
+	/**
+	 * Called when a new playlist has been added to the playlist container.
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  playlist   Playlist object.
+	 * @param[in]  position   Position in list
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_added)(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata);
+
+
+	/**
+	 * Called when a new playlist has been removed from playlist container
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  playlist   Playlist object.
+	 * @param[in]  position   Position in list
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_removed)(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata);
+
+
+	/**
+	 * Called when a playlist has been moved in the playlist container
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  playlist   Playlist object.
+	 * @param[in]  position   Previous position in playlist container list
+	 * @param[in]  new_position   New position in playlist container list
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *playlist_moved)(sp_playlistcontainer *pc, sp_playlist *playlist, int position, int new_position, void *userdata);
+
+	/**
+	 * Called when the playlist container is loaded
+	 *
+	 * @param[in]  pc         Playlist container
+	 * @param[in]  userdata   Userdata as set in sp_playlistcontainer_add_callbacks()
+	 */
+	void (SP_CALLCONV *container_loaded)(sp_playlistcontainer *pc, void *userdata);
+} sp_playlistcontainer_callbacks;
+
+
+/**
+ * Register interest in changes to a playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  callbacks Callbacks, see sp_playlistcontainer_callbacks
+ * @param[in]  userdata  Opaque value passed to callbacks.
+ *
+ * @note Every sp_playlistcontainer_add_callbacks() needs to be paired with a corresponding
+ *       sp_playlistcontainer_remove_callbacks() that is invoked before releasing the
+ *       last reference you own for the container. In other words, you must make sure
+ *       to have removed all the callbacks before the container gets destroyed.
+ *
+ * @sa sp_session_playlistcontainer()
+ * @sa sp_playlistcontainer_remove_callbacks
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_add_callbacks(sp_playlistcontainer *pc, sp_playlistcontainer_callbacks *callbacks, void *userdata);
+
+
+/**
+ * Unregister interest in changes to a playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  callbacks Callbacks, see sp_playlistcontainer_callbacks
+ * @param[in]  userdata  Opaque value passed to callbacks.
+ *
+ * @sa sp_session_playlistcontainer()
+ * @sa sp_playlistcontainer_add_callbacks
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_remove_callbacks(sp_playlistcontainer *pc, sp_playlistcontainer_callbacks *callbacks, void *userdata);
+
+/**
+ * Return the number of playlists in the given playlist container
+ *
+ * @param[in]  pc        Playlist container
+ *
+ * @return               Number of playlists, -1 if undefined
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(int) sp_playlistcontainer_num_playlists(sp_playlistcontainer *pc);
+
+/**
+ * Return true if the playlistcontainer is fully loaded
+ *
+ * @param[in]  pc        Playlist container
+ *
+ * @return               True if container is loaded
+ *
+ * @note The container_loaded callback will be invoked when this flips to true
+ */
+SP_LIBEXPORT(bool) sp_playlistcontainer_is_loaded(sp_playlistcontainer *pc);
+
+/**
+ * Return a pointer to the playlist at a specific index
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]
+ *
+ * @return               The playlist object
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlistcontainer_playlist(sp_playlistcontainer *pc, int index);
+
+/**
+ * Return the type of the playlist at a @a index
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]
+ *
+ * @return               Type of the playlist, @see sp_playlist_type
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_playlist_type) sp_playlistcontainer_playlist_type(sp_playlistcontainer *pc, int index);
+
+/**
+ * Return the folder name at @a index
+ *
+ * @param[in]  pc           Playlist container
+ * @param[in]  index        Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1].
+ *                          Index should point at a start-folder entry, otherwise the empty string is written to buffer.
+ * @param[in]  buffer       Pointer to char[] where to store folder name
+ * @param[in]  buffer_size  Size of array
+ *
+ * @return                  One of the following errors, from ::sp_error
+ *                          SP_ERROR_OK
+ *                          SP_ERROR_INDEX_OUT_OF_RANGE
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_playlist_folder_name(sp_playlistcontainer *pc, int index, char *buffer, int buffer_size);
+
+/**
+ * Return the folder id at @a index
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index in playlist container. Should be in the interval [0, sp_playlistcontainer_num_playlists() - 1]
+ *
+ * @return               The group ID of the folder. Returns 0 on index out of range, pc being NULL or indexed item not being a folder
+ *
+ * @sa sp_session_playlistcontainer()
+ */
+SP_LIBEXPORT(sp_uint64) sp_playlistcontainer_playlist_folder_id(sp_playlistcontainer *pc, int index);
+
+/**
+ * Add an empty playlist at the end of the playlist container.
+ * The name must not consist of only spaces and it must be shorter than 256 characters.
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  name      Name of new playlist
+ *
+ * @return               Pointer to the new playlist. Can be NULL if the operation fails.
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlistcontainer_add_new_playlist(sp_playlistcontainer *pc, const char *name);
+
+/**
+ * Add an existing playlist at the end of the given playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  link      Link object pointing to a playlist
+ *
+ * @return               Pointer to the new playlist. Will be NULL if the playlist already exists.
+ */
+SP_LIBEXPORT(sp_playlist *) sp_playlistcontainer_add_playlist(sp_playlistcontainer *pc, sp_link *link);
+
+/**
+ * Remove playlist at index from the given playlist container
+ *
+ * @param[in]  pc        Playlist container
+ * @param[in]  index     Index of playlist to be removed
+ *
+ * @return     error     One of the following errors, from ::sp_error
+ *                       SP_ERROR_OK
+ *                       SP_ERROR_INDEX_OUT_OF_RANGE
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_remove_playlist(sp_playlistcontainer *pc, int index);
+
+/**
+ * Move a playlist in the playlist container
+ *
+ * @param[in]  pc           Playlist container
+ * @param[in]  index        Index of playlist to be moved
+ * @param[in]  new_position New position for the playlist
+ * @param[in]  dry_run      Do not execute the move, only check if it possible
+
+ * @return     error        One of the following errors, from ::sp_error
+ *                          SP_ERROR_OK
+ *                          SP_ERROR_INDEX_OUT_OF_RANGE
+ *                          SP_ERROR_INVALID_INDATA - If trying to move a folder into itself
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_move_playlist(sp_playlistcontainer *pc, int index, int new_position, bool dry_run);
+
+
+/**
+ * Add a playlist folder
+ *
+ * @param[in]  pc           Playlist container
+ * @param[in]  index        Position of SP_PLAYLIST_TYPE_START_FOLDER entry
+ * @param[in]  name         Name of group
+
+ * @return     error        One of the following errors, from ::sp_error
+ *                          SP_ERROR_OK
+ *                          SP_ERROR_INDEX_OUT_OF_RANGE
+ *
+ * @note This operation will actually create two playlists. One of
+ * type SP_PLAYLIST_TYPE_START_FOLDER and immediately following a
+ * SP_PLAYLIST_TYPE_END_FOLDER one.
+ *
+ * To remove a playlist folder both of these must be deleted or the list
+ * will be left in an inconsistant state.
+ *
+ * There is no way to rename a playlist folder. Instead you need to remove
+ * the folder and recreate it again.
+ */
+SP_LIBEXPORT(sp_error) sp_playlistcontainer_add_folder(sp_playlistcontainer *pc, int index, const char *name);
+
+
+/**
+ * Return a pointer to the user object of the owner.
+ *
+ * @param[in]  pc   Playlist container.
+ * @return          The user object or NULL if unknown or none.
+ */
+SP_LIBEXPORT(sp_user *) sp_playlistcontainer_owner(sp_playlistcontainer *pc);
+
+
+/**
+ * Increase reference count on playlistconatiner object
+ *
+ * @param[in]  pc   Playlist container.
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_add_ref(sp_playlistcontainer *pc);
+
+/**
+ * Release reference count on playlistconatiner object
+ *
+ * @param[in]  pc   Playlist container.
+ */
+SP_LIBEXPORT(void) sp_playlistcontainer_release(sp_playlistcontainer *pc);
+
+/** @} */
+
+
+/**
+ * @defgroup user User handling
+ * @{
+ */
+
+
+/**
+ * User relation type
+ */
+typedef enum sp_relation_type {
+  SP_RELATION_TYPE_UNKNOWN = 0,          ///< Not yet known
+  SP_RELATION_TYPE_NONE = 1,             ///< No relation
+  SP_RELATION_TYPE_UNIDIRECTIONAL = 2,   ///< The currently logged in user is following this uer
+  SP_RELATION_TYPE_BIDIRECTIONAL = 3,    ///< Bidirectional friendship established
+} sp_relation_type;
+
+
+
+/**
+ * Get a pointer to a string representing the user's canonical username.
+ *
+ * @param[in]   user         The Spotify user whose canonical username you would like a string representation of
+ *
+ * @return                   A string representing the canonical username.
+ */
+SP_LIBEXPORT(const char *) sp_user_canonical_name(sp_user *user);
+
+/**
+ * Get a pointer to a string representing the user's displayable username.
+ * If there is no difference between the canonical username and the display name,
+ * or if the library does not know about the display name yet, the canonical username will
+ * be returned.
+ *
+ * @param[in]   user         The Spotify user whose displayable username you would like a string representation of
+ *
+ * @return                   A string
+ */
+SP_LIBEXPORT(const char *) sp_user_display_name(sp_user *user);
+
+/**
+ * Get load status for a user object. Before it is loaded, only the user's canonical username
+ * is known.
+ *
+ * @param[in]   user         Spotify user object
+ *
+ * @return                   True if user object is loaded, otherwise false
+ */
+SP_LIBEXPORT(bool) sp_user_is_loaded(sp_user *user);
+
+
+
+/**
+ * Increase the reference count of an user
+ *
+ * @param[in]   user       The user object
+ */
+SP_LIBEXPORT(void) sp_user_add_ref(sp_user *user);
+
+/**
+ * Decrease the reference count of an user
+ *
+ * @param[in]   user       The user object
+ */
+SP_LIBEXPORT(void) sp_user_release(sp_user *user);
+
+/** @} */
+
+
+/**
+ * @defgroup toplist Toplist handling
+ * @{
+ */
+
+/**
+ * Toplist types
+ */
+typedef enum {
+	SP_TOPLIST_TYPE_ARTISTS = 0, ///< Top artists
+	SP_TOPLIST_TYPE_ALBUMS  = 1, ///< Top albums
+	SP_TOPLIST_TYPE_TRACKS  = 2, ///< Top tracks
+} sp_toplisttype;
+
+
+/**
+ * Convenience macro to create a toplist region. Toplist regions are ISO 3166-1
+ * country codes (in uppercase) encoded in an integer. There are also some reserved
+ * codes used to denote non-country regions. See sp_toplistregion
+ *
+ * Example: SP_TOPLIST_REGION('S', 'E') for Sweden
+ */
+#define SP_TOPLIST_REGION(a, b) ((a) << 8 | (b))
+
+/**
+ * Special toplist regions
+ */
+typedef enum {
+	SP_TOPLIST_REGION_EVERYWHERE = 0, ///< Global toplist
+	SP_TOPLIST_REGION_USER = 1,       ///< Toplist for a given user
+} sp_toplistregion;
+
+
+/**
+ * The type of a callback used in sp_toplistbrowse_create()
+ *
+ * When the callback is called, the metadata of all tracks belonging to it will have
+ * been loaded, so sp_track_is_loaded() will return non-zero. The same goes for the
+ * similar toplist data.
+ *
+ * @param[in]   result          The same pointer returned by sp_toplistbrowse_create()
+ * @param[in]   userdata        The opaque pointer given to sp_toplistbrowse_create()
+ */
+typedef void SP_CALLCONV toplistbrowse_complete_cb(sp_toplistbrowse *result, void *userdata);
+
+/**
+ * Initiate a request for browsing an toplist
+ *
+ * The user is responsible for freeing the returned toplist browse using sp_toplistbrowse_release(). This can be done in the callback.
+ *
+ * @param[in]   session         Session object
+ * @param[in]   type            Type of toplist to be browsed. see the sp_toplisttype enum for possible values
+ * @param[in]   region          Region. see sp_toplistregion enum. Country specific regions are coded as two chars in an integer.
+ *                              Sweden would correspond to 'S' << 8 | 'E'
+ * @param[in]   username        If region is SP_TOPLIST_REGION_USER this specifies which user to get toplists for. NULL means the logged in user.
+ * @param[in]   callback        Callback to be invoked when browsing has been completed. Pass NULL if you are not interested in this event.
+ * @param[in]   userdata        Userdata passed to callback.
+ *
+ * @return                      Toplist browse object
+ *
+ * @see ::toplistbrowse_complete_cb
+ */
+SP_LIBEXPORT(sp_toplistbrowse *) sp_toplistbrowse_create(sp_session *session, sp_toplisttype type, sp_toplistregion region, const char *username, toplistbrowse_complete_cb *callback, void *userdata);
+
+
+/**
+ * Check if an toplist browse request is completed
+ *
+ * @param[in]   tlb        Toplist browse object
+ *
+ * @return                 True if browsing is completed, false if not
+ */
+SP_LIBEXPORT(bool) sp_toplistbrowse_is_loaded(sp_toplistbrowse *tlb);
+
+/**
+* Check if browsing returned an error code.
+*
+* @param[in]   tlb        Toplist browse object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_IS_LOADING
+*                         SP_ERROR_OTHER_PERMANENT
+*                         SP_ERROR_OTHER_TRANSIENT
+*/
+SP_LIBEXPORT(sp_error) sp_toplistbrowse_error(sp_toplistbrowse *tlb);
+
+
+
+/**
+ * Increase the reference count of an toplist browse result
+ *
+ * @param[in]   tlb       The toplist browse result object
+ */
+SP_LIBEXPORT(void) sp_toplistbrowse_add_ref(sp_toplistbrowse *tlb);
+
+/**
+ * Decrease the reference count of an toplist browse result
+ *
+ * @param[in]   tlb       The toplist browse result object
+ */
+SP_LIBEXPORT(void) sp_toplistbrowse_release(sp_toplistbrowse *tlb);
+
+/**
+ * Given an toplist browse object, return number of artists
+ *
+ * @param[in]   tlb         Toplist browse object
+ *
+ * @return                  Number of artists on toplist
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_num_artists(sp_toplistbrowse *tlb);
+
+/**
+ * Return the artist at the given index in the given toplist browse object
+ *
+ * @param[in]  tlb        Toplist object
+ * @param[in]  index      Index of the wanted artist. Should be in the interval [0, sp_toplistbrowse_num_artists() - 1]
+ *
+ * @return                The artist at the given index in the given toplist browse object
+ */
+SP_LIBEXPORT(sp_artist *) sp_toplistbrowse_artist(sp_toplistbrowse *tlb, int index);
+
+
+/**
+ * Given an toplist browse object, return number of albums
+ *
+ * @param[in]   tlb         Toplist browse object
+ *
+ * @return                  Number of albums on toplist
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_num_albums(sp_toplistbrowse *tlb);
+
+
+/**
+ * Return the album at the given index in the given toplist browse object
+ *
+ * @param[in]  tlb        Toplist object
+ * @param[in]  index      Index of the wanted album. Should be in the interval [0, sp_toplistbrowse_num_albums() - 1]
+ *
+ * @return                The album at the given index in the given toplist browse object
+ */
+SP_LIBEXPORT(sp_album *) sp_toplistbrowse_album(sp_toplistbrowse *tlb, int index);
+
+
+/**
+ * Given an toplist browse object, return number of tracks
+ *
+ * @param[in]   tlb         Toplist browse object
+ *
+ * @return                  Number of tracks on toplist
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_num_tracks(sp_toplistbrowse *tlb);
+
+
+/**
+ * Return the track at the given index in the given toplist browse object
+ *
+ * @param[in]  tlb        Toplist object
+ * @param[in]  index      Index of the wanted track. Should be in the interval [0, sp_toplistbrowse_num_tracks() - 1]
+ *
+ * @return                The track at the given index in the given toplist browse object
+ */
+SP_LIBEXPORT(sp_track *) sp_toplistbrowse_track(sp_toplistbrowse *tlb, int index);
+
+/**
+ * Return the time (in ms) that was spent waiting for the Spotify backend to serve the request
+ *
+ * @param[in]  tlb        Toplist object
+ *
+ * @return                -1 if the request was served from the local cache
+ *                        If the result is not yet loaded the return value is undefined
+ */
+SP_LIBEXPORT(int) sp_toplistbrowse_backend_request_duration(sp_toplistbrowse *tlb);
+
+
+/** @} */
+
+/**
+ * @defgroup inbox Inbox subsystem
+ * @{
+ */
+
+/**
+ * The type of a callback used in sp_inbox_post()
+ *
+ * When this callback is called, the sp_track_is_loaded(), sp_album_is_loaded(),
+ * and sp_artist_is_loaded() functions will return non-zero for the objects
+ * contained in the search result.
+ *
+ * @param[in]   result          The same pointer returned by sp_search_create()
+ * @param[in]   userdata        The opaque pointer given to sp_search_create()
+ */
+typedef void SP_CALLCONV inboxpost_complete_cb(sp_inbox *result, void *userdata);
+
+/**
+ * Add to inbox
+ *
+ * @param[in]  session    Session object
+ * @param[in]  user       Canonical username of recipient
+ * @param[in]  tracks     Array of tracks to post
+ * @param[in]  num_tracks Number of tracks in \p tracks
+ * @param[in]  message    Message to attach to tracks. UTF-8
+ * @param[in]  callback   Callback to be invoked when the request has completed
+ * @param[in]  userdata   Userdata passed to callback
+ *
+ * @return                sp_inbox object if the request has been sent, NULL if request failed to initialize
+ */
+SP_LIBEXPORT(sp_inbox *) sp_inbox_post_tracks(sp_session *session, const char *user, sp_track * const *tracks, int num_tracks, const char *message, inboxpost_complete_cb *callback, void *userdata);
+
+
+/**
+* Check if inbox operation returned an error code.
+*
+* @param[in]   inbox      Inbox object
+*
+* @return                 One of the following errors, from ::sp_error
+*                         SP_ERROR_OK
+*                         SP_ERROR_OTHER_TRANSIENT
+*                         SP_ERROR_PERMISSION_DENIED
+*                         SP_ERROR_INVALID_INDATA
+*                         SP_ERROR_INBOX_IS_FULL
+*                         SP_ERROR_NO_SUCH_USER
+*                         SP_ERROR_OTHER_PERMANENT
+*/
+SP_LIBEXPORT(sp_error) sp_inbox_error(sp_inbox *inbox);
+
+/**
+ * Increase the reference count of a inbox result
+ *
+ * @param[in]   inbox    The inbox result object
+ */
+SP_LIBEXPORT(void) sp_inbox_add_ref(sp_inbox *inbox);
+
+/**
+ * Decrease the reference count of a inbox result
+ *
+ * @param[in]   inbox    The inbox result object
+ */
+SP_LIBEXPORT(void) sp_inbox_release(sp_inbox *inbox);
+
+/** @} */
+
+/**
+ * Return the libspotify build ID
+ *
+ * This might be useful to have available for display somewhere in your
+ * user interface.
+ */
+SP_LIBEXPORT(const char *) sp_build_id(void);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PUBLIC_API_H */
+/**
+ * @example browse.c
+ *
+ * The browse.c example shows how you can use the album, artist, and browse functions.
+ * The example also include some rudimentary playlist browsing.
+ * It is part of the spshell program
+ */
+/**
+ * @example search.c
+ *
+ * The search.c example shows how you can use search functions.
+ * It is part of the spshell program
+ */
+/**
+ * @example toplist.c
+ *
+ * The toplist.c example shows how you can use toplist functions.
+ * It is part of the spshell program
+ */
+/**
+ * @example jukebox.c
+ *
+ * The jukebox.c example shows how you can use playback and playlist functions.
+ */
diff --git a/lib/libspotify/libspotify.lib b/lib/libspotify/libspotify.lib
new file mode 100644
index 0000000..f2a96d6
Binary files /dev/null and b/lib/libspotify/libspotify.lib differ
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 2193cfe..7803d7f 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -18,6 +18,9 @@
  *
  */
 
+//spotify
+#include "music/spotyXBMC/Addon.music.spotify.h"
+
 #include "network/Network.h"
 #include "threads/SystemClock.h"
 #include "system.h"
@@ -1293,7 +1296,7 @@ bool CApplication::Initialize()
 
     g_windowManager.Add(new CGUIDialogPeripheralManager);
     g_windowManager.Add(new CGUIDialogPeripheralSettings);
-    
+
     g_windowManager.Add(new CGUIDialogMediaFilter);
 
     g_windowManager.Add(new CGUIWindowMusicPlayList);
@@ -1384,6 +1387,9 @@ bool CApplication::Initialize()
     ADDON::CAddonMgr::Get().StartServices(false);
   }
 
+  //spotify
+  g_spotify = new Addon_music_spotify();
+
   g_sysinfo.Refresh();
 
   CLog::Log(LOGINFO, "removing tempfiles");
@@ -1881,16 +1887,16 @@ void CApplication::ReloadSkin()
   m_skinReloading = false;
   CGUIMessage msg(GUI_MSG_LOAD_SKIN, -1, g_windowManager.GetActiveWindow());
   g_windowManager.SendMessage(msg);
-  
+
   // Reload the skin, restoring the previously focused control.  We need this as
   // the window unload will reset all control states.
   int iCtrlID = -1;
   CGUIWindow* pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
   if (pWindow)
     iCtrlID = pWindow->GetFocusedControlID();
-  
+
   g_application.LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
- 
+
   if (iCtrlID != -1)
   {
     pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
@@ -3328,6 +3334,10 @@ bool CApplication::Cleanup()
 {
   try
   {
+    //spotify
+    if (g_spotify)
+      g_spotify->enable(false);
+      //delete g_spotify;
     g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST);
     g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST_EDITOR);
     g_windowManager.Delete(WINDOW_MUSIC_FILES);
@@ -3474,7 +3484,7 @@ bool CApplication::Cleanup()
 #ifdef HAS_DVD_DRIVE
     CLibcdio::ReleaseInstance();
 #endif
-#endif 
+#endif
 #if defined(TARGET_ANDROID)
     // enable for all platforms once it's safe
     g_sectionLoader.UnloadAll();
@@ -4080,7 +4090,7 @@ bool CApplication::PlayFile(const CFileItem& item, bool bRestart)
     if ( !(m_eCurrentPlayer == eNewCore && (m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer  == EPC_PAPLAYER
 #if defined(HAS_OMXPLAYER)
             || m_eCurrentPlayer == EPC_OMXPLAYER
-#endif            
+#endif
             )) )
     {
       delete m_pPlayer;
@@ -4815,7 +4825,7 @@ bool CApplication::OnMessage(CGUIMessage& message)
 
       // Update our infoManager with the new details etc.
       if (m_nextPlaylistItem >= 0)
-      { 
+      {
         // playing an item which is not in the list - player might be stopped already
         // so do nothing
         if (playList.size() <= m_nextPlaylistItem)
diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index 2b69129..1d49490 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -1179,6 +1179,16 @@ bool CFileItem::IsRemovable() const
   return IsOnDVD() || IsCDDA() || m_iDriveType == CMediaSource::SOURCE_TYPE_REMOVABLE;
 }
 
+bool CFileItem::IsSpotify() const
+{
+  if (URIUtils::GetExtension(m_strPath).Equals(".spotify", false))
+    return true;
+  CStdString extension = m_strPath.Right(m_strPath.GetLength() - m_strPath.Find('.') - 1);
+  if (extension.Left(12) == "spotifyradio")
+    return true;
+  return false;
+}
+
 bool CFileItem::IsReadOnly() const
 {
   if (IsParentFolder()) return true;
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index c51a73f..dd3cb15 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -158,6 +158,7 @@ public:
   bool IsParentFolder() const;
   bool IsFileFolder() const;
   bool IsRemovable() const;
+  bool IsSpotify() const;
   bool IsTuxBox() const;
   bool IsMythTV() const;
   bool IsHDHomeRun() const;
diff --git a/xbmc/GUIInfoManager.cpp b/xbmc/GUIInfoManager.cpp
index a4098e0..c79bbbe 100644
--- a/xbmc/GUIInfoManager.cpp
+++ b/xbmc/GUIInfoManager.cpp
@@ -5287,7 +5287,9 @@ bool CGUIInfoManager::GetLibraryBool(int condition)
         db.Close();
       }
     }
-    return m_libraryHasMusic > 0;
+    //spotify ugly hack to allow library to be enabled without music
+    return true;
+    //return m_libraryHasMusic > 0;
   }
   else if (condition == LIBRARY_HAS_MOVIES)
   {
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxSpotify.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxSpotify.cpp
new file mode 100644
index 0000000..c9606e7
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxSpotify.cpp
@@ -0,0 +1,180 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "DVDDemuxSpotify.h"
+#include "DVDInputStreams/DVDInputStream.h"
+#include "DVDDemuxUtils.h"
+#include "music/spotyXBMC/SxSettings.h"
+#include "utils/log.h"
+#include "../DVDClock.h"
+
+using namespace std;
+
+class CDemuxStreamAudioSpotify: public CDemuxStreamAudio {
+	CDVDDemuxSpotify *m_parent;
+	string m_codec;
+public:
+	CDemuxStreamAudioSpotify(CDVDDemuxSpotify *parent, const string& codec) :
+			m_parent(parent), m_codec(codec)
+
+	{
+	}
+	void GetStreamInfo(string& strInfo) {
+		CStdString info;
+		info.Format("%s", m_codec.c_str());
+		strInfo = info;
+	}
+};
+
+CDVDDemuxSpotify::CDVDDemuxSpotify() :
+		CDVDDemux() {
+	m_pInput = NULL;
+	m_stream = NULL;
+	m_pts = 0;
+}
+
+CDVDDemuxSpotify::~CDVDDemuxSpotify() {
+	Dispose();
+}
+
+bool CDVDDemuxSpotify::Open(CDVDInputStream* pInput) {
+	if (!pInput || !pInput->IsStreamType(DVDSTREAM_TYPE_SPOTIFY))
+		return false;
+
+	m_pInput = pInput;
+	m_stream = new CDemuxStreamAudioSpotify(this, "Spotify");
+
+	m_stream->iSampleRate = 44100;
+	m_stream->iBitsPerSample = 16;
+	m_stream->iBitRate =
+			addon_music_spotify::Settings::getInstance()->useHighBitrate() ?
+					320000 : 160000;
+	m_stream->iChannels = 2;
+	m_stream->type = STREAM_AUDIO;
+	m_stream->codec = CODEC_ID_PCM_S16LE;
+
+	return true;
+}
+
+void CDVDDemuxSpotify::Dispose() {
+	delete m_stream;
+	m_stream = NULL;
+
+	m_pInput = NULL;
+	m_pts = 0;
+}
+
+void CDVDDemuxSpotify::Reset() {
+	CDVDInputStream* pInputStream = m_pInput;
+	Dispose();
+	Open(pInputStream);
+}
+
+void CDVDDemuxSpotify::Abort() {
+	if (m_pInput)
+		return m_pInput->Abort();
+}
+
+#define SPOTIFY_READ_SIZE (2048 * sizeof(int16_t))
+DemuxPacket* CDVDDemuxSpotify::Read() {
+	if (!m_pInput)
+		return NULL;
+
+	DemuxPacket* pPacket = CDVDDemuxUtils::AllocateDemuxPacket(
+			SPOTIFY_READ_SIZE);
+
+	if (!pPacket) {
+		if (m_pInput)
+			m_pInput->Close();
+		return NULL;
+	}
+
+	pPacket->iStreamId = 0;
+	pPacket->iSize = m_pInput->Read(pPacket->pData, SPOTIFY_READ_SIZE);
+	if (pPacket->iSize < 1) {
+		delete pPacket;
+		pPacket = NULL;
+	} else {
+		int n = (m_stream->iChannels * m_stream->iBitsPerSample
+				* m_stream->iSampleRate) >> 3;
+		if (n > 0) {
+			m_pts += ((double) pPacket->iSize * DVD_TIME_BASE) / n;
+			pPacket->dts = m_pts;
+			pPacket->pts = m_pts;
+		} else {
+			pPacket->dts = DVD_NOPTS_VALUE;
+			pPacket->pts = DVD_NOPTS_VALUE;
+		}
+	}
+
+	return pPacket;
+}
+
+void CDVDDemuxSpotify::Flush() {
+
+}
+
+bool CDVDDemuxSpotify::SeekTime(int time, bool backwords, double *startpts) {
+	if (time < 0)
+		time = 0;
+
+	CDVDInputStream::ISeekTime* ist =
+			dynamic_cast<CDVDInputStream::ISeekTime*>(m_pInput);
+	if (ist) {
+		if (!ist->SeekTime(time))
+			return false;
+		m_pts = (int64_t) time * (AV_TIME_BASE / 1000);
+		if (startpts)
+			*startpts = DVD_NOPTS_VALUE;
+		return true;
+	}
+	return false;
+}
+
+void CDVDDemuxSpotify::SetSpeed(int iSpeed) {
+
+}
+
+CDemuxStream* CDVDDemuxSpotify::GetStream(int iStreamId) {
+	if (iStreamId != 0)
+		return NULL;
+
+	return m_stream;
+}
+
+int CDVDDemuxSpotify::GetStreamLength() {
+	if (m_pInput)
+		return m_pInput->GetLength();
+	return 0;
+}
+
+int CDVDDemuxSpotify::GetNrOfStreams() {
+	return (m_stream == NULL ? 0 : 1);
+}
+
+std::string CDVDDemuxSpotify::GetFileName() {
+	if (m_pInput)
+		return m_pInput->GetFileName();
+	else
+		return "";
+}
+
+void CDVDDemuxSpotify::GetStreamCodecName(int iStreamId, CStdString &strName) {
+	if (m_stream && iStreamId == 0)
+		strName = "BXA";
+}
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxSpotify.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxSpotify.h
new file mode 100644
index 0000000..4ecb9a4
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxSpotify.h
@@ -0,0 +1,47 @@
+#pragma once
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "DVDDemux.h"
+
+class CDVDDemuxSpotify: public CDVDDemux {
+public:
+	CDVDDemuxSpotify();
+	virtual ~CDVDDemuxSpotify();
+
+	bool Open(CDVDInputStream* pInput);
+	void Dispose();
+	void Reset();
+	void Abort();
+	void Flush();
+	DemuxPacket* Read();
+
+	bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+	void SetSpeed(int iSpeed);
+	int GetStreamLength();
+	CDemuxStream* GetStream(int iStreamId);
+	int GetNrOfStreams();
+	std::string GetFileName();
+	virtual void GetStreamCodecName(int iStreamId, CStdString &strName);
+private:
+	friend class CDemuxStreamAudioSpotify;
+	CDVDInputStream *m_pInput;
+	CDemuxStreamAudio *m_stream;
+	double m_pts;
+};
+
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
index ecc536a..e63d04d 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
@@ -32,6 +32,7 @@
 #endif
 #include "DVDDemuxBXA.h"
 #include "DVDDemuxPVRClient.h"
+#include "DVDDemuxSpotify.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClients.h"
 
@@ -52,6 +53,15 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream)
       return NULL;
   }
 
+  if (pInputStream->IsStreamType(DVDSTREAM_TYPE_SPOTIFY))
+  {
+    auto_ptr<CDVDDemuxSpotify> demuxer(new CDVDDemuxSpotify());
+    if(demuxer->Open(pInputStream))
+      return demuxer.release();
+    else
+      return NULL;
+  }
+
   if (pInputStream->IsStreamType(DVDSTREAM_TYPE_HTTP))
   {
     CDVDInputStreamHttp* pHttpStream = (CDVDInputStreamHttp*)pInputStream;
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/Makefile.in b/xbmc/cores/dvdplayer/DVDDemuxers/Makefile.in
index b83c631..df04ac8 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/Makefile.in
@@ -8,6 +8,7 @@ SRCS += DVDDemuxPVRClient.cpp
 SRCS += DVDDemuxShoutcast.cpp
 SRCS += DVDDemuxUtils.cpp
 SRCS += DVDDemuxVobsub.cpp
+SRCS += DVDDemuxSpotify.cpp
 SRCS += DVDFactoryDemuxer.cpp
 
 LIB = DVDDemuxers.a
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
index 03fae82..6fbb11a 100644
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
@@ -28,6 +28,7 @@
 #include "DVDInputStreamPVRManager.h"
 #include "DVDInputStreamTV.h"
 #include "DVDInputStreamRTMP.h"
+#include "DVDInputStreamSpotify.h"
 #ifdef HAVE_LIBBLURAY
 #include "DVDInputStreamBluray.h"
 #endif
@@ -113,6 +114,9 @@ CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IDVDPlayer* pPlayer,
   else if(file.substr(0, 7) == "htsp://")
     return new CDVDInputStreamHTSP();
 #endif
+  if (item.IsSpotify()){
+	  return new CDVDInputStreamSpotify();
+  }
 
   // our file interface handles all these types of streams
   return (new CDVDInputStreamFile());
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h
index b3b7ae3..7467617 100644
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h
@@ -40,6 +40,7 @@ enum DVDStreamType
   DVDSTREAM_TYPE_MPLS   = 10,
   DVDSTREAM_TYPE_BLURAY = 11,
   DVDSTREAM_TYPE_PVRMANAGER = 12,
+  DVDSTREAM_TYPE_SPOTIFY = 13,
 };
 
 #define SEEK_POSSIBLE 0x10 // flag used to check if protocol allows seeks
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamSpotify.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamSpotify.cpp
new file mode 100644
index 0000000..935390c
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamSpotify.cpp
@@ -0,0 +1,232 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "DVDInputStreamSpotify.h"
+#include "playlists/PlayList.h"
+#include "PlayListPlayer.h"
+#include "utils/log.h"
+#include "utils/URIUtils.h"
+#include "music/spotyXBMC/session/Session.h"
+#include "music/spotyXBMC/radio/RadioHandler.h"
+#include "music/spotyXBMC/player/PlayerHandler.h"
+#include "utils/RingBuffer.h"
+
+#define XMIN(a,b) ((a)<(b)?(a):(b))
+
+using namespace addon_music_spotify;
+using namespace PLAYLIST;
+
+CDVDInputStreamSpotify::CDVDInputStreamSpotify() :
+		CDVDInputStream(DVDSTREAM_TYPE_SPOTIFY) {
+	m_buffer.Destroy();
+	m_currentTrack = 0;
+	m_isPlayerLoaded = false;
+	m_endOfTrack = false;
+	m_totalTime = 0;
+}
+
+CDVDInputStreamSpotify::~CDVDInputStreamSpotify() {
+	Close();
+}
+
+bool CDVDInputStreamSpotify::Open(const char* strFile,
+		const std::string& content) {
+	m_buffer.Create(2048 * sizeof(int16_t) * 50);
+
+	CStdString uri = URIUtils::GetFileName(strFile);
+	CStdString extension = uri.Right(uri.GetLength() - uri.Find('.') - 1);
+	if (extension.Left(12) == "spotifyradio") {
+		//if its a radiotrack the radionumber and tracknumber is secretly
+		// encoded at the end of the extension
+		CStdString trackStr = extension.Right(
+				extension.GetLength() - extension.ReverseFind('#') - 1);
+		CStdString radioNumber = extension.Left(uri.Find('#'));
+		radioNumber = radioNumber.Right(
+				radioNumber.GetLength() - radioNumber.Find('#') - 1);
+		RadioHandler::getInstance()->pushToTrack(atoi(radioNumber),
+				atoi(trackStr));
+	}
+
+	//we have a non legit extension so remove it manually
+	uri = uri.Left(uri.Find('.'));
+
+	Logger::printOut("trying to load track:");
+	Logger::printOut(uri);
+	sp_link *spLink = sp_link_create_from_string(uri);
+	m_currentTrack = sp_link_as_track(spLink);
+	sp_track_add_ref(m_currentTrack);
+	sp_link_release(spLink);
+	m_endOfTrack = false;
+	m_isPlayerLoaded = false;
+	m_totalTime = sp_track_duration(m_currentTrack);
+
+	// Prefetch the next track!
+
+	CPlayList & playlist = g_playlistPlayer.GetPlaylist(PLAYLIST_MUSIC);
+	int nextSong = g_playlistPlayer.GetNextSong();
+
+	if (nextSong >= 0 && nextSong < playlist.size()) {
+		CFileItemPtr song = playlist[nextSong];
+		if (song != NULL) {
+			CStdString uri = song->GetPath();
+			if (uri.Left(7).Equals("spotify")) {
+				uri = uri.Left(uri.Find('.'));
+				Logger::printOut("prefetching track:");
+				Logger::printOut(uri);
+				sp_link *spLink = sp_link_create_from_string(uri);
+				sp_track* track = sp_link_as_track(spLink);
+				sp_session_player_prefetch(getSession(), track);
+				sp_link_release(spLink);
+			}
+		}
+	}
+	return true;
+}
+
+void CDVDInputStreamSpotify::Close() {
+	unloadPlayer();
+	m_buffer.Destroy();
+}
+
+int CDVDInputStreamSpotify::Read(BYTE* pBuffer, int size) {
+	if (!m_isPlayerLoaded)
+		loadPlayer();
+
+	// Wait at most 3 seconds to fill buffer
+	int maxLoops = 60;
+	while (!m_endOfTrack && m_buffer.getMaxReadSize() <= 0) {
+		if (--maxLoops <= 0) {
+			Logger::printOut("Empty buffer");
+			return 0;
+		}
+		Sleep(50);
+	}
+
+	unsigned int want = (unsigned int)
+			XMIN(m_buffer.getMaxReadSize(), (unsigned int)size);
+
+	if (m_buffer.ReadData((char *) pBuffer, want))
+		return want;
+
+	return 0;
+}
+
+bool CDVDInputStreamSpotify::SeekTime(int iTimeInMsec) {
+	Logger::printOut("trying to seek");
+	//if (sp_session_player_seek(getSession(), iTimeInMsec) != SP_ERROR_OK)
+	//	return false;
+	sp_session_player_seek(getSession(), iTimeInMsec);
+	return true;
+}
+
+int64_t CDVDInputStreamSpotify::Seek(int64_t offset, int whence) {
+
+	if (whence == SEEK_POSSIBLE)
+		return 0;
+	return -1;
+}
+
+bool CDVDInputStreamSpotify::IsEOF() {
+// TODO Semaphore
+	return m_endOfTrack;
+}
+
+int64_t CDVDInputStreamSpotify::GetLength() {
+	return m_totalTime;
+}
+
+bool CDVDInputStreamSpotify::Pause(double dTime) {
+//CSingleLock lock(m_RTMPSection);
+	return true;
+}
+
+bool CDVDInputStreamSpotify::loadPlayer() {
+	Logger::printOut("load player");
+	if (!m_isPlayerLoaded) {
+		//do we have a track at all?
+		if (m_currentTrack) {
+			CStdString name;
+			Logger::printOut("load player 2");
+			if (sp_track_is_loaded(m_currentTrack)) {
+				sp_error error = sp_session_player_load(getSession(),
+						m_currentTrack);
+				CStdString message;
+				Logger::printOut("load player 3");
+				message.Format("%s", sp_error_message(error));
+				Logger::printOut(message);
+				Logger::printOut("load player 4");
+				if (SP_ERROR_OK == error) {
+					PlayerHandler::getInstance()->attachPlayer(this);
+					sp_session_player_play(getSession(), true);
+					m_isPlayerLoaded = true;
+					Logger::printOut("load player 5");
+					return true;
+				}
+			}
+		} else
+			return false;
+	}
+	return true;
+}
+
+bool CDVDInputStreamSpotify::unloadPlayer() {
+//make sure there is no music_delivery while we are removing the codec
+	while (!Session::getInstance()->lock()) {
+	}
+	if (m_isPlayerLoaded) {
+		sp_session_player_play(getSession(), false);
+		sp_session_player_unload(getSession());
+		if (m_currentTrack != NULL) {
+			sp_track_release(m_currentTrack);
+		}
+		PlayerHandler::getInstance()->detachPlayer(this);
+	}
+
+	m_currentTrack = NULL;
+	m_isPlayerLoaded = false;
+	m_endOfTrack = true;
+	Session::getInstance()->unlock();
+	return true;
+}
+
+sp_session* CDVDInputStreamSpotify::getSession() {
+	return Session::getInstance()->getSpSession();
+}
+
+int CDVDInputStreamSpotify::sp_musicDelivery(const sp_audioformat *format,
+		const void *frames, int num_frames) {
+	if (num_frames == 0) {
+		Logger::printOut("musicDelivery Discontinuity");
+		// A discontinuity has occurred, flush buffers and return
+		m_buffer.Clear();
+		return 0;
+	}
+
+	int consumedFrames = 0;
+	unsigned int size = num_frames * (int) sizeof(int16_t) * format->channels;
+
+	if (m_buffer.getMaxWriteSize() > size) {
+		if (m_buffer.WriteData((char *) frames, size))
+			consumedFrames = size / ((int) sizeof(int16_t) * format->channels);
+	}
+	return consumedFrames;
+}
+
+void CDVDInputStreamSpotify::sp_endOfTrack() {
+	m_endOfTrack = true;
+}
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamSpotify.h b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamSpotify.h
new file mode 100644
index 0000000..ec23281
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamSpotify.h
@@ -0,0 +1,59 @@
+#pragma once
+
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "DVDInputStream.h"
+#include "utils/RingBuffer.h"
+#include "music/spotyXBMC/player/ISpotifyPlayer.h"
+#include <libspotify/api.h>
+
+using namespace addon_music_spotify;
+class CDVDInputStreamSpotify: public CDVDInputStream,
+		public CDVDInputStream::ISeekTime,
+		public ISpotifyPlayer {
+public:
+	CDVDInputStreamSpotify();
+	virtual ~CDVDInputStreamSpotify();
+
+	virtual bool Open(const char* strFile, const std::string& content);
+	virtual void Close();
+	virtual int Read(BYTE* buf, int buf_size);
+	bool SeekTime(int iTimeInMsec);
+	virtual int64_t Seek(int64_t offset, int whence);
+	virtual bool IsEOF();
+	virtual int64_t GetLength();
+	virtual bool Pause(double dTime);
+
+	int sp_musicDelivery(const sp_audioformat *format, const void *frames,
+			int num_frames);
+	void sp_endOfTrack();
+
+private:
+	bool loadPlayer();
+	bool unloadPlayer();
+	sp_session * getSession();
+
+	sp_track *m_currentTrack;
+	CRingBuffer m_buffer;
+	//bool m_startStream;
+	bool m_isPlayerLoaded;
+	bool m_endOfTrack;
+	int64_t m_totalTime; // time in milliseconds
+};
+
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/Makefile b/xbmc/cores/dvdplayer/DVDInputStreams/Makefile
index 4607ed3..0bed883 100644
--- a/xbmc/cores/dvdplayer/DVDInputStreams/Makefile
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/Makefile
@@ -14,6 +14,7 @@ SRCS=	DVDFactoryInputStream.cpp \
 	DVDInputStreamPVRManager.cpp \
 	DVDInputStreamStack.cpp \
 	DVDInputStreamTV.cpp \
+	DVDInputStreamSpotify.cpp \
 	DVDStateSerializer.cpp \
 
 LIB=	DVDInputStreams.a
diff --git a/xbmc/cores/paplayer/CodecFactory.cpp b/xbmc/cores/paplayer/CodecFactory.cpp
index f1ce580..80c6967 100644
--- a/xbmc/cores/paplayer/CodecFactory.cpp
+++ b/xbmc/cores/paplayer/CodecFactory.cpp
@@ -41,6 +41,7 @@
 #include "URL.h"
 #include "DVDPlayerCodec.h"
 #include "PCMCodec.h"
+#include "SpotifyCodec.h"
 
 ICodec* CodecFactory::CreateCodec(const CStdString& strFileType)
 {
@@ -109,6 +110,10 @@ ICodec* CodecFactory::CreateCodec(const CStdString& strFileType)
 #endif
   else if (strFileType.Equals("tta"))
     return new DVDPlayerCodec();
+  //spotify
+  //TODO see if any addon has the ability to play the format.... now hardcode spotify
+  else if (strFileType.Left(7).Equals("spotify"))
+    return new SpotifyCodec();
 
   return NULL;
 }
diff --git a/xbmc/cores/paplayer/Makefile.in b/xbmc/cores/paplayer/Makefile.in
index 31cc8bd..660e5b2 100644
--- a/xbmc/cores/paplayer/Makefile.in
+++ b/xbmc/cores/paplayer/Makefile.in
@@ -25,6 +25,7 @@ SRCS += TimidityCodec.cpp
 SRCS += VGMCodec.cpp
 SRCS += WAVcodec.cpp
 SRCS += YMCodec.cpp
+SRCS += SpotifyCodec.cpp
 
 ifeq (@USE_ASAP_CODEC@,1)
 SRCS += ASAPCodec.cpp
diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index 5a99843..9623ac6 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -37,6 +37,7 @@
 #define TIME_TO_CACHE_NEXT_FILE 5000 /* 5 seconds before end of song, start caching the next song */
 #define FAST_XFADE_TIME           80 /* 80 milliseconds */
 #define MAX_SKIP_XFADE_TIME     2000 /* max 2 seconds crossfade on track skip */
+/* Spotify hack !! When changing defines above, also do it OpenFile and QueueNextFileEx below */
 
 CAEChannelInfo ICodec::GetChannelInfo()
 {
@@ -229,7 +230,26 @@ void PAPlayer::CloseAllStreams(bool fade/* = true */)
 
 bool PAPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
 {
-  m_defaultCrossfadeMS = g_guiSettings.GetInt("musicplayer.crossfade") * 1000;
+  if (!file.IsSpotify())
+  {
+    m_defaultCrossfadeMS = g_guiSettings.GetInt("musicplayer.crossfade") * 1000;
+    #undef TIME_TO_CACHE_NEXT_FILE //Ensure we have default values
+    #undef FAST_XFADE_TIME
+    #undef MAX_SKIP_XFADE_TIME
+    #define TIME_TO_CACHE_NEXT_FILE 5000
+    #define FAST_XFADE_TIME           80
+    #define MAX_SKIP_XFADE_TIME     2000
+  }
+  else
+  {
+    m_defaultCrossfadeMS = 0;
+    #undef TIME_TO_CACHE_NEXT_FILE
+    #undef FAST_XFADE_TIME
+    #undef MAX_SKIP_XFADE_TIME
+    #define TIME_TO_CACHE_NEXT_FILE 0000
+    #define FAST_XFADE_TIME           00
+    #define MAX_SKIP_XFADE_TIME     0000
+  }
 
   if (m_streams.size() > 1 || !m_defaultCrossfadeMS || m_isPaused)
   {
@@ -264,7 +284,12 @@ bool PAPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
 
 void PAPlayer::UpdateCrossfadeTime(const CFileItem& file)
 {
-  m_upcomingCrossfadeMS = m_defaultCrossfadeMS = g_guiSettings.GetInt("musicplayer.crossfade") * 1000;
+  if (!file.IsSpotify())
+    m_upcomingCrossfadeMS = m_defaultCrossfadeMS = g_guiSettings.GetInt("musicplayer.crossfade") * 1000;
+  else
+    CLog::Log(LOGDEBUG, "PAPlayer::UpdateCrossfadeTime: Spotify track detected, crossfade is disabled.");
+  m_upcomingCrossfadeMS = m_defaultCrossfadeMS; // Spotify (spotyxbmc) can not handle crossfade
+
   if (m_upcomingCrossfadeMS)
   {
     if (m_streams.size() == 0 ||
@@ -291,6 +316,35 @@ bool PAPlayer::QueueNextFile(const CFileItem &file)
 
 bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
 {
+
+  if (!file.IsSpotify())
+  {
+    #undef TIME_TO_CACHE_NEXT_FILE //Make sure we have default values
+    #undef FAST_XFADE_TIME
+    #undef MAX_SKIP_XFADE_TIME
+    #define TIME_TO_CACHE_NEXT_FILE 5000
+    #define FAST_XFADE_TIME           80
+    #define MAX_SKIP_XFADE_TIME     2000
+  }
+  else
+  {
+    m_defaultCrossfadeMS = 0;
+    #undef TIME_TO_CACHE_NEXT_FILE
+    #undef FAST_XFADE_TIME
+    #undef MAX_SKIP_XFADE_TIME
+    #define TIME_TO_CACHE_NEXT_FILE 0000
+    #define FAST_XFADE_TIME           00
+    #define MAX_SKIP_XFADE_TIME     0000
+    CSharedLock lock(m_streamsLock);
+    while (m_streams.size() > 0) //Make sure we only have one concurrent stream
+    {
+      lock.Leave();
+      Sleep(50);
+      CSharedLock lock(m_streamsLock);
+    }
+    lock.Leave();
+  }
+
   StreamInfo *si = new StreamInfo();
 
   if (!si->m_decoder.Create(file, (file.m_lStartOffset * 1000) / 75))
diff --git a/xbmc/cores/paplayer/SpotifyCodec.cpp b/xbmc/cores/paplayer/SpotifyCodec.cpp
new file mode 100644
index 0000000..b6b2cd2
--- /dev/null
+++ b/xbmc/cores/paplayer/SpotifyCodec.cpp
@@ -0,0 +1,247 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+               2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "SpotifyCodec.h"
+#include "playlists/PlayList.h"
+#include "PlayListPlayer.h"
+#include "Util.h"
+#include "utils/URIUtils.h"
+#include <stdint.h>
+#include <string.h>
+#include "music/spotyXBMC/session/Session.h"
+#include "music/spotyXBMC/radio/RadioHandler.h"
+#include "music/spotyXBMC/player/PlayerHandler.h"
+
+using namespace addon_music_spotify;
+using namespace PLAYLIST;
+
+SpotifyCodec::SpotifyCodec() {
+	m_SampleRate = 44100;
+	m_Channels = 2;
+	m_BitsPerSample = 16;
+	// The bitrate is hardcoded, we dont no it before first music delivery and
+	// then its to late, the skin has already printed it out
+	m_Bitrate = Settings::getInstance()->useHighBitrate() ? 320000 : 160000;
+	m_CodecName = "spotify";
+	m_DataFormat = AE_FMT_S16NE;
+	m_TotalTime = 0;
+	m_currentTrack = 0;
+	m_isPlayerLoaded = false;
+	m_buffer = 0;
+	m_bufferPos = 0;
+	m_bufferSize = 0;
+	m_endOfTrack = false;
+	m_startStream = false;
+}
+
+SpotifyCodec::~SpotifyCodec() {
+	DeInit();
+	delete m_buffer;
+}
+
+bool SpotifyCodec::Init(const CStdString & strFile, unsigned int filecache) {
+	m_bufferSize = 2048 * sizeof(int16_t) * 50;
+	m_buffer = new char[m_bufferSize];
+	CStdString uri = URIUtils::GetFileName(strFile);
+	CStdString extension = uri.Right(uri.GetLength() - uri.Find('.') - 1);
+	if (extension.Left(12) == "spotifyradio") {
+		//if its a radiotrack the radionumber and tracknumber is secretly
+		// encoded at the end of the extension
+		CStdString trackStr = extension.Right(
+				extension.GetLength() - extension.ReverseFind('#') - 1);
+		Logger::printOut(extension);
+		CStdString radioNumber = extension.Left(uri.Find('#'));
+		Logger::printOut(radioNumber);
+		radioNumber = radioNumber.Right(
+				radioNumber.GetLength() - radioNumber.Find('#') - 1);
+		Logger::printOut("loading codec radio");
+		RadioHandler::getInstance()->pushToTrack(atoi(radioNumber),
+				atoi(trackStr));
+	}
+	//we have a non legit extension so remove it manually
+	uri = uri.Left(uri.Find('.'));
+
+	Logger::printOut("trying to load track:");
+	Logger::printOut(uri);
+	sp_link *spLink = sp_link_create_from_string(uri);
+	m_currentTrack = sp_link_as_track(spLink);
+	sp_track_add_ref(m_currentTrack);
+	sp_link_release(spLink);
+	m_endOfTrack = false;
+	m_bufferPos = 0;
+	m_startStream = false;
+	m_isPlayerLoaded = false;
+	m_TotalTime = sp_track_duration(m_currentTrack);
+
+	//prefetch the next track!
+
+	CPlayList & playlist = g_playlistPlayer.GetPlaylist(PLAYLIST_MUSIC);
+	int nextSong = g_playlistPlayer.GetNextSong();
+
+	if (nextSong >= 0 && nextSong < playlist.size()) {
+		CFileItemPtr song = playlist[nextSong];
+		if (song != NULL) {
+			CStdString uri = song->GetPath();
+			if (uri.Left(7).Equals("spotify")) {
+				uri = uri.Left(uri.Find('.'));
+				Logger::printOut("prefetching track:");
+				Logger::printOut(uri);
+				sp_link *spLink = sp_link_create_from_string(uri);
+				sp_track* track = sp_link_as_track(spLink);
+				sp_session_player_prefetch(getSession(), track);
+				sp_link_release(spLink);
+			}
+		}
+	}
+	return true;
+}
+
+void SpotifyCodec::DeInit() {
+	unloadPlayer();
+}
+
+bool SpotifyCodec::CanSeek() {
+	return true;
+}
+
+int64_t SpotifyCodec::Seek(int64_t iSeekTime) {
+	Logger::printOut("trying to seek");
+	sp_session_player_seek(getSession(), (int) iSeekTime);
+	m_bufferPos = 0;
+	return iSeekTime;
+}
+
+int SpotifyCodec::ReadPCM(BYTE *pBuffer, int size, int *actualsize) {
+	*actualsize = 0;
+	if (!m_isPlayerLoaded)
+		loadPlayer();
+
+	if (m_startStream) {
+		if (m_endOfTrack && m_bufferPos == 0) {
+			return READ_EOF;
+		} else if (m_bufferPos > 0) {
+			int amountToMove = m_bufferPos;
+			if (m_bufferPos > size)
+				amountToMove = size;
+			memcpy(pBuffer, m_buffer, amountToMove);
+			memmove(m_buffer, m_buffer + amountToMove,
+					m_bufferSize - amountToMove);
+			m_bufferPos -= amountToMove;
+			*actualsize = amountToMove;
+		}
+	}
+	return READ_SUCCESS;
+}
+
+bool SpotifyCodec::CanInit() {
+	return true;
+}
+
+bool SpotifyCodec::loadPlayer() {
+	Logger::printOut("load player");
+	if (!m_isPlayerLoaded) {
+		//do we have a track at all?
+		if (m_currentTrack) {
+			CStdString name;
+			Logger::printOut("load player 2");
+			if (sp_track_is_loaded(m_currentTrack)) {
+				sp_error error = sp_session_player_load(getSession(),
+						m_currentTrack);
+				CStdString message;
+				Logger::printOut("load player 3");
+				message.Format("%s", sp_error_message(error));
+				Logger::printOut(message);
+				Logger::printOut("load player 4");
+				if (SP_ERROR_OK == error) {
+					PlayerHandler::getInstance()->attachPlayer(this);
+					sp_session_player_play(getSession(), true);
+					m_isPlayerLoaded = true;
+					Logger::printOut("load player 5");
+					return true;
+				}
+			}
+		} else
+			return false;
+	}
+	return true;
+}
+
+bool SpotifyCodec::unloadPlayer() {
+	//make sure there is no music_delivery while we are removing the codec
+	while (!Session::getInstance()->lock()) {
+	}
+	if (m_isPlayerLoaded) {
+		sp_session_player_play(getSession(), false);
+		sp_session_player_unload(getSession());
+		if (m_currentTrack != NULL) {
+			sp_track_release(m_currentTrack);
+		}
+		PlayerHandler::getInstance()->detachPlayer(this);
+	}
+
+	m_currentTrack = NULL;
+	m_isPlayerLoaded = false;
+	m_endOfTrack = true;
+	Session::getInstance()->unlock();
+	return true;
+}
+
+int SpotifyCodec::sp_musicDelivery(const sp_audioformat *format,
+		const void *frames, int num_frames) {
+	//Logger::printOut("music delivery");
+	int amountToMove = num_frames * (int) sizeof(int16_t) * format->channels;
+
+	if ((m_bufferPos + amountToMove) >= m_bufferSize) {
+		amountToMove = m_bufferSize - m_bufferPos;
+	}
+
+	memcpy(m_buffer + m_bufferPos, frames, amountToMove);
+	m_bufferPos += amountToMove;
+
+	if (!m_startStream && m_bufferPos == m_bufferSize) {
+		//now the buffer is full, start playing
+		m_startStream = true;
+	}
+
+	return amountToMove / ((int) sizeof(int16_t) * format->channels);
+}
+
+void SpotifyCodec::sp_endOfTrack() {
+	m_endOfTrack = true;
+}
+
+sp_session* SpotifyCodec::getSession() {
+	return Session::getInstance()->getSpSession();
+}
+
+CAEChannelInfo SpotifyCodec::GetChannelInfo() {
+	static enum AEChannel map[2][3] = { { AE_CH_FC, AE_CH_NULL }, { AE_CH_FL,
+			AE_CH_FR, AE_CH_NULL } };
+
+	if (m_Channels > 2) {
+		Logger::printOut("m_Channels is bigger than 2, please fix code,"
+				"I can't return a valid AEChannel map");
+//    return CAEUtil::GuessChLayout(m_Channels);
+	}
+
+	return CAEChannelInfo(map[m_Channels - 1]);
+}
diff --git a/xbmc/cores/paplayer/SpotifyCodec.h b/xbmc/cores/paplayer/SpotifyCodec.h
new file mode 100644
index 0000000..fa243a6
--- /dev/null
+++ b/xbmc/cores/paplayer/SpotifyCodec.h
@@ -0,0 +1,58 @@
+#pragma once
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+               2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "cores/paplayer/CachingCodec.h"
+#include "music/spotyXBMC/player/ISpotifyPlayer.h"
+#include <libspotify/api.h>
+
+using namespace addon_music_spotify;
+class SpotifyCodec: public CachingCodec, public ISpotifyPlayer {
+public:
+	SpotifyCodec();
+	virtual ~SpotifyCodec();
+
+	bool Init(const CStdString &strFile, unsigned int filecache);
+	void DeInit();
+	bool CanSeek();
+	int64_t Seek(int64_t iSeekTime);
+	int ReadPCM(BYTE *pBuffer, int size, int *actualsize);
+	bool CanInit();
+	CAEChannelInfo GetChannelInfo();
+
+	int sp_musicDelivery(const sp_audioformat *format, const void *frames,
+			int num_frames);
+	void sp_endOfTrack();
+
+private:
+	bool loadPlayer();
+	bool unloadPlayer();
+
+	sp_session * getSession();
+	sp_track *m_currentTrack;
+	bool m_startStream;
+	bool m_isPlayerLoaded;
+	bool m_endOfTrack;
+	int m_bufferSize;
+	char *m_buffer;
+	int m_bufferPos;
+};
diff --git a/xbmc/dialogs/GUIDialogContextMenu.h b/xbmc/dialogs/GUIDialogContextMenu.h
index 942a84d..cdd75e9 100644
--- a/xbmc/dialogs/GUIDialogContextMenu.h
+++ b/xbmc/dialogs/GUIDialogContextMenu.h
@@ -135,7 +135,12 @@ enum CONTEXT_BUTTON { CONTEXT_BUTTON_CANCELLED = 0,
                       CONTEXT_BUTTON_USER7,
                       CONTEXT_BUTTON_USER8,
                       CONTEXT_BUTTON_USER9,
-                      CONTEXT_BUTTON_USER10
+                      CONTEXT_BUTTON_USER10,
+                      //spotify allow us to set stared tracks and albums
+                      CONTEXT_BUTTON_SPOTIFY_TOGGLE_STAR_TRACK,
+                      CONTEXT_BUTTON_SPOTIFY_TOGGLE_STAR_ALBUM,
+                      CONTEXT_BUTTON_SPOTIFY_BROWSE_ALBUM,
+                      CONTEXT_BUTTON_SPOTIFY_BROWSE_ARTIST
                     };
 
 class CContextButtons : public std::vector< std::pair<unsigned int, CStdString> >
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
index 2fdaf3d..f910fb0 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+//spotify
+#include "../../music/spotyXBMC/Addon.music.spotify.h"
 #include "DirectoryNodeAlbum.h"
 #include "QueryParams.h"
 #include "music/MusicDatabase.h"
@@ -53,9 +55,15 @@ bool CDirectoryNodeAlbum::GetContent(CFileItemList& items) const
 
   CQueryParams params;
   CollectQueryParams(params);
+  CStdString strBaseDir = BuildPath();
+  CURL url(strBaseDir);
 
   bool bSuccess=musicdatabase.GetAlbumsNav(BuildPath(), items, params.GetGenreId(), params.GetArtistId());
 
+  //spotify
+  // TODO ask all loaded music addons for albums
+  bSuccess = g_spotify->GetAlbums(items, strBaseDir,musicdatabase.GetArtistById(params.GetArtistId()));
+
   musicdatabase.Close();
 
   return bSuccess;
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeArtist.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeArtist.cpp
index 8c5b8a8..7c2819c 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeArtist.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeArtist.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+//spotify
+#include "../../music/spotyXBMC/Addon.music.spotify.h"
 #include "DirectoryNodeArtist.h"
 #include "QueryParams.h"
 #include "music/MusicDatabase.h"
@@ -57,6 +59,12 @@ bool CDirectoryNodeArtist::GetContent(CFileItemList& items) const
 
   bool bSuccess = musicdatabase.GetArtistsNav(BuildPath(), items, !g_guiSettings.GetBool("musiclibrary.showcompilationartists"), params.GetGenreId());
 
+  //spotify
+  // TODO ask all loaded music addons for artists
+  CStdString strBaseDir = BuildPath();
+  bSuccess = g_spotify->GetArtists(items, strBaseDir);
+
+
   musicdatabase.Close();
 
   return bSuccess;
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
index cd69df1..e714052 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+//spotify
+#include "../../music/spotyXBMC/Addon.music.spotify.h"
 #include "DirectoryNodeOverview.h"
 #include "FileItem.h"
 #include "music/MusicDatabase.h"
@@ -94,5 +96,10 @@ bool CDirectoryNodeOverview::GetContent(CFileItemList& items) const
     items.Add(pItem);
   }
 
+  //spotify
+   // TODO ask all loaded music addons for custom entries
+   g_spotify->GetCustomEntries(items);
+
+
   return true;
 }
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeSong.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeSong.cpp
index 43fd5df..e26316b 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeSong.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeSong.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+//spotify
+#include "../../music/spotyXBMC/Addon.music.spotify.h"
 #include "DirectoryNodeSong.h"
 #include "QueryParams.h"
 #include "music/MusicDatabase.h"
@@ -42,6 +44,10 @@ bool CDirectoryNodeSong::GetContent(CFileItemList& items) const
   CStdString strBaseDir=BuildPath();
   bool bSuccess=musicdatabase.GetSongsNav(strBaseDir, items, params.GetGenreId(), params.GetArtistId(), params.GetAlbumId());
 
+  //spotify
+  //TODO scan through all addons that provide songs, also create a better naming system for addon sources
+  bSuccess = g_spotify->GetTracks(items, strBaseDir,musicdatabase.GetArtistById(params.GetArtistId()),params.GetAlbumId());
+
   musicdatabase.Close();
 
   return bSuccess;
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeTop100.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeTop100.cpp
index 7162aba..97095d7 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeTop100.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeTop100.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+//spotify
+#include "../../music/spotyXBMC/Addon.music.spotify.h"
 #include "DirectoryNodeTop100.h"
 #include "FileItem.h"
 #include "guilib/LocalizeStrings.h"
@@ -65,5 +67,9 @@ bool CDirectoryNodeTop100::GetContent(CFileItemList& items) const
     items.Add(pItem);
   }
 
+  //spotify
+  //get all toplists from addons, now just fetch the spotify lists
+  g_spotify->GetTopLists(items);
+
   return true;
 }
diff --git a/xbmc/filesystem/MusicSearchDirectory.cpp b/xbmc/filesystem/MusicSearchDirectory.cpp
index 34fc013..cecd6ec 100644
--- a/xbmc/filesystem/MusicSearchDirectory.cpp
+++ b/xbmc/filesystem/MusicSearchDirectory.cpp
@@ -17,7 +17,8 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
-
+//spotify
+#include "../music/spotyXBMC/Addon.music.spotify.h"
 #include "threads/SystemClock.h"
 #include "MusicSearchDirectory.h"
 #include "music/MusicDatabase.h"
@@ -49,6 +50,9 @@ bool CMusicSearchDirectory::GetDirectory(const CStdString& strPath, CFileItemLis
 
   // and retrieve the search details
   items.SetPath(strPath);
+  //spotify perform a search in spotify.
+  //TODO search all addons providing search functionality
+  g_spotify->Search(search, items);
   unsigned int time = XbmcThreads::SystemClockMillis();
   CMusicDatabase db;
   db.Open();
diff --git a/xbmc/music/Makefile b/xbmc/music/Makefile
index 045a267..2f33242 100644
--- a/xbmc/music/Makefile
+++ b/xbmc/music/Makefile
@@ -7,7 +7,38 @@ SRCS=Album.cpp \
      MusicInfoLoader.cpp \
      MusicThumbLoader.cpp \
      Song.cpp \
-     
+     spotyXBMC/Addon.music.spotify.cpp \
+     spotyXBMC/Logger.cpp \
+     spotyXBMC/Utils.cpp \
+     spotyXBMC/SxSettings.cpp \
+     spotyXBMC/radio/SxRadio.cpp \
+     spotyXBMC/radio/RadioHandler.cpp \
+     spotyXBMC/radio/RadioBackgroundLoader.cpp \
+     spotyXBMC/album/SxAlbum.cpp \
+     spotyXBMC/album/AlbumStore.cpp \
+     spotyXBMC/album/AlbumContainer.cpp \
+     spotyXBMC/artist/SxArtist.cpp \
+     spotyXBMC/artist/ArtistStore.cpp \
+     spotyXBMC/artist/ArtistContainer.cpp \
+     spotyXBMC/search/Search.cpp \
+     spotyXBMC/search/SearchHandler.cpp \
+     spotyXBMC/search/SearchResultBackgroundLoader.cpp \
+     spotyXBMC/playlist/TopLists.cpp \
+     spotyXBMC/playlist/SxPlaylist.cpp \
+     spotyXBMC/playlist/StarredList.cpp \
+     spotyXBMC/playlist/PlaylistStore.cpp \
+     spotyXBMC/playlist/StarredBackgroundLoader.cpp \
+     spotyXBMC/session/Session.cpp \
+     spotyXBMC/session/BackgroundThread.cpp \
+     spotyXBMC/session/SessionCallbacks.cpp \
+     spotyXBMC/thumb/SxThumb.cpp \
+     spotyXBMC/thumb/ThumbStore.cpp \
+     spotyXBMC/track/SxTrack.cpp \
+     spotyXBMC/track/TrackStore.cpp \
+     spotyXBMC/track/TrackContainer.cpp \
+     spotyXBMC/player/PlayerHandler.cpp \
+     spotyXBMC/player/ISpotifyPlayer.cpp
+
 LIB=music.a
 
 include ../../Makefile.include
diff --git a/xbmc/music/spotyXBMC/Addon.music.spotify.cpp b/xbmc/music/spotyXBMC/Addon.music.spotify.cpp
new file mode 100644
index 0000000..0161576
--- /dev/null
+++ b/xbmc/music/spotyXBMC/Addon.music.spotify.cpp
@@ -0,0 +1,760 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+               2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "Addon.music.spotify.h"
+#include <stdint.h>
+#include "Utils.h"
+#include "Logger.h"
+#include "session/Session.h"
+#include "playlist/StarredList.h"
+#include "playlist/TopLists.h"
+#include "playlist/PlaylistStore.h"
+#include "playlist/SxPlaylist.h"
+#include "artist/SxArtist.h"
+#include "artist/ArtistStore.h"
+#include "track/TrackStore.h"
+#include "album/SxAlbum.h"
+#include "track/SxTrack.h"
+#include "album/AlbumStore.h"
+#include "../tags/MusicInfoTag.h"
+#include "../Album.h"
+#include "../Artist.h"
+#include "../../MediaSource.h"
+#include "player/PlayerHandler.h"
+#include "search/SearchHandler.h"
+#include "radio/RadioHandler.h"
+#include "SxSettings.h"
+
+using namespace addon_music_spotify;
+using namespace std;
+
+Addon_music_spotify* g_spotify;
+
+Addon_music_spotify::Addon_music_spotify() {
+		Session::getInstance()->enable();
+}
+
+Addon_music_spotify::~Addon_music_spotify() {
+	Session::getInstance()->deInit();
+	Logger::printOut("removing spotify addon");
+}
+
+bool Addon_music_spotify::enable(bool enable) {
+	if (enable)
+		return Session::getInstance()->enable();
+
+	Session::getInstance()->deInit();
+	return false;
+}
+
+bool Addon_music_spotify::isReady() {
+	return Session::getInstance()->isReady();
+}
+
+bool Addon_music_spotify::GetPlaylists(CFileItemList& items) {
+	if (isReady()) {
+		PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+		CMediaSource playlistShare;
+		for (int i = 0; i < ps->getPlaylistCount(); i++) {
+			if (!ps->getPlaylist(i)->isFolder() && ps->getPlaylist(i)->isLoaded()) {
+				playlistShare.strPath.Format("musicdb://3/spotify:playlist:%i", i);
+				const char* owner = ps->getPlaylist(i)->getOwnerName();
+				if (owner != NULL)
+					playlistShare.strName.Format("%s %s %s",
+							ps->getPlaylist(i)->getName(), Settings::getInstance()->getByString(), owner);
+				else
+					playlistShare.strName.Format("%s", ps->getPlaylist(i)->getName());
+				CFileItemPtr pItem(new CFileItem(playlistShare));
+				SxThumb* thumb = ps->getPlaylist(i)->getThumb();
+				if (thumb != NULL)
+					pItem->SetArt("thumb",thumb->getPath());
+				pItem->SetProperty("fanart_image", Settings::getInstance()->getFanart());
+				items.Add(pItem);
+			}
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::GetAlbums(CFileItemList& items, CStdString& path,
+		CStdString artistName) {
+	CURL url(path);
+	CStdString uri = url.GetFileNameWithoutPath();
+	if (uri.Left(14).Equals("spotify:artist")) {
+		return getArtistAlbums(items, uri);
+	} else if (uri.Left(15).Equals("spotify:toplist")) {
+		return getTopListAlbums(items);
+	} else if (uri.Left(13).Equals("spotify:track")) {
+		sp_link *spLink = sp_link_create_from_string(uri.Left(uri.Find('.')));
+		if (!spLink)
+			return false;
+		sp_track *spTrack = sp_link_as_track(spLink);
+		if (spTrack) {
+			sp_artist* spArtist = sp_track_artist(spTrack, 0);
+			return getArtistAlbums(items, spArtist);
+		}
+	} else if (uri.Left(13).Equals("spotify:album")) {
+		Logger::printOut("browsing artist from album");
+		Logger::printOut(uri);
+		sp_link *spLink = sp_link_create_from_string(uri.Left(uri.Find('#')));
+		if (!spLink)
+			return false;
+		sp_album *spAlbum = sp_link_as_album(spLink);
+		if (spAlbum) {
+			sp_artist* spArtist = sp_album_artist(spAlbum);
+			return getArtistAlbums(items, spArtist);
+		}
+	} else {
+		return getAllAlbums(items, artistName);
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getArtistAlbums(CFileItemList& items,
+		sp_artist* spArtist) {
+	SxArtist* artist = ArtistStore::getInstance()->getArtist(spArtist, true);
+	if (!artist)
+		return true;
+
+	// Not pretty but we need to advance libspotify if we are loading the artist for the first time here (clicking "browse artist" from the context menu)
+
+	while (!Session::getInstance()->lock())
+		;
+	while (!artist->isAlbumsLoaded()) {
+		Session::getInstance()->processEvents();
+	}
+	Session::getInstance()->unlock();
+
+	Logger::printOut(
+			"get artist albums, done browsing, waiting for all albums to load");
+
+//	while (!artist->isAlbumsLoaded()) {
+//	}
+
+	//add the similar artists item
+	if (artist->getArtists().size() > 0) {
+		CFileItemPtr pItem(new CFileItem(Settings::getInstance()->getSimilarArtistsString()));
+		CStdString path;
+		sp_link* link = sp_link_create_from_artist(spArtist);
+		char* uri = new char[256];
+		sp_link_as_string(link, uri, 256);
+		sp_link_release(link);
+		path.Format("musicdb://1/%s/", uri);
+		delete uri;
+		pItem->SetPath(path);
+		pItem->m_bIsFolder = true;
+		items.Add(pItem);
+		pItem->SetIconImage("DefaultMusicArtists.png");
+		pItem->SetProperty("fanart_image", Settings::getInstance()->getFanart());
+	}
+
+	//add the albums
+	vector<SxAlbum*> albums = artist->getAlbums();
+	for (unsigned int i = 0; i < albums.size(); i++) {
+		items.Add(Utils::SxAlbumToItem(albums[i]));
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getArtistAlbums(CFileItemList& items,
+		CStdString& artistStr) {
+	if (isReady()) {
+		sp_link *spLink = sp_link_create_from_string(artistStr);
+		if (!spLink)
+			return true;
+		sp_artist *spArtist = sp_link_as_artist(spLink);
+		if (!spArtist)
+			return true;
+
+		return getArtistAlbums(items, spArtist);
+
+		sp_link_release(spLink);
+		sp_artist_release(spArtist);
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getAllAlbums(CFileItemList& items,
+		CStdString& artistStr) {
+
+	Logger::printOut("get album");
+	if (isReady()) {
+		if (artistStr.IsEmpty()) {
+			//load all starred albums
+			PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+			StarredList* sl = ps->getStarredList();
+			if (sl == NULL)
+				return true;
+			if (!sl->isLoaded())
+				return true;
+			for (int i = 0; i < sl->getNumberOfAlbums(); i++) {
+				SxAlbum* album = sl->getAlbum(i);
+				//if its a multidisc we need to add them all
+				int discNumber = album->getNumberOfDiscs();
+				if (discNumber == 1)
+					items.Add(Utils::SxAlbumToItem(sl->getAlbum(i)));
+				else {
+					while (discNumber > 0) {
+						items.Add(Utils::SxAlbumToItem(sl->getAlbum(i), "", discNumber));
+						discNumber--;
+					}
+				}
+			}
+		} else {
+			//TODO do a small search for the artist and fetch the albums from the result
+
+		}
+	}
+	return true;
+
+}
+
+bool Addon_music_spotify::GetTracks(CFileItemList& items, CStdString& path,
+		CStdString artistName, int albumId) {
+	Logger::printOut("get tracks");
+	CURL url(path);
+	CStdString uri = url.GetFileNameWithoutPath();
+	//the path will look something like this "musicdb://2/spotify:artist:0LcJLqbBmaGUft1e9Mm8HV/-1/"
+	//if we are trying to show all tracks for a spotify artist, we cant use the params becouse they are only integers.
+	CURL url2(path.Left(path.GetLength() - 3));
+	CStdString artist = url2.GetFileNameWithoutPath();
+
+	if (uri.Left(13).Equals("spotify:album")) {
+		return getAlbumTracks(items, uri);
+	} else if (artist.Left(14).Equals("spotify:artist")) {
+		return getArtistTracks(items, artist);
+	} else if (uri.Left(16).Equals("spotify:playlist")) {
+		uri.Delete(0, 17);
+		return getPlaylistTracks(items, atoi(uri));
+	} else if (artist.Left(15).Equals("spotify:toplist")) {
+		return g_spotify->getTopListTracks(items);
+	} else if (uri.Left(13).Equals("spotify:radio")) {
+		return getRadioTracks(items, atoi(uri.Right(1)));
+	} else if (uri.Left(13).Equals("spotify:track")) {
+		return getAlbumTracksFromTrack(items, uri);
+	} else if (albumId == -1) {
+		return getAllTracks(items, artistName);
+	}
+	return true;
+}
+bool Addon_music_spotify::GetOneTrack(CFileItemList& items, CStdString& path) {
+  Logger::printOut("get one track");
+  CURL url(path);
+  CStdString uri = url.GetFileNameWithoutPath();
+  if (uri.Left(13).Equals("spotify:track")) {
+      if (isReady()) {
+      sp_link *spLink = sp_link_create_from_string(uri.Left(uri.Find('.')));
+      if (!spLink) return false;
+      sp_track *spTrack = sp_link_as_track(spLink);
+      if (spTrack) {
+        SxTrack* track = TrackStore::getInstance()->getTrack(spTrack);
+        items.Add(Utils::SxTrackToItem(track));
+        sp_track_release(spTrack);
+      }
+      sp_link_release(spLink);
+    } 
+  }
+  return true;  
+}
+
+bool Addon_music_spotify::getAlbumTracksFromTrack(CFileItemList& items,
+		CStdString& uri) {
+	if (isReady()) {
+		sp_link *spLink = sp_link_create_from_string(uri.Left(uri.Find('.')));
+		if (!spLink)
+			return false;
+		sp_track *spTrack = sp_link_as_track(spLink);
+		if (spTrack) {
+			sp_album* spAlbum = sp_track_album(spTrack);
+			if (spAlbum) {
+				// TODO find out on what disc the track is if its a multidisc
+				SxAlbum* album = AlbumStore::getInstance()->getAlbum(spAlbum, true);
+
+				// this is NOT nice, might result in a race condition... fix later
+				while (!album->isLoaded()) {
+					Session::getInstance()->processEvents();
+				}
+				vector<SxTrack*> tracks = album->getTracks();
+				for (unsigned int i = 0; i < tracks.size(); i++) {
+					items.Add(Utils::SxTrackToItem(tracks[i]));
+				}
+			}
+			sp_track_release(spTrack);
+		}
+		sp_link_release(spLink);
+	}
+}
+
+bool Addon_music_spotify::getAlbumTracks(CFileItemList& items,
+		CStdString& path) {
+	if (isReady()) {
+		//lets split the string to get the album uri and the disc number
+		CStdString uri = path.Left(path.Find('#'));
+		CStdString discStr = path.Right(path.GetLength() - path.Find('#') - 1);
+		//Logger::printOut(discStr.c_str());
+		int disc = atoi(discStr.c_str());
+
+		//0 means its not a multidisc, so we need to change it to 1
+		if (disc == 0)
+			disc = 1;
+		sp_link *spLink = sp_link_create_from_string(uri);
+		sp_album *spAlbum = sp_link_as_album(spLink);
+		SxAlbum* salbum = AlbumStore::getInstance()->getAlbum(spAlbum, true);
+		vector<SxTrack*> tracks = salbum->getTracks();
+		for (unsigned int i = 0; i < tracks.size(); i++) {
+			if (disc == tracks[i]->getDisc())
+				items.Add(Utils::SxTrackToItem(tracks[i]));
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getArtistTracks(CFileItemList& items,
+		CStdString& path) {
+	Logger::printOut("get artist tracks");
+	if (isReady()) {
+		sp_link *spLink = sp_link_create_from_string(path);
+		if (!spLink)
+			return true;
+		sp_artist *spArtist = sp_link_as_artist(spLink);
+		if (!spArtist)
+			return true;
+		SxArtist* artist = ArtistStore::getInstance()->getArtist(spArtist, true);
+		if (!artist)
+			return true;
+
+		//if its the first call the artist might not be loaded yet, the artist will update the view when its ready
+		artist->doLoadTracksAndAlbums();
+		while (!artist->isTracksLoaded())
+			;
+		vector<SxTrack*> tracks = artist->getTracks();
+		for (unsigned int i = 0; i < tracks.size(); i++) {
+			items.Add(Utils::SxTrackToItem(tracks[i]));
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getAllTracks(CFileItemList& items, CStdString& path) {
+	Logger::printOut("get tracks");
+	Logger::printOut(path);
+	if (isReady()) {
+		if (path.IsEmpty()) {
+			//load the starred tracks
+			PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+			StarredList* sl = ps->getStarredList();
+
+			if (sl == NULL)
+				return true;
+			if (!sl->isLoaded())
+				return true;
+
+			for (int i = 0; i < sl->getNumberOfTracks(); i++) {
+				items.Add(Utils::SxTrackToItem(sl->getTrack(i)));
+			}
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getRadioTracks(CFileItemList& items, int radio) {
+	Logger::printOut("get radio tracks");
+	if (isReady()) {
+		int lowestTrackNumber = RadioHandler::getInstance()->getLowestTrackNumber(
+				radio);
+		if (radio == 1 || radio == 2) {
+			vector<SxTrack*> tracks = RadioHandler::getInstance()->getTracks(radio);
+			for (unsigned int i = 0; i < tracks.size(); i++) {
+				const CFileItemPtr pItem = Utils::SxTrackToItem(tracks[i], "",
+						i + lowestTrackNumber + 1);
+				CStdString path;
+				path.Format("%s%s%i%s%i", pItem->GetPath(), "radio#", radio, "#",
+						i + lowestTrackNumber);
+				pItem->SetPath(path);
+				items.Add(pItem);
+			}
+		}
+		return true;
+	}
+	return false;
+}
+
+bool Addon_music_spotify::GetArtists(CFileItemList& items, CStdString& path) {
+	CURL url(path);
+	CStdString uri = url.GetFileNameWithoutPath();
+	if (uri.Left(15).Equals("spotify:toplist")) {
+		getTopListArtists(items);
+	} else if (uri.Left(14).Equals("spotify:artist")) {
+		getArtistSimilarArtists(items, uri);
+	} else {
+		getAllArtists(items);
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getAllArtists(CFileItemList& items) {
+	Logger::printOut("get starred artists");
+	if (isReady()) {
+		PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+		StarredList* sl = ps->getStarredList();
+
+		if (sl == NULL)
+			return true;
+		if (!sl->isLoaded())
+			return true;
+
+		for (int i = 0; i < sl->getNumberOfArtists(); i++) {
+			items.Add(Utils::SxArtistToItem(sl->getArtist(i)));
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getArtistSimilarArtists(CFileItemList& items,
+		CStdString uri) {
+	Logger::printOut("get similar artists");
+	if (isReady()) {
+		sp_link *spLink = sp_link_create_from_string(uri);
+		if (!spLink)
+			return true;
+		sp_artist *spArtist = sp_link_as_artist(spLink);
+		if (!spArtist)
+			return true;
+		SxArtist* artist = ArtistStore::getInstance()->getArtist(spArtist, true);
+		if (!artist)
+			return true;
+
+		//if its the first call the artist might not be loaded yet, the artist will update the view when its ready
+		artist->doLoadTracksAndAlbums();
+		while (!artist->isTracksLoaded())
+			;
+		vector<SxArtist*> artists = artist->getArtists();
+		for (unsigned int i = 0; i < artists.size(); i++) {
+			items.Add(Utils::SxArtistToItem(artists[i]));
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getPlaylistTracks(CFileItemList& items, int index) {
+	Logger::printOut("get playlist tracks");
+	if (isReady()) {
+		PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+		SxPlaylist* pl = ps->getPlaylist(index);
+
+		for (int i = 0; i < pl->getNumberOfTracks(); i++) {
+			items.Add(Utils::SxTrackToItem(pl->getTrack(i), "", i + 1));
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::GetTopLists(CFileItemList& items) {
+	if (isReady()) {
+		Logger::printOut("get the toplist entry list");
+		TopLists* topLists = Session::getInstance()->getTopLists();
+
+		if (topLists == NULL || !topLists->isLoaded())
+			return true;
+
+		//add the tracks entry
+		CFileItemPtr pItem(new CFileItem(Settings::getInstance()->getTopListTrackString()));
+		CStdString path;
+		path.Format("musicdb://2/spotify:toplist/-1/");
+		pItem->SetPath(path);
+		pItem->m_bIsFolder = true;
+		items.Add(pItem);
+		pItem->SetProperty("fanart_image", Settings::getInstance()->getFanart());
+
+		//add the album entry
+		CFileItemPtr pItem2(new CFileItem(Settings::getInstance()->getTopListAlbumString()));
+		path.Format("musicdb://2/spotify:toplist");
+		pItem2->SetPath(path);
+		pItem2->m_bIsFolder = true;
+		items.Add(pItem2);
+		pItem2->SetProperty("fanart_image", Settings::getInstance()->getFanart());
+
+		//add the artist entry
+		CFileItemPtr pItem3(new CFileItem(Settings::getInstance()->getTopListArtistString()));
+		path.Format("musicdb://1/spotify:toplist");
+		pItem3->SetPath(path);
+		pItem3->m_bIsFolder = true;
+		items.Add(pItem3);
+		pItem3->SetProperty("fanart_image", Settings::getInstance()->getFanart());
+	}
+	return true;
+}
+
+bool Addon_music_spotify::GetCustomEntries(CFileItemList& items) {
+	if (isReady()) {
+		//add radio 1
+		CStdString name;
+		name.Format("%s%s", Settings::getInstance()->getRadioPrefixString(),
+				Settings::getInstance()->getRadio1Name());
+		CFileItemPtr pItem(new CFileItem(name));
+		CStdString path;
+		path.Format("musicdb://3/spotify:radio:1/");
+		pItem->SetPath(path);
+		pItem->m_bIsFolder = true;
+		items.Add(pItem);
+		pItem->SetProperty("fanart_image", Settings::getInstance()->getFanart());
+
+		//add radio 2
+		name.Format("%s%s", Settings::getInstance()->getRadioPrefixString(),
+				Settings::getInstance()->getRadio2Name());
+		CFileItemPtr pItem2(new CFileItem(name));
+		path.Format("musicdb://3/spotify:radio:2/");
+		pItem2->SetPath(path);
+		pItem2->m_bIsFolder = true;
+		items.Add(pItem2);
+		pItem2->SetProperty("fanart_image", Settings::getInstance()->getFanart());
+
+	}
+	return true;
+}
+
+bool Addon_music_spotify::GetContextButtons(CFileItemPtr& item,
+		CContextButtons &buttons) {
+	if (isReady()) {
+		CURL url(item->GetPath());
+		CStdString uri = url.GetFileNameWithoutPath();
+		//the path will look something like this "musicdb://2/spotify:artist:0LcJLqbBmaGUft1e9Mm8HV/-1/"
+		//if we are trying to show all tracks for a spotify artist, we cant use the params becouse they are only integers.
+
+		if (uri.Left(13).Equals("spotify:album")) {
+			uri = uri.Left(uri.Find('#'));
+			sp_link *spLink = sp_link_create_from_string(uri);
+			sp_album *spAlbum = sp_link_as_album(spLink);
+			SxAlbum* salbum = AlbumStore::getInstance()->getAlbum(spAlbum, true);
+			if (salbum) {
+				buttons.Add(
+						CONTEXT_BUTTON_SPOTIFY_TOGGLE_STAR_ALBUM,
+						salbum->isStarred() ?
+								Settings::getInstance()->getUnstarAlbumString() :
+								Settings::getInstance()->getStarAlbumString());
+				AlbumStore::getInstance()->removeAlbum(salbum);
+				buttons.Add(CONTEXT_BUTTON_SPOTIFY_BROWSE_ARTIST,
+						Settings::getInstance()->getBrowseArtistString());
+			}
+			sp_link_release(spLink);
+			sp_album_release(spAlbum);
+		} else if (uri.Left(13).Equals("spotify:track")) {
+			uri = uri.Left(uri.Find('.'));
+			Logger::printOut(uri);
+			sp_link *spLink = sp_link_create_from_string(uri);
+			sp_track* spTrack = sp_link_as_track(spLink);
+			buttons.Add(
+					CONTEXT_BUTTON_SPOTIFY_TOGGLE_STAR_TRACK,
+					sp_track_is_starred(Session::getInstance()->getSpSession(), spTrack) ?
+							Settings::getInstance()->getUnstarTrackString() :
+							Settings::getInstance()->getStarTrackString());
+			buttons.Add(CONTEXT_BUTTON_SPOTIFY_BROWSE_ALBUM,
+					Settings::getInstance()->getBrowseAlbumString());
+			buttons.Add(CONTEXT_BUTTON_SPOTIFY_BROWSE_ARTIST,
+					Settings::getInstance()->getBrowseArtistString());
+
+			//this is unstable as it is now... find a solution later
+
+			SxAlbum* salbum = AlbumStore::getInstance()->getAlbum(
+					sp_track_album(spTrack), true);
+			if (salbum) {
+				while (!Session::getInstance()->lock())
+					;
+				while (!salbum->isLoaded()) {
+					Session::getInstance()->processEvents();
+				}
+				Session::getInstance()->unlock();
+				buttons.Add(
+						CONTEXT_BUTTON_SPOTIFY_TOGGLE_STAR_ALBUM,
+						salbum->isStarred() ?
+								Settings::getInstance()->getUnstarAlbumString() :
+								Settings::getInstance()->getStarAlbumString());
+				AlbumStore::getInstance()->removeAlbum(salbum);
+			}
+
+			sp_track_release(spTrack);
+			sp_link_release(spLink);
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::ToggleStarTrack(CFileItemPtr& item) {
+	if (isReady()) {
+		CURL url(item->GetPath());
+		CStdString uri = url.GetFileNameWithoutPath();
+		uri = uri.Left(uri.Find('.'));
+		Logger::printOut(uri);
+		sp_link *spLink = sp_link_create_from_string(uri);
+		sp_track* spTrack = sp_link_as_track(spLink);
+		sp_track_set_starred(Session::getInstance()->getSpSession(), &spTrack, 1,
+				!sp_track_is_starred(Session::getInstance()->getSpSession(), spTrack));
+		sp_link_release(spLink);
+		sp_track_release(spTrack);
+	}
+	return true;
+}
+
+bool Addon_music_spotify::ToggleStarAlbum(CFileItemPtr& item) {
+	if (isReady()) {
+		Logger::printOut("toggle album star addon");
+		CURL url(item->GetPath());
+		CStdString uri = url.GetFileNameWithoutPath();
+
+		sp_album *spAlbum = NULL;
+		if (uri.Left(13).Equals("spotify:album")) {
+			uri = uri.Left(uri.Find('#'));
+			sp_link* spLink = sp_link_create_from_string(uri);
+			spAlbum = sp_link_as_album(spLink);
+			sp_link_release(spLink);
+		} else if (uri.Left(13).Equals("spotify:track")) {
+			sp_link *spLink = sp_link_create_from_string(uri.Left(uri.Find('.')));
+			if (!spLink)
+				return true;
+			sp_track *spTrack = sp_link_as_track(spLink);
+			sp_link_release(spLink);
+			if (spTrack) {
+				spAlbum = sp_track_album(spTrack);
+			}
+			sp_track_release(spTrack);
+		} else {
+			return true;
+		}
+		SxAlbum* salbum = AlbumStore::getInstance()->getAlbum(spAlbum, true);
+		if (salbum){
+			while (!Session::getInstance()->lock())
+				;
+			while (!salbum->isLoaded()) {
+				Session::getInstance()->processEvents();
+			}
+			Session::getInstance()->unlock();
+			salbum->toggleStar();
+			AlbumStore::getInstance()->removeAlbum(salbum);
+		}
+		sp_album_release(spAlbum);
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getTopListArtists(CFileItemList& items) {
+	Logger::printOut("get toplist artists");
+	if (isReady()) {
+		PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+		TopLists* tl = ps->getTopLists();
+
+		if (!tl->isArtistsLoaded())
+			tl->reLoadArtists();
+
+		while (!tl->isArtistsLoaded()) {
+			//Session::getInstance()->processEvents();
+		}
+
+		vector<SxArtist*> artists = tl->getArtists();
+		for (unsigned int i = 0; i < artists.size(); i++) {
+			items.Add(Utils::SxArtistToItem(artists[i]));
+		}
+
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getTopListAlbums(CFileItemList& items) {
+	Logger::printOut("get toplist albums");
+	if (isReady()) {
+		PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+		TopLists* tl = ps->getTopLists();
+
+		if (!tl->isAlbumsLoaded())
+			tl->reLoadAlbums();
+
+		while (!tl->isAlbumsLoaded()) {
+			// Session::getInstance()->processEvents();
+		}
+
+		vector<SxAlbum*> albums = tl->getAlbums();
+		for (unsigned int i = 0; i < albums.size(); i++) {
+			items.Add(Utils::SxAlbumToItem(albums[i]));
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::getTopListTracks(CFileItemList& items) {
+	Logger::printOut("get toplist tracks");
+	if (isReady()) {
+		PlaylistStore* ps = Session::getInstance()->getPlaylistStore();
+		TopLists* tl = ps->getTopLists();
+
+		if (!tl->isTracksLoaded())
+			tl->reLoadTracks();
+
+		while (!tl->isTracksLoaded()) {
+			//Session::getInstance()->processEvents();
+		}
+
+		vector<SxTrack*> tracks = tl->getTracks();
+		for (unsigned int i = 0; i < tracks.size(); i++) {
+			items.Add(Utils::SxTrackToItem(tracks[i], "", i + 1));
+		}
+	}
+	return true;
+}
+
+bool Addon_music_spotify::Search(CStdString query, CFileItemList& items) {
+//do the search, if we are already searching and are to fetch results this want do anything
+	Logger::printOut("new search");
+	if (isReady()) {
+		if (!SearchHandler::getInstance()->search(query)) {
+			CStdString albumPrefix;
+			albumPrefix.Format("[%s] ", g_localizeStrings.Get(558).c_str());
+			Logger::printOut("search fetch albums");
+			vector<SxAlbum*> albums = SearchHandler::getInstance()->getAlbumResults();
+			for (unsigned int i = 0; i < albums.size(); i++) {
+				//if its a multidisc we need to add them all
+				int discNumber = albums[i]->getNumberOfDiscs();
+				if (discNumber == 1) {
+					items.Add(Utils::SxAlbumToItem(albums[i], albumPrefix));
+				} else {
+					while (discNumber > 0) {
+						items.Add(Utils::SxAlbumToItem(albums[i], albumPrefix, discNumber));
+						discNumber--;
+					}
+				}
+			}
+			Logger::printOut("search fetch tracks");
+			vector<SxTrack*> tracks = SearchHandler::getInstance()->getTrackResults();
+			for (unsigned int i = 0; i < tracks.size(); i++)
+				items.Add(Utils::SxTrackToItem(tracks[i]));
+
+			CStdString artistPrefix;
+			artistPrefix.Format("[%s] ", g_localizeStrings.Get(557).c_str());
+
+			Logger::printOut("search fetch artists");
+			vector<SxArtist*> artists =
+					SearchHandler::getInstance()->getArtistResults();
+			for (unsigned int i = 0; i < artists.size(); i++)
+				items.Add(Utils::SxArtistToItem(artists[i], artistPrefix));
+		}
+	}
+	return true;
+}
+
diff --git a/xbmc/music/spotyXBMC/Addon.music.spotify.h b/xbmc/music/spotyXBMC/Addon.music.spotify.h
new file mode 100644
index 0000000..38eac7b
--- /dev/null
+++ b/xbmc/music/spotyXBMC/Addon.music.spotify.h
@@ -0,0 +1,84 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+               2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef ADDONMUSICSPOTIFY_H_
+#define ADDONMUSICSPOTIFY_H_
+
+#include "track/SxTrack.h"
+#include "artist/SxArtist.h"
+#include "session/Session.h"
+#include <vector>
+#include <string>
+#include "FileItem.h"
+#include "../../cores/paplayer/ICodec.h"
+#include "../../dialogs/GUIDialogContextMenu.h"
+
+using namespace std;
+using namespace addon_music_spotify;
+
+class Addon_music_spotify {
+public:
+  Addon_music_spotify();
+  virtual ~Addon_music_spotify();
+
+  bool enable(bool enable);
+  bool isEnabled() {
+    return m_isEnabled;
+  }
+  bool isReady();
+
+  bool GetTracks(CFileItemList& items, CStdString& path, CStdString artistName, int albumId);
+  bool GetOneTrack(CFileItemList& items, CStdString& path);
+  bool GetAlbums(CFileItemList& items, CStdString& path, CStdString artistName);
+  bool GetArtists(CFileItemList& items, CStdString& path);
+  bool GetPlaylists(CFileItemList& items);
+  bool GetTopLists(CFileItemList& items);
+  bool GetCustomEntries(CFileItemList& items);
+
+  // Context menu related functions
+  bool GetContextButtons(CFileItemPtr& item, CContextButtons &buttons);
+  bool ToggleStarTrack(CFileItemPtr& item);
+  bool ToggleStarAlbum(CFileItemPtr& item);
+
+  bool Search(CStdString query, CFileItemList& items);
+
+private:
+  bool m_isEnabled;
+  bool getAlbumTracksFromTrack(CFileItemList& items, CStdString& trackUri);
+  bool getAlbumTracks(CFileItemList& items, CStdString& path);
+  bool getArtistTracks(CFileItemList& items, CStdString& path);
+  bool getAllTracks(CFileItemList& items, CStdString& path);
+  bool getPlaylistTracks(CFileItemList& items, int index);
+  bool getTopListTracks(CFileItemList& items);
+  bool getRadioTracks(CFileItemList& items, int radio);
+
+  bool getAllAlbums(CFileItemList& items, CStdString& path);
+  bool getArtistAlbums(CFileItemList& items, CStdString& path);
+  bool getArtistAlbums(CFileItemList& items, sp_artist* spArtist);
+  bool getTopListAlbums(CFileItemList& items);
+
+  bool getAllArtists(CFileItemList& items);
+  bool getArtistSimilarArtists(CFileItemList& items, CStdString uri);
+  bool getTopListArtists(CFileItemList& items);
+};
+extern Addon_music_spotify* g_spotify;
+#endif /* ADDONMUSICSPOTIFY_H_ */
diff --git a/xbmc/music/spotyXBMC/Logger.cpp b/xbmc/music/spotyXBMC/Logger.cpp
new file mode 100644
index 0000000..29b2c14
--- /dev/null
+++ b/xbmc/music/spotyXBMC/Logger.cpp
@@ -0,0 +1,36 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "Logger.h"
+
+namespace addon_music_spotify {
+
+  Logger::Logger() {
+    // TODO Auto-generated constructor stub
+
+  }
+
+  Logger::~Logger() {
+    // TODO Auto-generated destructor stub
+  }
+
+} /* namespace addon_music_spotify */
+
diff --git a/xbmc/music/spotyXBMC/Logger.h b/xbmc/music/spotyXBMC/Logger.h
new file mode 100644
index 0000000..8148649
--- /dev/null
+++ b/xbmc/music/spotyXBMC/Logger.h
@@ -0,0 +1,92 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef LOG_H_
+#define LOG_H_
+
+#include <iostream>
+#include <string>
+#include "../../utils/log.h"
+#include <fstream>
+#include "SxSettings.h"
+
+namespace addon_music_spotify {
+
+  using namespace std;
+
+  class Logger {
+  public:
+    Logger();
+    virtual ~Logger();
+    static void printOut(char* text) {
+	  CLog::Log(LOGDEBUG, "spotifylog: %s", text);
+      cout << text << "\n";
+      if (Settings::getInstance()->saveLogToFile()){
+        string path = Settings::getInstance()->getCachePath() + "log.txt";
+        ofstream file(path.c_str(), ios::app);
+        if (file.is_open()) {
+      	  file << text << "\n";
+        }
+        file.close();
+      }
+    }
+    static void printOut(const char* text) {
+      CLog::Log(LOGDEBUG, "spotifylog: %s", text);
+      cout << text << "\n";
+      if (Settings::getInstance()->saveLogToFile()){
+        string path = Settings::getInstance()->getCachePath() + "log.txt";
+        ofstream file(path.c_str(), ios::app);
+        if (file.is_open()) {
+      	  file << text << "\n";
+        }
+        file.close();
+      }
+    }
+    static void printOut(char text) {
+      CLog::Log(LOGDEBUG, "spotifylog: %c", text);
+      cout << text << "\n";
+      if (Settings::getInstance()->saveLogToFile()){
+        string path = Settings::getInstance()->getCachePath() + "log.txt";
+        ofstream file(path.c_str(), ios::app);
+        if (file.is_open()) {
+      	  file << text << "\n";
+        }
+        file.close();
+      }
+    }
+    static void printOut(string text) {
+    	CLog::Log(LOGDEBUG, "spotifylog: %s", text.c_str());
+      cout << text << "\n";
+      if (Settings::getInstance()->saveLogToFile()){
+        string path = Settings::getInstance()->getCachePath() + "log.txt";
+        ofstream file(path.c_str(), ios::app);
+        if (file.is_open()) {
+      	  file << text << "\n";
+        }
+        file.close();
+      }
+    }
+
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* LOG_H_ */
+
diff --git a/xbmc/music/spotyXBMC/SxSettings.cpp b/xbmc/music/spotyXBMC/SxSettings.cpp
new file mode 100644
index 0000000..f21f7a2
--- /dev/null
+++ b/xbmc/music/spotyXBMC/SxSettings.cpp
@@ -0,0 +1,170 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "SxSettings.h"
+#include "URL.h"
+
+namespace addon_music_spotify {
+
+	Settings* Settings::m_instance = 0;
+	Settings *Settings::getInstance() {
+		return m_instance ? m_instance : (m_instance = new Settings);
+	}
+
+	bool Settings::init(){
+		ADDON::AddonPtr addon;
+		const CStdString pluginId = "plugin.music.spotyXBMC";
+		CStdString value = "";
+
+		if (ADDON::CAddonMgr::Get().GetAddon(pluginId, addon)) {
+		  ADDON::CAddonMgr::Get().LoadAddonDescription(pluginId, addon);
+
+		  m_enabled = addon->GetSetting("enable") == "true";
+		  if (!m_enabled)
+		  	return false;
+		  m_userName =  addon->GetSetting("username");
+		  m_password = addon->GetSetting("password");
+
+		  m_cachePath = CSpecialProtocol::TranslatePath("special://temp/spotify/cache/");
+		  m_thumbPath = CSpecialProtocol::TranslatePath("special://temp/spotify/thumbs/");
+		  m_artistThumbPath = CSpecialProtocol::TranslatePath("special://temp/spotify/artistthumbs/");
+
+		  m_useHighBitrate = addon->GetSetting("highBitrate") == "true";
+		  m_useNormalization = addon->GetSetting("normalization") == "true";
+
+		  if (addon->GetSetting("enablefanart") == "true"){
+		    if (addon->GetSetting("customfanart") == "true"){
+		      m_fanart = addon->GetSetting("fanart");
+		    }else{
+		      m_fanart = addon->FanArt();
+		    }
+		  }
+
+		  m_useHTFanarts = addon->GetSetting("htfanart") == "true";
+		  m_useHTArtistThumbs =  addon->GetSetting("htartistthumb") == "true";
+		  m_startDelay = 1000 * atoi(addon->GetSetting("delay"));
+		  m_saveLogToFile =  addon->GetSetting("logtofile") == "true";
+		  m_searchNumberArtists = 10 * atoi(addon->GetSetting("searchNoArtists")) + 1;
+		  m_searchNumberAlbums = 10 * atoi(addon->GetSetting("searchNoAlbums")) + 1;
+		  m_searchNumberTracks = 10 * atoi(addon->GetSetting("searchNoTracks")) + 1;
+		  m_preloadArtistDetails = addon->GetSetting("preloadArtistDetails") == "true";
+
+		  int i = atoi(addon->GetSetting("artistNoArtists")) + 1;
+		  if (i == 11) m_artistNumberTracks = -1;
+		  m_artistNumberArtists = 10 * i;
+
+	    i = atoi(addon->GetSetting("artistNoAlbums")) + 1;
+		  if (i == 11) m_artistNumberAlbums = -1;
+		  m_artistNumberAlbums = 10 * i;
+
+		  i = atoi(addon->GetSetting("artistNoTracks")) + 1;
+		  if (i == 11) m_artistNumberTracks = -1;
+		  m_artistNumberTracks = 10 * i;
+
+		  m_radio1Name = addon->GetSetting("radio1name");
+		  m_radio1From = 1900 + (10 * (4 + atoi(addon->GetSetting("radio1from"))));
+		  m_radio1To = 1900 + (10 * (4 + atoi(addon->GetSetting("radio1to"))));
+
+		  m_radio1Genres = getRadioGenres(addon, 1);
+
+		  m_radio2Name = addon->GetSetting("radio2name");
+		  m_radio2From = 1900 + (10 * (4 + atoi(addon->GetSetting("radio2from"))));
+		  m_radio2To = 1900 + (10 * (4 + atoi(addon->GetSetting("radio2to"))));
+
+		  m_radio2Genres = getRadioGenres(addon, 2);
+
+		  m_radioNumberTracks = atoi(addon->GetSetting("radioNoTracks")) + 3;
+		  m_toplistRegionEverywhere = addon->GetSetting("topListRegion") == "1";
+		  m_preloadTopLists = addon->GetSetting("preloadToplists") == "true";
+		  m_byString = addon->GetString(30002);
+		  m_topListArtistString = addon->GetString(30500);
+		  m_topListAlbumString = addon->GetString(30501);
+		  m_topListTrackString = addon->GetString(30502);
+		  m_radioPrefixString = addon->GetString(30503);
+		  m_similarArtistsString = addon->GetString(30504);
+		  m_inboxString = addon->GetString(30505);
+		  m_starTrackString = addon->GetString(30600);
+		  m_unstarTrackString = addon->GetString(30601);
+		  m_starAlbumString = addon->GetString(30602);
+		  m_unstarAlbumString = addon->GetString(30603);
+		  m_browseAlbumString = addon->GetString(30604);
+		  m_browseArtistString = addon->GetString(30605);
+
+		  return true;
+		}
+		return false;
+	}
+
+	void Settings::deInit(){
+		delete m_instance;
+	}
+
+  Settings::Settings() {
+  }
+
+  Settings::~Settings() {
+  }
+
+  sp_radio_genre Settings::getRadioGenres(ADDON::AddonPtr addon, int radio) {
+
+  	CStdString radioC;
+  	radioC.Format("radio%igenre", radio);
+
+    struct {
+      bool enable;
+      int id;
+    } radiogenres[] = {
+    		{ addon->GetSetting(radioC + "1") == "true", 0x1 },
+    		{ addon->GetSetting(radioC + "2") == "true", 0x2 },
+    		{ addon->GetSetting(radioC + "3") == "true", 0x4 },
+    		{ addon->GetSetting(radioC + "4") == "true", 0x8 },
+    		{ addon->GetSetting(radioC + "5") == "true", 0x10 },
+    		{ addon->GetSetting(radioC + "6") == "true", 0x20 },
+    		{ addon->GetSetting(radioC + "7") == "true", 0x40 },
+    		{ addon->GetSetting(radioC + "8") == "true", 0x80 },
+    		{ addon->GetSetting(radioC + "9") == "true", 0x100 },
+    		{ addon->GetSetting(radioC + "10") == "true", 0x200 },
+    		{ addon->GetSetting(radioC + "11") == "true", 0x400 },
+    		{ addon->GetSetting(radioC + "12") == "true", 0x800 },
+    		{ addon->GetSetting(radioC + "13") == "true", 0x1000 },
+    		{ addon->GetSetting(radioC + "14") == "true", 0x2000 },
+    		{ addon->GetSetting(radioC + "15") == "true", 0x4000 },
+    		{ addon->GetSetting(radioC + "16") == "true", 0x8000 },
+    		{ addon->GetSetting(radioC + "17") == "true", 0x10000 },
+    		{ addon->GetSetting(radioC + "18") == "true", 0x20000 },
+			{ addon->GetSetting(radioC + "19") == "true", 0x40000 },
+    		{ addon->GetSetting(radioC + "20") == "true", 0x80000 },
+    		{ addon->GetSetting(radioC + "21") == "true", 0x100000 },
+    		{ addon->GetSetting(radioC + "22") == "true", 0x200000 },
+    		{ addon->GetSetting(radioC + "23") == "true", 0x400000 },
+    		{ addon->GetSetting(radioC + "24") == "true", 0x800000 },
+    		{ addon->GetSetting(radioC + "25") == "true", 0x1000000 },
+    		{ addon->GetSetting(radioC + "26") == "true", 0x2000000 },
+    		{ addon->GetSetting(radioC + "27") == "true", 0x4000000 },
+    };
+
+    int mask = 0;
+    for (unsigned int i = 0; i < sizeof(radiogenres) / sizeof(radiogenres[0]); i++)
+      if (radiogenres[i].enable) mask |= radiogenres[i].id;
+
+    return (sp_radio_genre) mask;
+  }
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/SxSettings.h b/xbmc/music/spotyXBMC/SxSettings.h
new file mode 100644
index 0000000..3cb0ac9
--- /dev/null
+++ b/xbmc/music/spotyXBMC/SxSettings.h
@@ -0,0 +1,274 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SXSETTINGS_H_
+#define SXSETTINGS_H_
+
+#include <libspotify/api.h>
+#include "addons/Addon.h"
+#include "addons/AddonManager.h"
+#include "filesystem/Directory.h"
+#include "filesystem/SpecialProtocol.h"
+
+namespace addon_music_spotify {
+
+  using namespace std;
+
+  class Settings {
+  public:
+
+    static Settings *getInstance();
+    bool init();
+    void deInit();
+
+    bool enabled() {
+      return m_enabled;
+    }
+
+    CStdString getUserName() {
+      return m_userName;
+    }
+
+    CStdString getPassword() {
+      return m_password;
+    }
+
+    CStdString getCachePath() {
+    	return m_cachePath;
+    }
+
+    CStdString getThumbPath() {
+    	return m_thumbPath;
+    }
+
+    CStdString getArtistThumbPath() {
+    	return m_artistThumbPath;
+    }
+
+    bool useHighBitrate() {
+      return m_useHighBitrate;
+    }
+    bool useNormalization(){
+    	return m_useNormalization;
+    }
+
+    CStdString getFanart() {
+    	return m_fanart;
+    }
+
+    bool getUseHTFanarts() {
+      return m_useHTFanarts;
+    }
+    bool getUseHTArtistThumbs() {
+      return m_useHTArtistThumbs;
+    }
+
+    int getStartDelay() {
+      return m_startDelay;
+    }
+
+    bool saveLogToFile() {
+      return m_saveLogToFile;
+    }
+
+    int getSearchNumberArtists() {
+      return m_searchNumberArtists;
+    }
+
+    int getSearchNumberAlbums() {
+      return m_searchNumberAlbums;
+    }
+
+    int getSearchNumberTracks() {
+      return m_searchNumberTracks;
+    }
+
+    bool getPreloadArtistDetails() {
+      return m_preloadArtistDetails;
+    }
+
+    int getArtistNumberArtists() {
+    	return m_artistNumberArtists;
+    }
+
+    int getArtistNumberAlbums() {
+    	return m_artistNumberAlbums;
+    }
+
+    int getArtistNumberTracks() {
+    	return m_artistNumberTracks;
+    }
+
+    CStdString getRadio1Name() {
+      return m_radio1Name;
+    }
+
+    int getRadio1From() {
+      return m_radio1From;
+    }
+
+    int getRadio1To() {
+      return m_radio1To;
+    }
+
+    sp_radio_genre getRadio1Genres() {
+    	return m_radio1Genres;
+    }
+
+    CStdString getRadio2Name() {
+      return m_radio2Name;
+    }
+
+    int getRadio2From() {
+      return m_radio2From;
+    }
+
+    int getRadio2To() {
+      return m_radio2To;
+    }
+
+    sp_radio_genre getRadio2Genres() {
+    	return m_radio2Genres;
+    }
+
+    int getRadioNumberTracks() {
+      return m_radioNumberTracks;
+    }
+
+    bool toplistRegionEverywhere() {
+      return m_toplistRegionEverywhere;
+    }
+
+    bool getPreloadTopLists() {
+      return m_preloadTopLists;
+    }
+
+    CStdString getByString() {
+      return m_byString;
+    }
+
+    CStdString getTopListArtistString() {
+      return m_topListArtistString;
+    }
+
+    CStdString getTopListAlbumString() {
+      return m_topListAlbumString;
+    }
+
+    CStdString getTopListTrackString() {
+      return m_topListTrackString;
+    }
+
+    CStdString getRadioPrefixString() {
+      return m_radioPrefixString;
+    }
+
+    CStdString getSimilarArtistsString() {
+      return m_similarArtistsString;
+    }
+
+    CStdString getInboxString() {
+      return m_inboxString;
+    }
+
+    CStdString getStarTrackString() {
+      return m_starTrackString;
+    }
+
+    CStdString getUnstarTrackString() {
+      return m_unstarTrackString;
+    }
+
+    CStdString getStarAlbumString() {
+      return m_starAlbumString;
+    }
+
+    CStdString getUnstarAlbumString() {
+      return m_unstarAlbumString;
+    }
+
+    CStdString getBrowseAlbumString() {
+      return m_browseAlbumString;
+    }
+
+    CStdString getBrowseArtistString() {
+      return m_browseArtistString;
+    }
+
+  private:
+    bool m_enabled;
+    bool m_useHighBitrate;
+    bool m_useNormalization;
+    bool m_useHTFanarts;
+    bool m_useHTArtistThumbs;
+    bool m_saveLogToFile;
+    bool m_preloadArtistDetails;
+    bool m_toplistRegionEverywhere;
+    bool m_preloadTopLists;
+
+    int m_startDelay;
+    int m_searchNumberArtists;
+    int m_searchNumberAlbums;
+    int m_searchNumberTracks;
+    int m_radio1From;
+    int m_radio1To;
+    int m_radio2From;
+    int m_radio2To;
+    int m_radioNumberTracks;
+    int m_artistNumberArtists;
+    int m_artistNumberAlbums;
+    int m_artistNumberTracks;
+
+    sp_radio_genre m_radio1Genres;
+    sp_radio_genre m_radio2Genres;
+
+    CStdString m_userName;
+    CStdString m_password;
+    CStdString m_cachePath;
+    CStdString m_thumbPath;
+    CStdString m_artistThumbPath;
+    CStdString m_byString;
+    CStdString m_fanart;
+    CStdString m_radio1Name;
+    CStdString m_radio2Name;
+    CStdString m_topListArtistString;
+    CStdString m_topListAlbumString;
+    CStdString m_topListTrackString;
+    CStdString m_radioPrefixString;
+    CStdString m_similarArtistsString;
+    CStdString m_inboxString;
+    CStdString m_starTrackString;
+    CStdString m_unstarTrackString;
+    CStdString m_starAlbumString;
+    CStdString m_unstarAlbumString;
+    CStdString m_browseAlbumString;
+    CStdString m_browseArtistString;
+
+    sp_radio_genre getRadioGenres(ADDON::AddonPtr addon, int radio);
+
+    Settings();
+    virtual ~Settings();
+
+    static Settings *m_instance;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SXSETTINGS_H_ */
diff --git a/xbmc/music/spotyXBMC/Utils.cpp b/xbmc/music/spotyXBMC/Utils.cpp
new file mode 100644
index 0000000..c3394f7
--- /dev/null
+++ b/xbmc/music/spotyXBMC/Utils.cpp
@@ -0,0 +1,240 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "Utils.h"
+#include "SxSettings.h"
+#include "settings/AdvancedSettings.h"
+#include "Logger.h"
+#include "../tags/MusicInfoTag.h"
+#include "../Album.h"
+#include "../Artist.h"
+#include "../../MediaSource.h"
+#include "Util.h"
+#include "filesystem/File.h"
+#include "filesystem/Directory.h"
+#include "guilib/GUIWindowManager.h"
+#include "GUIUserMessages.h"
+#include "utils/StringUtils.h"
+
+namespace addon_music_spotify {
+
+  Utils::Utils() {
+  }
+
+  Utils::~Utils() {
+  }
+
+  void Utils::cleanTags(string & text) {
+    bool done = false;
+    while (!done) {
+      // Look for start of tag:
+      size_t leftPos = text.find('<');
+      if (leftPos != string::npos) {
+        // See if tag close is in this line:
+        size_t rightPos = text.find('>');
+        if (rightPos == string::npos) {
+          done = true;
+          text.erase(leftPos);
+        } else
+          text.erase(leftPos, rightPos - leftPos + 1);
+      } else
+        done = true;
+    }
+  }
+
+  const CFileItemPtr Utils::SxAlbumToItem(SxAlbum *album, string prefix,
+      int discNumber) {
+    //wait for it to finish loading
+    while (!album->isLoaded()) {
+    }
+
+    CAlbum outAlbum;
+    outAlbum.artist =  StringUtils::Split(album->getAlbumArtistName(), g_advancedSettings.m_musicItemSeparator);
+    CStdString title;
+    if (discNumber != 0)
+      title.Format("%s%s %s %i", prefix, album->getAlbumName(), "disc",
+          discNumber);
+    else
+      title.Format("%s%s", prefix, album->getAlbumName());
+    outAlbum.strAlbum = title;
+    outAlbum.iYear = album->getAlbumYear();
+    outAlbum.strReview = album->getReview();
+    outAlbum.iRating = album->getAlbumRating();
+    CStdString path;
+    path.Format("musicdb://3/%s#%i", album->getUri(), discNumber);
+    const CFileItemPtr pItem(new CFileItem(path, outAlbum));
+    if (album->hasThumb())
+      pItem->SetArt("thumb",album->getThumb()->getPath());
+    pItem->SetProperty("fanart_image", *album->getFanart());
+    return pItem;
+  }
+
+  const CFileItemPtr Utils::SxTrackToItem(SxTrack* track, string prefix,
+      int trackNumber) {
+    //wait for it to finish loading
+    while (!track->isLoaded()) {
+    }
+    CSong outSong;
+    CStdString path;
+    path.Format("%s.spotify", track->getUri());
+    outSong.strFileName = path;
+    CStdString title;
+    title.Format("%s%s", prefix, track->getName());
+    outSong.strTitle = title;
+    outSong.iTrack = trackNumber == -1 ? track->getTrackNumber() : trackNumber;
+    outSong.iDuration = track->getDuration();
+    outSong.rating = track->getRating();
+    char ratingChar[3];
+    CStdString ratingStr; //= itoa(1 + (track->getRating() / 2), ratingChar, 10);
+    ratingStr.Format("%i", 1 + (track->getRating() / 2), ratingChar, 10);
+    //delete ratingChar;
+    outSong.rating = ratingStr[0];
+    outSong.artist =  StringUtils::Split(track->getArtistName(), g_advancedSettings.m_musicItemSeparator);
+    outSong.iYear = track->getYear();
+    outSong.strAlbum = track->getAlbumName();
+    outSong.albumArtist = StringUtils::Split(track->getAlbumArtistName(), g_advancedSettings.m_musicItemSeparator);
+    const CFileItemPtr pItem(new CFileItem(outSong));
+    if (track->hasThumb())
+      pItem->SetArt("thumb",track->getThumb()->getPath());
+    pItem->SetProperty("fanart_image", *track->getFanart());
+    return pItem;
+  }
+
+  const CFileItemPtr Utils::SxArtistToItem(SxArtist* artist, string prefix) {
+    //wait for it to finish loading
+    while (!artist->isLoaded()) {
+    }
+
+    CStdString path;
+    path.Format("musicdb://2/%s/", artist->getUri());
+
+    CFileItemPtr pItem(new CFileItem(path, true));
+    CStdString label;
+    label.Format("%s%s", prefix, artist->getArtistName());
+    pItem->SetLabel(label);
+    label.Format("A %s", artist->getArtistName());
+
+    pItem->GetMusicInfoTag()->SetTitle(label);
+    pItem->GetMusicInfoTag()->SetArtist(artist->getArtistName());
+
+    if (artist->hasThumb())
+      pItem->SetArt("thumb",artist->getThumb()->getPath());
+
+    pItem->SetIconImage("DefaultArtist.png");
+    pItem->SetProperty("fanart_image", *artist->getFanart());
+    pItem->SetProperty("artist_description", artist->getBio());
+
+    return pItem;
+  }
+
+  void Utils::createDir(CStdString path) {
+    XFILE::CDirectory::Create(path);
+
+  }
+
+  void Utils::removeDir(CStdString path) {
+    XFILE::CDirectory::Remove(path);
+  }
+
+  void Utils::removeFile(CStdString path) {
+    XFILE::CFile::Delete(path);
+  }
+
+  void Utils::updatePlaylists() {
+     CStdString path;
+     path.Format("special://musicplaylists/");
+     updatePath(path);
+   }
+
+   void Utils::updateMenu() {
+     Logger::printOut("updating main music menu");
+     CStdString path;
+     path.Format("");
+     updatePath(path);
+   }
+
+   void Utils::updatePlaylist(int index) {
+     //TODO FIX!
+     Logger::printOut("updating playlist view");
+     CStdString path;
+     path.Format("musicdb://3/spotify:playlist:%i/", index);
+     updatePath(path);
+   }
+
+   void Utils::updateAllArtists() {
+     Logger::printOut("updating all artists");
+     CStdString path;
+     path.Format("musicdb://2/");
+     updatePath(path);
+   }
+
+   void Utils::updateAllAlbums() {
+     Logger::printOut("updating all albums");
+     CStdString path;
+     path.Format("musicdb://3/");
+     updatePath(path);
+   }
+
+   void Utils::updateAllTracks() {
+     Logger::printOut("updating all tracks");
+     CStdString path;
+     path.Format("musicdb://4/");
+     updatePath(path);
+   }
+
+   void Utils::updateRadio(int radio) {
+     Logger::printOut("updating radio results");
+     CStdString path;
+     path.Format("musicdb://3/spotify:radio:%i/", radio);
+     updatePath(path);
+   }
+
+   void Utils::updateToplistMenu() {
+     Logger::printOut("updating toplistmenu");
+     CStdString path;
+     path.Format("musicdb://5/");
+     updatePath(path);
+   }
+
+   void Utils::updateSearchResults(string query) {
+     //we need to replace the whitespaces with %20
+
+     unsigned int pos = 0;
+     while (pos != string::npos) {
+       pos = query.find(' ');
+       if (pos != string::npos) {
+         query.replace(pos, 1, "%20");
+       }
+     }
+
+     Logger::printOut("updating search results");
+     CStdString path;
+     path.Format("musicsearch://%s/", query);
+     updatePath(path);
+   }
+
+   void Utils::updatePath(CStdString& path) {
+     CGUIMessage message(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_PATH);
+     message.SetStringParam(path);
+     g_windowManager.SendThreadMessage(message);
+   }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/Utils.h b/xbmc/music/spotyXBMC/Utils.h
new file mode 100644
index 0000000..b71bd70
--- /dev/null
+++ b/xbmc/music/spotyXBMC/Utils.h
@@ -0,0 +1,63 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef UTILS_H_
+#define UTILS_H_
+
+#include <string>
+#include "artist/SxArtist.h"
+#include "track/SxTrack.h"
+#include "album/SxAlbum.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class Utils {
+  public:
+    static void cleanTags(string& text);
+
+    static const CFileItemPtr SxAlbumToItem(SxAlbum* album, string prefix = "", int discNumber = 0);
+    static const CFileItemPtr SxTrackToItem(SxTrack* track, string prefix = "", int trackNumber = -1);
+    static const CFileItemPtr SxArtistToItem(SxArtist* artist, string prefix = "");
+
+    static void createDir(CStdString path);
+    static void removeDir(CStdString path);
+    static void removeFile(CStdString file);
+
+    static void updateMenu();
+    static void updatePlaylists();
+    static void updatePlaylist(int index);
+    static void updateAllArtists();
+    static void updateAllAlbums();
+    static void updateAllTracks();
+    static void updateRadio(int radio);
+    static void updateToplistMenu();
+    static void updateSearchResults(string query);
+
+  private:
+    Utils();
+    virtual ~Utils();
+    static void updatePath(CStdString& path);
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* UTILS_H_ */
diff --git a/xbmc/music/spotyXBMC/album/AlbumContainer.cpp b/xbmc/music/spotyXBMC/album/AlbumContainer.cpp
new file mode 100644
index 0000000..450ba04
--- /dev/null
+++ b/xbmc/music/spotyXBMC/album/AlbumContainer.cpp
@@ -0,0 +1,36 @@
+/*
+ * TrackContainer.cpp
+ *
+ *  Created on: Aug 17, 2011
+ *      Author: david
+ */
+
+#include "AlbumContainer.h"
+#include "AlbumStore.h"
+
+namespace addon_music_spotify {
+
+ AlbumContainer::AlbumContainer() {
+    // TODO Auto-generated constructor stub
+
+  }
+
+ AlbumContainer::~AlbumContainer() {
+    // TODO Auto-generated destructor stub
+  }
+
+  void AlbumContainer::removeAllAlbums() {
+    while (!m_albums.empty()) {
+      AlbumStore::getInstance()->removeAlbum(m_albums.back());
+      m_albums.pop_back();
+    }
+  }
+
+  bool AlbumContainer::albumsLoaded() {
+    for (int i = 0; i < m_albums.size(); i++) {
+      if (!m_albums[i]->isLoaded()) return false;
+    }
+    return true;
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/album/AlbumContainer.h b/xbmc/music/spotyXBMC/album/AlbumContainer.h
new file mode 100644
index 0000000..453c545
--- /dev/null
+++ b/xbmc/music/spotyXBMC/album/AlbumContainer.h
@@ -0,0 +1,29 @@
+
+#ifndef ALBUMCONTAINER_H_
+#define ALBUMCONTAINER_H_
+
+#include "SxAlbum.h"
+#include <vector>
+#include "FileItem.h"
+
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class AlbumContainer {
+  public:
+    AlbumContainer();
+    virtual ~AlbumContainer();
+
+    virtual bool getAlbumItems(CFileItemList& items) = 0;
+
+  protected:
+    vector<SxAlbum*> m_albums;
+
+    void removeAllAlbums();
+    bool albumsLoaded();
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* ALBUMCONTAINER_H_ */
diff --git a/xbmc/music/spotyXBMC/album/AlbumStore.cpp b/xbmc/music/spotyXBMC/album/AlbumStore.cpp
new file mode 100644
index 0000000..f20c15d
--- /dev/null
+++ b/xbmc/music/spotyXBMC/album/AlbumStore.cpp
@@ -0,0 +1,91 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "AlbumStore.h"
+#include "../Logger.h"
+#include "SxAlbum.h"
+
+namespace addon_music_spotify {
+
+  AlbumStore::AlbumStore() {
+  }
+
+  void AlbumStore::deInit() {
+    delete m_instance;
+  }
+
+  AlbumStore::~AlbumStore() {
+    for (albumMap::iterator it = m_albums.begin(); it != m_albums.end(); ++it) {
+      delete it->second;
+    }
+  }
+
+  AlbumStore* AlbumStore::m_instance = 0;
+  AlbumStore *AlbumStore::getInstance() {
+    return m_instance ? m_instance : (m_instance = new AlbumStore);
+  }
+
+  SxAlbum* AlbumStore::getAlbum(sp_album *spAlbum, bool loadTracksAndDetails) {
+    //Logger::printOut("loading spAlbum");
+    sp_album_add_ref(spAlbum);
+    while (!sp_album_is_loaded(spAlbum))
+      ;
+
+    albumMap::iterator it = m_albums.find(spAlbum);
+    SxAlbum *album;
+
+    if (it == m_albums.end()) {
+      //we need to create it
+      album = new SxAlbum(spAlbum, loadTracksAndDetails);
+      m_albums.insert(albumMap::value_type(spAlbum, album));
+    } else {
+      //Logger::printOut("loading album from store");
+      album = it->second;
+
+      if (loadTracksAndDetails) album->doLoadTracksAndDetails();
+
+      album->addRef();
+    }
+
+    return album;
+  }
+
+  void AlbumStore::removeAlbum(sp_album *spAlbum) {
+    albumMap::iterator it = m_albums.find(spAlbum);
+    SxAlbum *album;
+    if (it != m_albums.end()) {
+      album = it->second;
+      if (album->getReferencesCount() <= 1) {
+        m_albums.erase(spAlbum);
+        // Logger::printOut("deleting album");
+        delete album;
+      } else {
+        album->rmRef();
+        // Logger::printOut("lower album ref");
+      }
+    }
+  }
+
+  void AlbumStore::removeAlbum(SxAlbum* album) {
+    removeAlbum(album->getSpAlbum());
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/album/AlbumStore.h b/xbmc/music/spotyXBMC/album/AlbumStore.h
new file mode 100644
index 0000000..2539911
--- /dev/null
+++ b/xbmc/music/spotyXBMC/album/AlbumStore.h
@@ -0,0 +1,57 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef ALBUMSTORE_H_
+#define ALBUMSTORE_H_
+
+#include <libspotify/api.h>
+#ifdef _WIN32
+#include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
+
+
+namespace addon_music_spotify {
+  class SxAlbum;
+  class AlbumStore {
+  public:
+
+    static AlbumStore *getInstance();
+    static void deInit();
+
+    SxAlbum* getAlbum(sp_album *spAlbum, bool loadTracksAndDetails);
+    void removeAlbum(sp_album *spAlbum);
+    void removeAlbum(SxAlbum* album);
+
+  private:
+
+    AlbumStore();
+    virtual ~AlbumStore();
+
+    static AlbumStore *m_instance;
+
+    typedef std::tr1::unordered_map<sp_album*, SxAlbum*> albumMap;
+    albumMap m_albums;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* ALBUMSTORE_H_ */
diff --git a/xbmc/music/spotyXBMC/album/SxAlbum.cpp b/xbmc/music/spotyXBMC/album/SxAlbum.cpp
new file mode 100644
index 0000000..88b2fb8
--- /dev/null
+++ b/xbmc/music/spotyXBMC/album/SxAlbum.cpp
@@ -0,0 +1,157 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include <stdio.h>
+#include <math.h>
+#include "SxAlbum.h"
+#include "../Utils.h"
+#include "../session/Session.h"
+#include "../Logger.h"
+#include "../track/SxTrack.h"
+#include "../track/TrackStore.h"
+#include "../thumb/ThumbStore.h"
+
+namespace addon_music_spotify {
+
+SxAlbum::SxAlbum(sp_album *album, bool loadTracksAndDetails) {
+	m_spAlbum = album;
+	// Logger::printOut("creating album");
+	while (!sp_album_is_loaded(m_spAlbum))
+		;
+	m_references = 1;
+	m_numberOfDiscs = 1;
+	m_isLoadingTracks = false;
+	m_hasTracksAndDetails = false;
+	m_hasThumb = false;
+	m_thumb = NULL;
+	m_review = "none";
+	m_year = sp_album_year(m_spAlbum);
+	sp_link *link = sp_link_create_from_album(album);
+	m_uri = new char[256];
+	sp_link_as_string(link, m_uri, 256);
+	sp_link_release(link);
+	m_rating = 0;
+	if (loadTracksAndDetails)
+		doLoadTracksAndDetails();
+	doLoadThumb();
+	m_fanart = ThumbStore::getInstance()->getFanart(sp_artist_name(sp_album_artist(m_spAlbum)));
+	// Logger::printOut("creating album slut");
+}
+
+SxAlbum::~SxAlbum() {
+	removeAllTracks();
+
+	if (m_thumb)
+		ThumbStore::getInstance()->removeThumb(m_thumb);
+	sp_album_release(m_spAlbum);
+	delete m_uri;
+}
+
+bool SxAlbum::isStarred() {
+	for (int i = 0; i < m_tracks.size(); i++) {
+		if (!sp_track_is_starred(Session::getInstance()->getSpSession(),
+				m_tracks[i]->getSpTrack()))
+			return false;
+	}
+	return true;
+}
+
+bool SxAlbum::toggleStar() {
+	Logger::printOut("toggle album star");
+	sp_track **tracks = new sp_track*[m_tracks.size()]();
+
+	for (int i = 0; i < m_tracks.size(); i++) {
+		tracks[i] = m_tracks[i]->getSpTrack();
+	}
+
+	bool isStarred = this->isStarred();
+	sp_track_set_starred(Session::getInstance()->getSpSession(), tracks,
+			m_tracks.size(), !isStarred);
+
+	delete tracks;
+	return true;
+}
+
+void SxAlbum::doLoadTracksAndDetails() {
+	if (m_hasTracksAndDetails || m_isLoadingTracks)
+		return;
+
+	sp_albumbrowse_create(Session::getInstance()->getSpSession(), m_spAlbum,
+			&cb_albumBrowseComplete, this);
+	m_isLoadingTracks = true;
+}
+
+void SxAlbum::doLoadThumb() {
+	if (m_hasThumb)
+		return;
+	//Logger::printOut("Requesting thumb for album");
+	const byte* image = sp_album_cover(m_spAlbum);
+	if (image) {
+		m_thumb = ThumbStore::getInstance()->getThumb(image);
+		if (m_thumb)
+			m_hasThumb = true;
+	}
+}
+
+void SxAlbum::tracksLoaded(sp_albumbrowse *result) {
+	if (sp_albumbrowse_error(result) == SP_ERROR_OK) {
+		m_review = sp_albumbrowse_review(result);
+		//remove the links from the review text (it contains spotify uris so maybe we can do something fun with it later)
+		Utils::cleanTags(m_review);
+
+		//get some ratings, the album dont have rating so iterate through the tracks and calculate a mean value for the album
+		float rating = 0;
+
+		for (int index = 0; index < sp_albumbrowse_num_tracks(result); index++) {
+			sp_track *track = sp_albumbrowse_track(result, index);
+			if (m_numberOfDiscs < sp_track_disc(track))
+				m_numberOfDiscs = sp_track_disc(track);
+			m_tracks.push_back(
+					TrackStore::getInstance()->getTrack(
+							sp_albumbrowse_track(result, index)));
+
+			rating += sp_track_popularity(track);
+		}
+
+		if (sp_albumbrowse_num_tracks(result) != 0) {
+			m_rating = ceil(rating / (sp_albumbrowse_num_tracks(result)) / 10);
+		}
+
+		m_hasTracksAndDetails = true;
+	}
+	m_isLoadingTracks = false;
+	sp_albumbrowse_release(result);
+	//Logger::printOut("album browse complete done");
+}
+
+void SxAlbum::cb_albumBrowseComplete(sp_albumbrowse *result, void *userdata) {
+	//Logger::printOut("album browse complete");
+	SxAlbum *album = (SxAlbum*) (userdata);
+	//Logger::printOut(album->getAlbumName());
+	album->tracksLoaded(result);
+}
+
+bool SxAlbum::getTrackItems(CFileItemList& items) {
+	return true;
+}
+
+} /* namespace addon_music_spotify */
+
diff --git a/xbmc/music/spotyXBMC/album/SxAlbum.h b/xbmc/music/spotyXBMC/album/SxAlbum.h
new file mode 100644
index 0000000..94dff18
--- /dev/null
+++ b/xbmc/music/spotyXBMC/album/SxAlbum.h
@@ -0,0 +1,145 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SXALBUM_H_
+#define SXALBUM_H_
+
+#include <libspotify/api.h>
+#include <vector>
+#include <string>
+#include "../thumb/SxThumb.h"
+#include "../track/TrackContainer.h"
+#include "URL.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class AlbumStore;
+  class SxAlbum: private TrackContainer {
+  public:
+
+    static void SP_CALLCONV cb_albumBrowseComplete(sp_albumbrowse *result, void *userdata);
+    void doLoadTracksAndDetails();
+    void doLoadThumb();
+    void tracksLoaded(sp_albumbrowse *result);
+    const char *getReview() const;
+
+    friend class AlbumStore;
+
+    void addRef() {
+      m_references++;
+    }
+
+    int getReferencesCount() {
+      return m_references;
+    }
+
+    bool isLoaded() {
+      return !m_isLoadingTracks && (!m_hasThumb || (m_hasThumb && m_thumb->isLoaded()));
+    }
+
+    const char* getAlbumName() {
+      return sp_album_name(m_spAlbum);
+    }
+    const char* getAlbumArtistName() {
+      return sp_artist_name(sp_album_artist(m_spAlbum));
+    }
+    int getAlbumRating() {
+      return m_rating;
+    }
+    SxThumb* getAlbumThumb() {
+      return m_thumb;
+    }
+    sp_album* getSpAlbum() {
+      return m_spAlbum;
+    }
+    vector<SxTrack*> getTracks() {
+      return m_tracks;
+    }
+
+    bool isStarred();
+    bool toggleStar();
+
+    bool getTrackItems(CFileItemList& items);
+
+    bool hasTracksAndDetails() {
+      return m_hasTracksAndDetails;
+    }
+    bool hasThumb() {
+      return m_hasThumb;
+    }
+    bool isLoadingThumb() {
+      return m_thumb->isLoaded();
+    }
+
+    int getAlbumYear() {
+      return m_year;
+    }
+
+    string getReview() {
+      return m_review;
+    }
+
+    const char *getUri() {
+      return m_uri;
+    }
+
+    int getNumberOfDiscs() {
+      return m_numberOfDiscs;
+    }
+
+    SxThumb* getThumb() {
+      return m_thumb;
+    }
+
+    CStdString *getFanart(){
+    	return m_fanart;
+    }
+
+  private:
+    SxAlbum(sp_album *album, bool loadTracksAndDetails);
+    virtual ~SxAlbum();
+
+    void rmRef() {
+      m_references--;
+    }
+
+    int m_numberOfDiscs;
+
+    bool m_isLoadingTracks;
+    bool m_isLoadingThumb;
+    bool m_hasTracksAndDetails;
+    bool m_hasThumb;
+    CStdString *m_fanart;
+    int m_references;
+
+    char *m_uri;
+    sp_album *m_spAlbum;
+   // vector<SxTrack*> m_tracks;
+    SxThumb *m_thumb;
+    string m_review;
+    int m_rating;
+    int m_year;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SXALBUM_H_ */
diff --git a/xbmc/music/spotyXBMC/artist/ArtistContainer.cpp b/xbmc/music/spotyXBMC/artist/ArtistContainer.cpp
new file mode 100644
index 0000000..00cbdae
--- /dev/null
+++ b/xbmc/music/spotyXBMC/artist/ArtistContainer.cpp
@@ -0,0 +1,51 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "ArtistStore.h"
+#include "ArtistContainer.h"
+#include "SxArtist.h"
+
+namespace addon_music_spotify {
+
+  ArtistContainer::ArtistContainer() {
+    // TODO Auto-generated constructor stub
+
+  }
+
+  ArtistContainer::~ArtistContainer() {
+    // TODO Auto-generated destructor stub
+  }
+
+  void ArtistContainer::removeAllArtists() {
+    while (!m_artists.empty()) {
+      ArtistStore::getInstance()->removeArtist(m_artists.back());
+      m_artists.pop_back();
+    }
+  }
+
+  bool ArtistContainer::artistsLoaded() {
+    for (int i = 0; i < m_artists.size(); i++) {
+      if (!m_artists[i]->isLoaded()) return false;
+    }
+    return true;
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/artist/ArtistContainer.h b/xbmc/music/spotyXBMC/artist/ArtistContainer.h
new file mode 100644
index 0000000..bd2fb8e
--- /dev/null
+++ b/xbmc/music/spotyXBMC/artist/ArtistContainer.h
@@ -0,0 +1,49 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef ARTISTCONTAINER_H_
+#define ARTISTCONTAINER_H_
+
+#include <vector>
+#include "FileItem.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class SxArtist;
+
+  class ArtistContainer {
+  public:
+    ArtistContainer();
+    virtual ~ArtistContainer();
+
+    virtual bool getArtistItems(CFileItemList& items) = 0;
+
+  protected:
+    vector<SxArtist*> m_artists;
+
+    void removeAllArtists();
+    bool artistsLoaded();
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* ARTISTCONTAINER_H_ */
diff --git a/xbmc/music/spotyXBMC/artist/ArtistStore.cpp b/xbmc/music/spotyXBMC/artist/ArtistStore.cpp
new file mode 100644
index 0000000..9754abc
--- /dev/null
+++ b/xbmc/music/spotyXBMC/artist/ArtistStore.cpp
@@ -0,0 +1,94 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "ArtistStore.h"
+#include "../Logger.h"
+#include "SxArtist.h"
+
+namespace addon_music_spotify {
+
+ArtistStore::ArtistStore() {
+}
+
+void ArtistStore::deInit() {
+	delete m_instance;
+}
+
+ArtistStore::~ArtistStore() {
+	Logger::printOut("deleting artistStore");
+	for (artistMap::iterator it = m_artists.begin(); it != m_artists.end();
+			++it) {
+		delete it->second;
+	}
+}
+
+ArtistStore* ArtistStore::m_instance = 0;
+ArtistStore *ArtistStore::getInstance() {
+	return m_instance ? m_instance : (m_instance = new ArtistStore);
+}
+
+SxArtist* ArtistStore::getArtist(sp_artist *spArtist,
+		bool loadAlbumsAndTracks) {
+	Logger::printOut("loading spArtist");
+	sp_artist_add_ref(spArtist);
+	while (!sp_artist_is_loaded(spArtist))
+		;
+
+	artistMap::iterator it = m_artists.find(spArtist);
+	SxArtist *artist;
+
+	if (it == m_artists.end()) {
+		//we need to create it
+		artist = new SxArtist(spArtist, loadAlbumsAndTracks);
+		m_artists.insert(artistMap::value_type(spArtist, artist));
+	} else {
+		//Logger::printOut("loading artist from store");
+		artist = it->second;
+		if (loadAlbumsAndTracks)
+			artist->doLoadTracksAndAlbums();
+
+		artist->addRef();
+	}
+
+	return artist;
+}
+
+void ArtistStore::removeArtist(sp_artist *spArtist) {
+	artistMap::iterator it = m_artists.find(spArtist);
+	SxArtist *artist;
+	if (it != m_artists.end()) {
+		artist = it->second;
+		if (artist->getReferencesCount() <= 1) {
+			m_artists.erase(spArtist);
+			Logger::printOut("deleting artist");
+			delete artist;
+		} else {
+			artist->rmRef();
+			Logger::printOut("lower artist ref");
+		}
+	}
+}
+
+void ArtistStore::removeArtist(SxArtist* artist) {
+	removeArtist(artist->getSpArtist());
+}
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/artist/ArtistStore.h b/xbmc/music/spotyXBMC/artist/ArtistStore.h
new file mode 100644
index 0000000..7ddfd2e
--- /dev/null
+++ b/xbmc/music/spotyXBMC/artist/ArtistStore.h
@@ -0,0 +1,57 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef ARTISTSTORE_H_
+#define ARTISTSTORE_H_
+
+#include <libspotify/api.h>
+#include <string>
+#ifdef _WIN32
+#include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
+
+namespace addon_music_spotify {
+  class SxArtist;
+  class ArtistStore {
+  public:
+
+    static ArtistStore *getInstance();
+    static void deInit();
+
+    SxArtist* getArtist(sp_artist *spArtist, bool loadDetails);
+    void removeArtist(sp_artist *spArtist);
+    void removeArtist(SxArtist* artist);
+
+  private:
+
+    ArtistStore();
+    virtual ~ArtistStore();
+
+    static ArtistStore *m_instance;
+
+    typedef std::tr1::unordered_map<sp_artist*, SxArtist*> artistMap;
+    artistMap m_artists;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* ARTISTSTORE_H_ */
diff --git a/xbmc/music/spotyXBMC/artist/SxArtist.cpp b/xbmc/music/spotyXBMC/artist/SxArtist.cpp
new file mode 100644
index 0000000..bdb5e81
--- /dev/null
+++ b/xbmc/music/spotyXBMC/artist/SxArtist.cpp
@@ -0,0 +1,233 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include <stdio.h>
+#include <math.h>
+#include "SxArtist.h"
+#include "../session/Session.h"
+#include "../Logger.h"
+#include "../Utils.h"
+
+#include "../album/SxAlbum.h"
+#include "../album/AlbumStore.h"
+#include "../track/SxTrack.h"
+#include "../track/TrackStore.h"
+#include "../artist/SxArtist.h"
+#include "../artist/ArtistStore.h"
+#include "../thumb/SxThumb.h"
+#include "../thumb/ThumbStore.h"
+
+namespace addon_music_spotify {
+
+	SxArtist::SxArtist(sp_artist *artist, bool loadTracksAndAlbums) {
+		m_spArtist = artist;
+		Logger::printOut("creating artist");
+		m_references = 1;
+		m_browse = NULL;
+		m_isLoadingDetails = false;
+		m_hasDetails = false;
+		m_hasTracksAndAlbums = false;
+		m_thumb = NULL;
+		m_hasThumb = false;
+		m_bio = "";
+		sp_link *link = sp_link_create_from_artist(artist);
+		m_uri = new char[256];
+		sp_link_as_string(link, m_uri, 256);
+		sp_link_release(link);
+
+			//check if there is a thumb
+			const byte* image = sp_artist_portrait(artist);
+			if (image) {
+				m_thumb = ThumbStore::getInstance()->getThumb(image);
+				if (m_thumb)
+					m_hasThumb = true;
+			}
+
+		m_loadTrackAndAlbums = loadTracksAndAlbums;
+		if (loadTracksAndAlbums)
+			doLoadTracksAndAlbums();
+		//sometimes the thumb is not loaded correct here, do a small artist browse and try again!
+		else if (Settings::getInstance()->getPreloadArtistDetails() || !m_hasThumb)
+			doLoadDetails();
+		else
+			m_hasDetails = true;
+		Logger::printOut("creating artist done");
+
+		m_fanart = ThumbStore::getInstance()->getFanart(sp_artist_name(m_spArtist));
+	}
+
+	SxArtist::~SxArtist() {
+		while (m_isLoadingDetails) {
+			//Session::getInstance()->processEvents();
+			Logger::printOut("waiting for artist to die");
+		}
+
+		removeAllTracks();
+		removeAllAlbums();
+		removeAllArtists();
+
+		if (m_thumb)
+			ThumbStore::getInstance()->removeThumb(m_thumb);
+		delete m_uri;
+		if (hasDetails() && m_browse != NULL)
+			sp_artistbrowse_release(m_browse);
+		sp_artist_release(m_spArtist);
+	}
+
+	bool SxArtist::isAlbumsLoaded() {
+		if (!m_hasTracksAndAlbums)
+			return false;
+		return albumsLoaded();
+	}
+
+	bool SxArtist::isTracksLoaded() {
+		if (!m_hasTracksAndAlbums)
+			return false;
+		return tracksLoaded();
+	}
+
+	bool SxArtist::isArtistsLoaded() {
+		if (!m_hasTracksAndAlbums)
+			return false;
+		return artistsLoaded();
+	}
+
+	void SxArtist::doLoadTracksAndAlbums() {
+		Logger::printOut("loading artist tracks and albums");
+		m_loadTrackAndAlbums = true;
+		//if we allready have it all..
+		if (m_hasTracksAndAlbums)
+			return;
+
+		m_isLoadingDetails = true;
+		m_browse = sp_artistbrowse_create(Session::getInstance()->getSpSession(),
+				m_spArtist, SP_ARTISTBROWSE_FULL, &cb_artistBrowseComplete, this);
+	}
+
+	void SxArtist::doLoadDetails() {
+		if (m_hasDetails || m_isLoadingDetails)
+			return;
+
+		m_isLoadingDetails = true;
+		m_browse = sp_artistbrowse_create(Session::getInstance()->getSpSession(),
+				m_spArtist, SP_ARTISTBROWSE_NO_ALBUMS, &cb_artistBrowseComplete, this);
+	}
+
+	void SxArtist::detailsLoaded(sp_artistbrowse *result) {
+		if (sp_artistbrowse_error(result) == SP_ERROR_OK) {
+			//check if there is a thumb
+			if (!m_hasThumb && sp_artistbrowse_num_portraits > 0) {
+				const byte* image = sp_artistbrowse_portrait(result, 0);
+				if (image) {
+					m_thumb = ThumbStore::getInstance()->getThumb(image);
+				}
+			}
+			if (m_thumb != NULL)
+				m_hasThumb = true;
+
+			m_bio = sp_artistbrowse_biography(result);
+			//remove the links from the bio text (it contains spotify uris so maybe we can do something fun with it later)
+			Utils::cleanTags(m_bio);
+
+			if (m_loadTrackAndAlbums) {
+				//add the albums
+				int maxAlbums =
+						Settings::getInstance()->getArtistNumberAlbums() == -1 ?
+								sp_artistbrowse_num_albums(m_browse) :
+								Settings::getInstance()->getArtistNumberAlbums();
+
+				int addedAlbums = 0;
+				for (int index = 0;
+						index < sp_artistbrowse_num_albums(m_browse)
+								&& addedAlbums < maxAlbums; index++) {
+					if (sp_album_is_available(sp_artistbrowse_album(m_browse, index))) {
+						m_albums.push_back(
+								AlbumStore::getInstance()->getAlbum(
+										sp_artistbrowse_album(m_browse, index), true));
+						addedAlbums++;
+					}
+				}
+
+				//add the tracks
+				int maxTracks =
+						Settings::getInstance()->getArtistNumberTracks() == -1 ?
+								sp_artistbrowse_num_tracks(m_browse) :
+								Settings::getInstance()->getArtistNumberTracks();
+
+				int addedTracks = 0;
+				for (int index = 0;
+						index < sp_artistbrowse_num_tracks(m_browse)
+								&& addedTracks < maxTracks; index++) {
+					if (sp_track_get_availability(Session::getInstance()->getSpSession(),
+							sp_artistbrowse_track(m_browse, index))) {
+						m_tracks.push_back(
+								TrackStore::getInstance()->getTrack(
+										sp_artistbrowse_track(m_browse, index)));
+						addedTracks++;
+					}
+				}
+
+				//add the artists
+				int maxArtists =
+						Settings::getInstance()->getArtistNumberArtists() == -1 ?
+								sp_artistbrowse_num_similar_artists(m_browse) :
+								Settings::getInstance()->getArtistNumberArtists();
+
+				int addedArtists = 0;
+				for (int index = 0;
+						index < sp_artistbrowse_num_similar_artists(m_browse)
+								&& addedArtists < maxArtists; index++) {
+					m_artists.push_back(
+							ArtistStore::getInstance()->getArtist(
+									sp_artistbrowse_similar_artist(m_browse, index), false));
+					addedArtists++;
+				}
+
+				m_hasTracksAndAlbums = true;
+			}
+		}
+		m_isLoadingDetails = false;
+		m_hasDetails = true;
+		Logger::printOut("artist browse complete done");
+	}
+
+	void SxArtist::cb_artistBrowseComplete(sp_artistbrowse *result,
+			void *userdata) {
+		Logger::printOut("artist browse complete");
+		SxArtist *artist = (SxArtist*) (userdata);
+		Logger::printOut(artist->getArtistName());
+		artist->detailsLoaded(result);
+	}
+
+	bool SxArtist::getTrackItems(CFileItemList& items) {
+		return true;
+	}
+
+	bool SxArtist::getAlbumItems(CFileItemList& items) {
+		return true;
+	}
+
+	bool SxArtist::getArtistItems(CFileItemList& items) {
+		return true;
+	}
+
+} /* namespace addon_music_spotify */
+
diff --git a/xbmc/music/spotyXBMC/artist/SxArtist.h b/xbmc/music/spotyXBMC/artist/SxArtist.h
new file mode 100644
index 0000000..ca67874
--- /dev/null
+++ b/xbmc/music/spotyXBMC/artist/SxArtist.h
@@ -0,0 +1,161 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SXARTIST_H_
+#define SXARTIST_H_
+
+#ifndef SP_CALLCONV
+#ifdef _WIN32
+#define SP_CALLCONV __stdcall
+#else
+#define SP_CALLCONV
+#endif
+#endif
+
+#include <libspotify/api.h>
+#include <vector>
+#include <string>
+#include "../album/AlbumContainer.h"
+#include "../track/TrackContainer.h"
+#include "ArtistContainer.h"
+#include "../thumb/SxThumb.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+	class SxTrack;
+	class SxAlbum;
+	class SxArtist;
+	class ArtistStore;
+	class SxArtist: private TrackContainer,
+			private AlbumContainer,
+			private ArtistContainer {
+	public:
+
+		static void SP_CALLCONV cb_artistBrowseComplete(sp_artistbrowse *result,
+				void *userdata);
+		void doLoadDetails();
+		void doLoadTracksAndAlbums();
+
+		void detailsLoaded(sp_artistbrowse *result);
+
+		friend class ArtistStore;
+
+		void addRef() {
+			m_references++;
+		}
+
+		int getReferencesCount() {
+			return m_references;
+		}
+
+		bool isLoaded() {
+			return !m_isLoadingDetails
+					&& (!m_hasThumb || (m_hasThumb && m_thumb->isLoaded()));
+		}
+
+		bool isAlbumsLoaded();
+		bool isTracksLoaded();
+		bool isArtistsLoaded();
+
+		const char* getArtistName() {
+			return sp_artist_name(m_spArtist);
+		}
+
+		SxThumb* getThumb() {
+			return m_thumb;
+		}
+
+		sp_artist* getSpArtist() {
+			return m_spArtist;
+		}
+
+		vector<SxTrack*> getTracks() {
+			return m_tracks;
+		}
+
+		bool getTrackItems(CFileItemList& items);
+
+		vector<SxAlbum*> getAlbums() {
+			return m_albums;
+		}
+
+		bool getAlbumItems(CFileItemList& items);
+
+		vector<SxArtist*> getArtists() {
+			return m_artists;
+		}
+
+		bool getArtistItems(CFileItemList& items);
+
+		bool hasDetails() {
+			return m_hasDetails;
+		}
+
+		bool hasTracksAndAlbums() {
+			return m_hasTracksAndAlbums;
+		}
+
+		bool hasThumb() {
+			return m_hasThumb;
+		}
+
+		string getBio() {
+			return m_bio;
+		}
+
+		const char *getUri() {
+			return m_uri;
+		}
+
+		CStdString *getFanart() {
+			return m_fanart;
+		}
+
+
+	private:
+		SxArtist(sp_artist *artist, bool loadTracksAndAlbums);
+		virtual ~SxArtist();
+
+		void rmRef() {
+			m_references--;
+		}
+
+		bool m_isLoadingDetails;
+		bool m_loadTrackAndAlbums;
+		bool m_hasDetails;
+		bool m_hasTracksAndAlbums;
+		int m_references;
+
+		string m_bio;
+		sp_artistbrowse* m_browse;
+
+		char *m_uri;
+		sp_artist *m_spArtist;
+		SxThumb *m_thumb;
+
+		CStdString *m_fanart;
+
+		bool m_hasThumb;
+	};
+
+} /* namespace addon_music_spotify */
+#endif /* SXARTIST_H_ */
diff --git a/xbmc/music/spotyXBMC/player/ISpotifyPlayer.cpp b/xbmc/music/spotyXBMC/player/ISpotifyPlayer.cpp
new file mode 100644
index 0000000..3a49fbc
--- /dev/null
+++ b/xbmc/music/spotyXBMC/player/ISpotifyPlayer.cpp
@@ -0,0 +1,27 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ISpotifyPlayer.h"
+
+namespace addon_music_spotify {
+ISpotifyPlayer::ISpotifyPlayer() {
+}
+
+ISpotifyPlayer::~ISpotifyPlayer() {
+}
+}
diff --git a/xbmc/music/spotyXBMC/player/ISpotifyPlayer.h b/xbmc/music/spotyXBMC/player/ISpotifyPlayer.h
new file mode 100644
index 0000000..5118e22
--- /dev/null
+++ b/xbmc/music/spotyXBMC/player/ISpotifyPlayer.h
@@ -0,0 +1,33 @@
+#pragma once
+
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <libspotify/api.h>
+
+namespace addon_music_spotify {
+class ISpotifyPlayer {
+public:
+	ISpotifyPlayer();
+	virtual ~ISpotifyPlayer();
+
+	virtual int sp_musicDelivery(const sp_audioformat *format,
+			const void *frames, int num_frames)=0;
+	virtual void sp_endOfTrack()=0;
+};
+}
diff --git a/xbmc/music/spotyXBMC/player/PlayerHandler.cpp b/xbmc/music/spotyXBMC/player/PlayerHandler.cpp
new file mode 100644
index 0000000..6ae7259
--- /dev/null
+++ b/xbmc/music/spotyXBMC/player/PlayerHandler.cpp
@@ -0,0 +1,78 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+               2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "PlayerHandler.h"
+#include "ISpotifyPlayer.h"
+#include "../session/Session.h"
+
+namespace addon_music_spotify {
+
+PlayerHandler* PlayerHandler::m_instance = 0;
+ISpotifyPlayer* PlayerHandler::m_player = 0;
+PlayerHandler *PlayerHandler::getInstance() {
+	return m_instance ? m_instance : (m_instance = new PlayerHandler());
+}
+ISpotifyPlayer* PlayerHandler::getPlayer() {
+	return m_player;
+}
+
+PlayerHandler::PlayerHandler() {
+	m_instance = 0;
+}
+
+PlayerHandler::~PlayerHandler() {
+	if (!m_instance)
+		return;
+	m_instance->detachPlayer(m_player);
+}
+
+void PlayerHandler::deInit() {
+	if (!m_instance)
+		return;
+	m_instance->detachPlayer(m_player);
+}
+
+int PlayerHandler::cb_musicDelivery(sp_session *session,
+		const sp_audioformat *format, const void *frames, int num_frames) {
+	if (m_instance) {
+		ISpotifyPlayer *player = m_instance->getPlayer();
+		if (player)
+			return player->sp_musicDelivery(format, frames, num_frames);
+	}
+	return 0;
+}
+
+void PlayerHandler::cb_endOfTrack(sp_session *session) {
+	if (m_instance) {
+		ISpotifyPlayer *player = m_instance->getPlayer();
+		if (player)
+			player->sp_endOfTrack();
+	}
+}
+
+void PlayerHandler::attachPlayer(ISpotifyPlayer *player) {
+	m_player = player;
+}
+void PlayerHandler::detachPlayer(ISpotifyPlayer *player) {
+	m_player = 0;
+}
+}/* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/player/PlayerHandler.h b/xbmc/music/spotyXBMC/player/PlayerHandler.h
new file mode 100644
index 0000000..c363da6
--- /dev/null
+++ b/xbmc/music/spotyXBMC/player/PlayerHandler.h
@@ -0,0 +1,53 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+               2013  Samuel Cabrero <samuelcabrero@gmail.com>
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef PLAYERHANDLER_H_
+#define PLAYERHANDLER_H_
+
+#include <libspotify/api.h>
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+class ISpotifyPlayer;
+class PlayerHandler {
+public:
+	static PlayerHandler *getInstance();
+	static void deInit();
+
+	void attachPlayer(ISpotifyPlayer *player);
+	void detachPlayer(ISpotifyPlayer *player);
+	static ISpotifyPlayer *getPlayer();
+
+	static int SP_CALLCONV cb_musicDelivery(sp_session *session,
+			const sp_audioformat *format, const void *frames, int num_frames);static void SP_CALLCONV cb_endOfTrack(sp_session *session);
+
+private:
+	PlayerHandler();
+	virtual ~PlayerHandler();
+	static PlayerHandler *m_instance;
+	static ISpotifyPlayer *m_player;
+};
+
+} /* namespace addon_music_spotify */
+#endif /* PLAYERHANDLER_H_ */
diff --git a/xbmc/music/spotyXBMC/playlist/PlaylistStore.cpp b/xbmc/music/spotyXBMC/playlist/PlaylistStore.cpp
new file mode 100644
index 0000000..bd8b5e7
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/PlaylistStore.cpp
@@ -0,0 +1,188 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "PlaylistStore.h"
+#include "../session/Session.h"
+
+#include "SxPlaylist.h"
+#include "StarredList.h"
+#include "TopLists.h"
+#include "../session/Session.h"
+#include "../track/TrackStore.h"
+#include "../thumb/ThumbStore.h"
+#include "../track/SxTrack.h"
+#include "../thumb/SxThumb.h"
+#include "../Utils.h"
+
+namespace addon_music_spotify {
+
+  PlaylistStore::PlaylistStore() {
+    Logger::printOut("init playliststore");
+    m_isLoaded = false;
+    m_starredList = NULL;
+    m_topLists = NULL;
+    m_spContainer = sp_session_playlistcontainer(Session::getInstance()->getSpSession());
+    m_spStarredList = sp_session_starred_create(Session::getInstance()->getSpSession());
+    m_spInboxList = sp_session_inbox_create(Session::getInstance()->getSpSession());
+
+    for (int i = 0; i < sp_playlistcontainer_num_playlists(m_spContainer); i++) {
+      sp_playlist_set_in_ram(Session::getInstance()->getSpSession(), sp_playlistcontainer_playlist(m_spContainer, i), true);
+    }
+
+    sp_playlist_set_in_ram(Session::getInstance()->getSpSession(), m_spInboxList , true);
+    sp_playlist_set_in_ram(Session::getInstance()->getSpSession(), m_spStarredList, true);
+
+    m_pcCallbacks.playlist_added = &pc_playlist_added;
+    m_pcCallbacks.playlist_removed = &pc_playlist_removed;
+    m_pcCallbacks.container_loaded = &pc_loaded;
+    m_pcCallbacks.playlist_moved = &pc_playlist_moved;
+
+    sp_playlistcontainer_add_callbacks(m_spContainer, &m_pcCallbacks, this);
+  }
+
+  PlaylistStore::~PlaylistStore() {
+    sp_playlistcontainer_remove_callbacks(m_spContainer, &m_pcCallbacks, this);
+    Logger::printOut("delete PlaylistStore");
+    while (!m_playlists.empty()) {
+      delete m_playlists.back();
+      m_playlists.pop_back();
+    }
+    Logger::printOut("delete PlaylistStore starred");
+    delete m_starredList;
+    delete m_topLists;
+    m_starredList = NULL;
+
+    Logger::printOut("delete PlaylistStore done");
+  }
+
+  bool PlaylistStore::isLoaded() {
+    if (!m_isLoaded) return false;
+
+    for (int i = 0; i < m_playlists.size(); i++) {
+      if (!m_playlists[i]->isLoaded()) {
+        return false;
+      }
+    }
+    if (m_starredList) if (!m_starredList->isLoaded()) return false;
+
+    if (m_topLists) if (!m_topLists->isLoaded()) return false;
+
+    return true;
+  }
+
+  const char *PlaylistStore::getPlaylistName(int index) {
+    if (index < m_playlists.size()) {
+
+      return m_playlists[index]->getName();
+    }
+    return "";
+  }
+
+  SxPlaylist *PlaylistStore::getPlaylist(int index) {
+    if (index < m_playlists.size()) {
+      return m_playlists[index];
+    }
+    return NULL;
+  }
+
+  void PlaylistStore::pc_loaded(sp_playlistcontainer *pc, void *userdata) {
+    Logger::printOut("pc loaded");
+    PlaylistStore *store = (PlaylistStore*) userdata;
+
+    vector<SxPlaylist*> newPlaylists;
+    int playlistNumber = 0;
+    //add the inbox playlist first
+    newPlaylists.push_back(new SxPlaylist(store->m_spInboxList, playlistNumber, false));
+    playlistNumber++;
+
+
+    for (int i = 0; i < sp_playlistcontainer_num_playlists(store->getContainer()); i++) {
+      sp_playlist_type spType = sp_playlistcontainer_playlist_type(store->m_spContainer, i);
+      if (spType == SP_PLAYLIST_TYPE_PLAYLIST) {
+        newPlaylists.push_back(new SxPlaylist(sp_playlistcontainer_playlist(store->getContainer(), i), playlistNumber, false));
+        playlistNumber++;
+      }
+    }
+
+    Utils::updatePlaylists();
+
+    store->m_starredList = new StarredList(store->m_spStarredList);
+    Logger::printOut("m_starredList created");
+
+    Logger::printOut("All playlists loaded");
+
+    //empty the old one if we are updating
+    while (!store->m_playlists.empty()) {
+      delete store->m_playlists.back();
+      store->m_playlists.pop_back();
+    }
+    store->m_playlists = newPlaylists;
+
+    if (store->m_topLists == NULL
+    ) store->m_topLists = new TopLists();
+
+    store->m_isLoaded = true;
+    Utils::updateToplistMenu();
+
+  }
+
+  void PlaylistStore::pc_playlist_added(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata) {
+    PlaylistStore *store = (PlaylistStore*) userdata;
+    store->addPlaylist(playlist, position);
+  }
+
+  void PlaylistStore::pc_playlist_moved(sp_playlistcontainer *pc, sp_playlist *playlist, int position, int new_position, void *userdata) {
+    PlaylistStore *store = (PlaylistStore*) userdata;
+    store->movePlaylist(position, new_position);
+  }
+
+  void PlaylistStore::pc_playlist_removed(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata) {
+    PlaylistStore *store = (PlaylistStore*) userdata;
+    store->removePlaylist(position);
+  }
+
+  StarredList *PlaylistStore::getStarredList() {
+    return m_starredList;
+  }
+
+  void PlaylistStore::removePlaylist(int position) {
+    Logger::printOut("removing playlist");
+    Logger::printOut(position);
+    if (position < m_playlists.size()) {
+      Logger::printOut("removing playlist inner");
+      m_isLoaded = false;
+      m_playlists[position]->makeInvalid();
+      Logger::printOut("removing playlist inner 2");
+    }
+  }
+
+  void PlaylistStore::movePlaylist(int position, int newPosition) {
+    Logger::printOut("moving playlist");
+    //skip this now since the playlists are ordered by name anyway
+    //m_isLoaded = false;
+  }
+
+  void PlaylistStore::addPlaylist(sp_playlist *playlist, int position) {
+    Logger::printOut("adding playlist");
+    m_isLoaded = false;
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/playlist/PlaylistStore.h b/xbmc/music/spotyXBMC/playlist/PlaylistStore.h
new file mode 100644
index 0000000..457928c
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/PlaylistStore.h
@@ -0,0 +1,85 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef PLAYLISTCONTAINER_H_
+#define PLAYLISTCONTAINER_H_
+
+#include <libspotify/api.h>
+#include <vector>
+
+namespace addon_music_spotify {
+
+  using namespace std;
+
+  class StarredList;
+  class SxPlaylist;
+  class TopLists;
+
+  class PlaylistStore {
+  public:
+    PlaylistStore();
+    virtual ~PlaylistStore();
+
+    void init();
+
+    static void SP_CALLCONV pc_loaded(sp_playlistcontainer *pc, void *userdata);
+    static void SP_CALLCONV pc_playlist_added(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata);
+    static void SP_CALLCONV pc_playlist_moved(sp_playlistcontainer *pc, sp_playlist *playlist, int position, int new_position, void *userdata);
+    static void SP_CALLCONV pc_playlist_removed(sp_playlistcontainer *pc, sp_playlist *playlist, int position, void *userdata);
+
+    bool isLoaded();
+    int getPlaylistCount() {
+      return m_playlists.size();
+    }
+    const char* getPlaylistName(int index);
+    SxPlaylist* getPlaylist(int index);
+    StarredList* getStarredList();
+    sp_playlistcontainer* getContainer() {
+      return m_spContainer;
+    }
+    sp_playlist* getStarredSpList() {
+      return m_spStarredList;
+    }
+
+    TopLists* getTopLists() {
+      return m_topLists;
+    }
+
+    void removePlaylist(int position);
+    void movePlaylist(int position, int newPosition);
+    void addPlaylist(sp_playlist* playlist, int position);
+
+  private:
+
+    static void *loadPlaylists(void *s);
+    bool m_isLoaded;
+    vector<SxPlaylist*> m_playlists;
+    StarredList* m_starredList;
+    TopLists* m_topLists;
+    sp_playlist* m_spStarredList;
+    sp_playlist* m_spInboxList;
+    sp_playlistcontainer_callbacks m_pcCallbacks;
+    sp_playlistcontainer *m_spContainer;
+
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* PLAYLISTCONTAINER_H_ */
diff --git a/xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.cpp b/xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.cpp
new file mode 100644
index 0000000..7a7020a
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.cpp
@@ -0,0 +1,179 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "../album/AlbumStore.h"
+#include "../session/Session.h"
+#include "StarredBackgroundLoader.h"
+#include "StarredList.h"
+#include "../album/SxAlbum.h"
+#include "../track/SxTrack.h"
+#include "../artist/SxArtist.h"
+#include "../track/TrackStore.h"
+#include "../artist/ArtistStore.h"
+#include "../Utils.h"
+#include <set>
+
+namespace addon_music_spotify {
+
+StarredBackgroundLoader::StarredBackgroundLoader() : CThread("Spotify StarredBackgroundLoader"){
+}
+
+StarredBackgroundLoader::~StarredBackgroundLoader() {
+}
+
+void StarredBackgroundLoader::OnStartup() {
+}
+
+void StarredBackgroundLoader::OnExit() {
+}
+
+void StarredBackgroundLoader::OnException() {
+}
+
+void StarredBackgroundLoader::Process() {
+	StarredList* ls =
+			Session::getInstance()->getPlaylistStore()->getStarredList();
+	ls->m_isBackgroundLoading = true;
+
+	while (ls->m_reload) {
+		Logger::printOut("Populate starred albums and artists thread start");
+		//we need the session lock so that we can run processevents and wait for albums etc
+		while (!Session::getInstance()->lock()) {
+			SleepMs(1);
+		}
+		ls->m_reload = false;
+
+		vector<SxTrack*> newTracks;
+		for (int index = 0; index < sp_playlist_num_tracks(ls->m_spPlaylist);
+				index++) {
+			if (!sp_track_get_availability(Session::getInstance()->getSpSession(),
+					sp_playlist_track(ls->m_spPlaylist, index)))
+				continue;
+			SxTrack* track = TrackStore::getInstance()->getTrack(
+					sp_playlist_track(ls->m_spPlaylist, index));
+			if (track) {
+				newTracks.push_back(track);
+			}
+		}
+
+		ls->removeAllTracks();
+
+		ls->m_tracks = newTracks;
+
+		set<sp_album*> tempAlbums;
+		set<sp_artist*> tempArtists;
+		for (int i = 0; i < ls->getNumberOfTracks(); i++) {
+
+			sp_album* tempAlbum = sp_track_album(ls->m_tracks[i]->getSpTrack());
+			if (tempAlbum != NULL)
+				tempAlbums.insert(tempAlbum);
+
+			sp_artist* tempArtist = sp_track_artist(ls->m_tracks[i]->getSpTrack(), 0);
+			if (tempArtist != NULL)
+				tempArtists.insert(tempArtist);
+		}
+
+		//now we have a set with unique sp_albums, lets load them and see if they have all tracks starred or not
+
+		vector<SxAlbum*> newAlbums;
+		//find out witch albums that has complete set of starred tracks
+		for (set<sp_album*>::const_iterator albumIt = tempAlbums.begin();
+				albumIt != tempAlbums.end(); ++albumIt) {
+			sp_album* tempalbum = (sp_album*) *albumIt;
+			if (tempalbum == NULL)
+				continue;
+			while (!sp_album_is_loaded(tempalbum))
+				SleepMs(1);
+
+			SxAlbum* album = AlbumStore::getInstance()->getAlbum(tempalbum, true);
+			Logger::printOut(album->getAlbumName());
+
+			Session::getInstance()->unlock();
+			while (!album->isLoaded()) {
+				SleepMs(1);
+			}
+			while (!Session::getInstance()->lock()) {
+				SleepMs(1);
+			}
+
+			if (!album->hasTracksAndDetails() || album->getTracks().size() == 0
+					|| !sp_album_is_available(album->getSpAlbum())) {
+				AlbumStore::getInstance()->removeAlbum(album);
+				continue;
+			}
+			bool albumIsStarred = true;
+			vector<SxTrack*> tracks = album->getTracks();
+			for (int i = 0; i < tracks.size(); i++) {
+				if (!sp_track_is_starred(Session::getInstance()->getSpSession(),
+						tracks[i]->getSpTrack())) {
+					albumIsStarred = false;
+					break;
+				}
+			}
+
+			if (albumIsStarred)
+				newAlbums.push_back(
+						AlbumStore::getInstance()->getAlbum(album->getSpAlbum(), true));
+		}
+
+		ls->removeAllAlbums();
+
+		//add all artists that we have collected
+
+		vector<SxArtist*> newArtists;
+		for (set<sp_artist*>::const_iterator artistIt = tempArtists.begin();
+				artistIt != tempArtists.end(); ++artistIt) {
+			sp_artist* tempartist = (sp_artist*) *artistIt;
+			if (tempartist == NULL)
+				continue;
+			//while (!sp_artist_is_loaded(tempartist))
+			//	SleepMs(1);
+
+			SxArtist* artist = ArtistStore::getInstance()->getArtist(tempartist,
+					false);
+
+			if (artist != NULL)
+				newArtists.push_back(artist);
+		}
+
+		while (!ls->m_artists.empty()) {
+			ArtistStore::getInstance()->removeArtist(ls->m_artists.back());
+			ls->m_artists.pop_back();
+		}
+
+		ls->m_artists = newArtists;
+		ls->m_albums = newAlbums;
+
+		//wait for all info to finish loading before updating the lists (or reloading it all)
+		Session::getInstance()->unlock();
+		while (!ls->isLoaded()) {
+			SleepMs(1);
+		}
+	}
+
+	ls->m_isBackgroundLoading = false;
+
+	Utils::updateAllTracks();
+	Utils::updateAllAlbums();
+	Utils::updateAllArtists();
+	Logger::printOut("Populate starred albums and artists thread done");
+}
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.h b/xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.h
new file mode 100644
index 0000000..f892521
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/StarredBackgroundLoader.h
@@ -0,0 +1,44 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef STARREDBACKGROUNDLOADER_H_
+#define STARREDBACKGROUNDLOADER_H_
+
+#include "threads/Thread.h"
+
+namespace addon_music_spotify {
+
+  class StarredBackgroundLoader: public CThread {
+  public:
+    StarredBackgroundLoader();
+    virtual ~StarredBackgroundLoader();
+
+    void SleepMs(int ms){ Sleep(ms); }
+
+  private:
+    void OnStartup();
+    void OnExit();
+    void OnException(); // signal termination handler
+    void Process();
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* STARREDBACKGROUNDLOADER_H_ */
diff --git a/xbmc/music/spotyXBMC/playlist/StarredList.cpp b/xbmc/music/spotyXBMC/playlist/StarredList.cpp
new file mode 100644
index 0000000..ddfc7d4
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/StarredList.cpp
@@ -0,0 +1,98 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "StarredList.h"
+#include "../session/Session.h"
+#include "../album/SxAlbum.h"
+#include "../track/SxTrack.h"
+#include "../artist/SxArtist.h"
+#include "../album/AlbumStore.h"
+#include "../track/TrackStore.h"
+#include "../artist/ArtistStore.h"
+#include "../Utils.h"
+
+namespace addon_music_spotify {
+
+  using namespace std;
+
+  StarredList::StarredList(sp_playlist* spPlaylist) :
+      SxPlaylist(spPlaylist, 0, false) {
+    m_isBackgroundLoading = false;
+    m_reload = true;
+    populateAlbumsAndArtists();
+  }
+
+  StarredList::~StarredList() {
+    removeAllTracks();
+    removeAllAlbums();
+
+    while (!m_artists.empty()) {
+      ArtistStore::getInstance()->removeArtist(m_artists.back());
+      m_artists.pop_back();
+    }
+  }
+
+  void StarredList::populateAlbumsAndArtists() {
+    Logger::printOut("Populate starred albums and artists");
+    //OK so we got the tracks list populated within the playlist, now create the albums we want
+    //we can't do it in this thread because the albums will never load... create a new thread
+    m_backgroundLoader = new StarredBackgroundLoader();
+    m_backgroundLoader->Create(true);
+  }
+
+  void StarredList::reLoad() {
+    Logger::printOut("reload star");
+    if (m_isBackgroundLoading) {
+      Logger::printOut("starred is loading in the background, set it to redo the loading again");
+      m_reload = true;
+      return;
+    }
+
+    m_reload = true;
+    populateAlbumsAndArtists();
+  }
+
+  SxAlbum *StarredList::getAlbum(int index) {
+    if (index < getNumberOfAlbums()) return m_albums[index];
+    return NULL;
+  }
+
+  bool StarredList::getAlbumItems(CFileItemList& items) {
+    return true;
+  }
+
+  SxArtist *StarredList::getArtist(int index) {
+    if (index < getNumberOfArtists()) return m_artists[index];
+    return NULL;
+  }
+
+  bool StarredList::isLoaded() {
+    if (!tracksLoaded() || !albumsLoaded()) return false;
+
+    for (int i = 0; i < m_artists.size(); i++) {
+      if (!m_artists[i]->isLoaded()) return false;
+    }
+
+    return true;
+  }
+
+} /* namespace addon_music_spotify */
+
diff --git a/xbmc/music/spotyXBMC/playlist/StarredList.h b/xbmc/music/spotyXBMC/playlist/StarredList.h
new file mode 100644
index 0000000..e504d7a
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/StarredList.h
@@ -0,0 +1,66 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef STARREDLISTS_H_
+#define STARREDLISTS_H_
+
+#include "SxPlaylist.h"
+#include "../album/AlbumContainer.h"
+#include "StarredBackgroundLoader.h"
+
+namespace addon_music_spotify {
+
+  class SxAlbum;
+  class SxArtist;
+
+  class StarredList: public SxPlaylist, private AlbumContainer {
+  public:
+    StarredList(sp_playlist* spPlaylist);
+    virtual ~StarredList();
+
+    void populateAlbumsAndArtists();
+    bool isLoaded();
+    void reLoad();
+
+    int getNumberOfAlbums() {
+      return m_albums.size();
+    }
+    SxAlbum* getAlbum(int index);
+
+    bool getAlbumItems(CFileItemList& items);
+
+    int getNumberOfArtists() {
+      return m_artists.size();
+    }
+    SxArtist* getArtist(int index);
+
+    friend class StarredBackgroundLoader;
+
+  private:
+    vector<SxArtist*> m_artists;
+
+    bool m_isBackgroundLoading;
+    bool m_reload;
+    StarredBackgroundLoader* m_backgroundLoader;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* STARREDLISTS_H_ */
diff --git a/xbmc/music/spotyXBMC/playlist/SxPlaylist.cpp b/xbmc/music/spotyXBMC/playlist/SxPlaylist.cpp
new file mode 100644
index 0000000..26d9282
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/SxPlaylist.cpp
@@ -0,0 +1,171 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "SxPlaylist.h"
+#include "../session/Session.h"
+#include "../track/TrackStore.h"
+#include "../thumb/ThumbStore.h"
+#include "../track/SxTrack.h"
+#include "../album/SxAlbum.h"
+#include "../thumb/SxThumb.h"
+#include "../Utils.h"
+
+namespace addon_music_spotify {
+
+  SxPlaylist::SxPlaylist(sp_playlist* spPlaylist, int index, bool isFolder) {
+    m_spPlaylist = spPlaylist;
+    m_isValid = true;
+    m_isFolder = isFolder;
+    m_index = index;
+    m_thumb = NULL;
+
+    if (!isFolder) {
+      if (sp_playlist_is_loaded(spPlaylist)) reLoad();
+      m_plCallbacks.description_changed = 0;
+      m_plCallbacks.image_changed = 0;
+      m_plCallbacks.playlist_metadata_updated = &cb_playlist_metadata_updated;
+      m_plCallbacks.playlist_renamed = &cb_playlist_renamed;
+      m_plCallbacks.playlist_state_changed = &cb_state_change;
+      m_plCallbacks.playlist_update_in_progress = 0;
+      m_plCallbacks.subscribers_changed = 0;
+      m_plCallbacks.track_created_changed = 0;
+      m_plCallbacks.track_message_changed = 0;
+      m_plCallbacks.track_seen_changed = 0;
+      m_plCallbacks.tracks_added = &cb_tracks_added;
+      m_plCallbacks.tracks_moved = &cb_tracks_moved;
+      m_plCallbacks.tracks_removed = &cb_tracks_removed;
+
+      sp_playlist_add_callbacks(spPlaylist, &m_plCallbacks, this);
+    }
+  }
+
+  SxPlaylist::~SxPlaylist() {
+    sp_playlist_remove_callbacks(m_spPlaylist, &m_plCallbacks, this);
+    if (!isFolder()) {
+      removeAllTracks();
+    }
+    //let it bleed a little, not sure if the reference actualy goes up or if it is linked to the container
+    // if (m_isValid)
+    //   sp_playlist_release(m_spPlaylist);
+  }
+
+  const char* SxPlaylist::getName() {
+	 //not the most elegant solution, but if the index is 0, its the inbox
+    return m_index == 0 ? Settings::getInstance()->getInboxString().GetBufferSetLength(Settings::getInstance()->getInboxString().GetLength() +1) : sp_playlist_name(m_spPlaylist);
+  }
+
+  const char* SxPlaylist::getOwnerName() {
+    sp_user* user = sp_playlist_owner(m_spPlaylist);
+    if (user != sp_session_user(Session::getInstance()->getSpSession())) {
+      return sp_user_display_name(user);
+    }
+    return NULL;
+  }
+
+  bool SxPlaylist::isLoaded() {
+    if (!isFolder()) {
+      return tracksLoaded();
+    }
+    return true;
+  }
+
+  SxTrack* SxPlaylist::getTrack(int index) {
+    if (index < getNumberOfTracks() && m_isValid && isLoaded() && !isFolder()) return m_tracks[index];
+    return NULL;
+  }
+
+  bool SxPlaylist::getTrackItems(CFileItemList& items) {
+    return true;
+  }
+
+  void SxPlaylist::reLoad() {
+    Logger::printOut("reload play");
+    if (m_isValid && !isFolder()) {
+      m_thumb = NULL;
+      //TODO fix a thumb, why is it never returning any images?
+      byte image[20];
+      if (sp_playlist_get_image(m_spPlaylist, image)) {
+        m_thumb = ThumbStore::getInstance()->getThumb(image);
+      }
+      Logger::printOut("reload play 3");
+
+      vector<SxTrack*> newTracks;
+      for (int index = 0; index < sp_playlist_num_tracks(m_spPlaylist); index++) {
+        sp_track* spTrack = sp_playlist_track(m_spPlaylist, index);
+        if (!sp_track_get_availability(Session::getInstance()->getSpSession(), spTrack)) continue;
+        SxTrack* track = TrackStore::getInstance()->getTrack(spTrack);
+        if (track) {
+          newTracks.push_back(track);
+          //no thumb, lets pick one from the track list
+          if (m_thumb == NULL)
+          	if (track->getThumb() != NULL)
+              //no need to add ref to the thumb, when the track disappears the playlist will switch thumb
+              m_thumb = track->getThumb();
+        }
+      }
+
+      removeAllTracks();
+
+      Logger::printOut("reload play done");
+      m_tracks = newTracks;
+    }
+    Utils::updatePlaylist(m_index);
+  }
+
+  void SxPlaylist::cb_tracks_removed(sp_playlist *pl, const int *tracks, int num_tracks, void *userdata) {
+    Logger::printOut("playlists cb_tracks_removed");
+    SxPlaylist* plist = (SxPlaylist*) userdata;
+    if (plist->isLoaded()) plist->reLoad();
+  }
+
+  void SxPlaylist::cb_playlist_renamed(sp_playlist *pl, void *userdata) {
+    Logger::printOut("playlists cb_playlist_renamed");
+    //set some kind of dirty flag to the store
+  }
+
+  void SxPlaylist::cb_playlist_metadata_updated(sp_playlist *pl, void *userdata) {
+    Logger::printOut("playlists cb_playlist_metadata_updated");
+
+    //skip the updating, the metadata we have will do for now :)
+    SxPlaylist* plist = (SxPlaylist*) userdata;
+    if (plist->isLoaded()) plist->reLoad();
+  }
+
+  void SxPlaylist::cb_tracks_moved(sp_playlist *pl, const int *tracks, int num_tracks, int new_position, void *userdata) {
+    Logger::printOut("playlists cb_tracks_moved");
+    SxPlaylist* plist = (SxPlaylist*) userdata;
+    if (plist->isLoaded()) plist->reLoad();
+  }
+
+  void SxPlaylist::cb_state_change(sp_playlist *pl, void *userdata) {
+    Logger::printOut("playlists cb_state_change");
+    SxPlaylist* plist = (SxPlaylist*) userdata;
+    if (plist->isLoaded()) plist->reLoad();
+  }
+
+  void SxPlaylist::cb_tracks_added(sp_playlist *pl, sp_track * const *tracks, int num_tracks, int position, void *userdata) {
+    Logger::printOut("playlists cb_tracks_added");
+    SxPlaylist* plist = (SxPlaylist*) userdata;
+    if (plist->isLoaded()) plist->reLoad();
+  }
+
+} /* namespace addon_music_spotify */
+
diff --git a/xbmc/music/spotyXBMC/playlist/SxPlaylist.h b/xbmc/music/spotyXBMC/playlist/SxPlaylist.h
new file mode 100644
index 0000000..b617419
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/SxPlaylist.h
@@ -0,0 +1,90 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SXPLAYLIST_H_
+#define SXPLAYLIST_H_
+
+#include <libspotify/api.h>
+#include "../track/TrackContainer.h"
+#include <vector>
+
+namespace addon_music_spotify {
+
+  using namespace std;
+  class TrackStore;
+  class ThumbStore;
+  class SxThumb;
+  class SxTrack;
+
+  class SxPlaylist: protected TrackContainer {
+  public:
+    SxPlaylist(sp_playlist* spSxPlaylist, int index, bool isFolder);
+    virtual ~SxPlaylist();
+
+    void init();
+
+    static void SP_CALLCONV cb_state_change(sp_playlist *pl, void *userdata);
+    static void SP_CALLCONV cb_tracks_added(sp_playlist *pl, sp_track * const *tracks, int num_tracks, int position, void *userdata);
+    static void SP_CALLCONV cb_tracks_removed(sp_playlist *pl, const int *tracks, int num_tracks, void *userdata);
+    static void SP_CALLCONV cb_playlist_renamed(sp_playlist *pl, void *userdata);
+    static void SP_CALLCONV cb_playlist_metadata_updated(sp_playlist *pl, void *userdata);
+    static void SP_CALLCONV cb_tracks_moved(sp_playlist *pl, const int *tracks, int num_tracks, int new_position, void *userdata);
+
+    virtual bool isLoaded();
+    const char* getName();
+    const char* getOwnerName();
+    int getNumberOfTracks() {
+      return m_tracks.size();
+    }
+    int getIndex() {
+      return m_index;
+    }
+    bool isFolder() {
+      return m_isFolder;
+    }
+    SxTrack* getTrack(int index);
+
+    bool getTrackItems(CFileItemList& items);
+
+    SxThumb* getThumb() {
+      return m_thumb;
+    }
+    virtual void reLoad();
+    //call this when the playlist is removed from spotify and the pointer is no longer valid
+    void makeInvalid() {
+      m_isValid = false;
+    }
+
+  protected:
+    bool m_isValid;
+    sp_playlist* m_spPlaylist;
+
+  private:
+    bool m_isFolder;
+    int m_index;
+    SxThumb* m_thumb;
+    sp_playlist_callbacks m_plCallbacks;
+    const char* ownerName;
+
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SXPLAYLIST_H_ */
diff --git a/xbmc/music/spotyXBMC/playlist/TopLists.cpp b/xbmc/music/spotyXBMC/playlist/TopLists.cpp
new file mode 100644
index 0000000..92df520
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/TopLists.cpp
@@ -0,0 +1,220 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "TopLists.h"
+#include "../session/Session.h"
+#include "../SxSettings.h"
+#include <sys/timeb.h>
+
+namespace addon_music_spotify {
+
+TopLists::TopLists() {
+	m_albumsNextReload.SetExpired();
+	m_artistsNextReload.SetExpired();
+	m_tracksNextReload.SetExpired();
+	m_waitingForAlbums = false;
+	m_waitingForArtists = false;
+	m_waitingForTracks = false;
+	m_albumsLoaded = false;
+	m_artistsLoaded = false;
+	m_tracksLoaded = false;
+	Logger::printOut("creating toplists");
+	if (Settings::getInstance()->getPreloadTopLists()) {
+		reLoadArtists();
+		reLoadAlbums();
+		reLoadTracks();
+	}
+}
+
+TopLists::~TopLists() {
+	unloadLists();
+}
+
+void TopLists::unloadLists() {
+	m_albumsLoaded = false;
+	m_artistsLoaded = false;
+	m_tracksLoaded = false;
+
+	removeAllTracks();
+	removeAllAlbums();
+	removeAllArtists();
+}
+
+void TopLists::reLoadArtists() {
+	if (m_waitingForArtists)
+		return;
+	m_waitingForArtists = true;
+	sp_toplistregion region =
+			Settings::getInstance()->toplistRegionEverywhere() ?
+					SP_TOPLIST_REGION_EVERYWHERE :
+					(sp_toplistregion) sp_session_user_country(
+							Session::getInstance()->getSpSession());
+	sp_toplistbrowse_create(Session::getInstance()->getSpSession(),
+			SP_TOPLIST_TYPE_ARTISTS, region, Settings::getInstance()->getUserName(),
+			&cb_toplistArtistsComplete, this);
+}
+
+void TopLists::reLoadAlbums() {
+	if (m_waitingForAlbums)
+		return;
+	m_waitingForAlbums = true;
+	sp_toplistregion region =
+			Settings::getInstance()->toplistRegionEverywhere() ?
+					SP_TOPLIST_REGION_EVERYWHERE :
+					(sp_toplistregion) sp_session_user_country(
+							Session::getInstance()->getSpSession());
+	sp_toplistbrowse_create(Session::getInstance()->getSpSession(),
+			SP_TOPLIST_TYPE_ALBUMS, region, Settings::getInstance()->getUserName(),
+			&cb_toplistAlbumsComplete, this);
+}
+
+void TopLists::reLoadTracks() {
+	if (m_waitingForTracks)
+		return;
+	m_waitingForTracks = true;
+	sp_toplistregion region =
+			Settings::getInstance()->toplistRegionEverywhere() ?
+					SP_TOPLIST_REGION_EVERYWHERE :
+					(sp_toplistregion) sp_session_user_country(
+							Session::getInstance()->getSpSession());
+	sp_toplistbrowse_create(Session::getInstance()->getSpSession(),
+			SP_TOPLIST_TYPE_TRACKS, region, Settings::getInstance()->getUserName(),
+			&cb_toplistTracksComplete, this);
+}
+
+bool TopLists::isArtistsLoaded() {
+	if (!m_artistsLoaded || m_artistsNextReload.IsTimePast())
+		return false;
+	return artistsLoaded();
+}
+
+bool TopLists::isAlbumsLoaded() {
+	if (!m_albumsLoaded || m_albumsNextReload.IsTimePast())
+		return false;
+	return albumsLoaded();
+}
+
+bool TopLists::isTracksLoaded() {
+	if (!m_tracksLoaded || m_tracksNextReload.IsTimePast())
+		return false;
+	return tracksLoaded();
+}
+
+bool TopLists::getArtistItems(CFileItemList& items) {
+	return true;
+}
+
+bool TopLists::getAlbumItems(CFileItemList& items) {
+	return true;
+}
+
+bool TopLists::getTrackItems(CFileItemList& items) {
+	return true;
+}
+
+void TopLists::cb_toplistArtistsComplete(sp_toplistbrowse *result,
+		void *userdata) {
+	Logger::printOut("toplist artists callback");
+	TopLists *lists = (TopLists*) (userdata);
+
+	vector<SxArtist*> newArtists;
+
+	for (int index = 0; index < sp_toplistbrowse_num_artists(result); index++) {
+		//dont load the albums and tracks for all artists here, it takes forever
+		SxArtist* artist = ArtistStore::getInstance()->getArtist(
+				sp_toplistbrowse_artist(result, index), false);
+		if (artist != NULL)
+			newArtists.push_back(artist);
+	}
+
+	lists->removeAllArtists();
+	lists->m_artists = newArtists;
+
+	struct timeb tmb;
+	ftime(&tmb);
+	lists->m_artistsNextReload.Set(1000 * 60 * 60 * 24);
+	lists->m_waitingForArtists = false;
+	lists->m_artistsLoaded = true;
+	Logger::printOut("Toplist artists loaded");
+}
+
+void TopLists::cb_toplistAlbumsComplete(sp_toplistbrowse *result,
+		void *userdata) {
+	Logger::printOut("toplist albums callback");
+	TopLists *lists = (TopLists*) (userdata);
+
+	vector<SxAlbum*> newAlbums;
+
+	for (int index = 0; index < sp_toplistbrowse_num_albums(result); index++) {
+		sp_album* tempalbum = sp_toplistbrowse_album(result, index);
+		if (tempalbum == NULL)
+			continue;
+		while (!sp_album_is_loaded(tempalbum))
+			;
+
+		if (sp_album_is_available(tempalbum)) {
+			SxAlbum* album = AlbumStore::getInstance()->getAlbum(tempalbum, true);
+			if (album != NULL)
+				newAlbums.push_back(album);
+		}
+	}
+
+	lists->removeAllAlbums();
+	lists->m_albums = newAlbums;
+
+	struct timeb tmb;
+	ftime(&tmb);
+	lists->m_albumsNextReload.Set(1000 * 60 * 60 * 24);
+	lists->m_waitingForAlbums = false;
+	lists->m_albumsLoaded = true;
+	Logger::printOut("Toplist albums loaded");
+}
+
+void TopLists::cb_toplistTracksComplete(sp_toplistbrowse *result,
+		void *userdata) {
+	Logger::printOut("toplist tracks callback");
+	TopLists *lists = (TopLists*) (userdata);
+	//add the tracks
+
+	vector<SxTrack*> newTracks;
+
+	for (int index = 0; index < sp_toplistbrowse_num_tracks(result); index++) {
+		if (sp_track_get_availability(Session::getInstance()->getSpSession(),
+				sp_toplistbrowse_track(result, index))) {
+			SxTrack* track = TrackStore::getInstance()->getTrack(
+					sp_toplistbrowse_track(result, index));
+			if (track != NULL)
+				newTracks.push_back(track);
+		}
+	}
+
+	lists->removeAllTracks();
+	lists->m_tracks = newTracks;
+
+	struct timeb tmb;
+	ftime(&tmb);
+	lists->m_tracksNextReload.Set(1000 * 60 * 60 * 24);
+	lists->m_waitingForTracks = false;
+	lists->m_tracksLoaded = true;
+	Logger::printOut("Toplist tracks loaded");
+}
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/playlist/TopLists.h b/xbmc/music/spotyXBMC/playlist/TopLists.h
new file mode 100644
index 0000000..4be6690
--- /dev/null
+++ b/xbmc/music/spotyXBMC/playlist/TopLists.h
@@ -0,0 +1,108 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef TOPLISTS_H_
+#define TOPLISTS_H_
+
+#ifndef SP_CALLCONV
+#ifdef _WIN32
+#define SP_CALLCONV __stdcall
+#else
+#define SP_CALLCONV
+#endif
+#endif
+
+#include <libspotify/api.h>
+#include <vector>
+#include "../../../threads/SystemClock.h"
+#include "../track/TrackStore.h"
+#include "../album/AlbumStore.h"
+#include "../artist/ArtistStore.h"
+#include "../artist/ArtistContainer.h"
+#include "../album/AlbumContainer.h"
+#include "../track/TrackContainer.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class TopLists: private AlbumContainer, private TrackContainer, private ArtistContainer {
+  public:
+    TopLists();
+    virtual ~TopLists();
+
+    static void SP_CALLCONV cb_toplistArtistsComplete(sp_toplistbrowse *result, void *userdata);
+    void artistListLoaded(sp_toplistbrowse *result);
+
+    static void SP_CALLCONV cb_toplistAlbumsComplete(sp_toplistbrowse *result, void *userdata);
+    void albumListLoaded(sp_toplistbrowse *result);
+
+    static void SP_CALLCONV cb_toplistTracksComplete(sp_toplistbrowse *result, void *userdata);
+    void trackListLoaded(sp_toplistbrowse *result);
+
+    //we can load on demand, so even if nothing is loaded, the object is loaded
+    bool isLoaded() {
+      return true;
+    }
+
+    //call this from the advance api thread, it will reload every 12 hours
+    //TODO actually do it!
+    void reLoadArtists();
+    void reLoadAlbums();
+    void reLoadTracks();
+    void unloadLists();
+
+    bool isArtistsLoaded();
+    bool isAlbumsLoaded();
+    bool isTracksLoaded();
+
+    vector<SxArtist*> getArtists() {
+      return m_artists;
+    }
+
+    bool getArtistItems(CFileItemList& items);
+
+    vector<SxAlbum*> getAlbums() {
+      return m_albums;
+    }
+
+    bool getAlbumItems(CFileItemList& items);
+
+    vector<SxTrack*> getTracks() {
+      return m_tracks;
+    }
+
+    bool getTrackItems(CFileItemList& items);
+
+  private:
+    bool m_albumsLoaded;
+    bool m_artistsLoaded;
+    bool m_tracksLoaded;
+    bool m_waitingForAlbums;
+    bool m_waitingForArtists;
+    bool m_waitingForTracks;
+    XbmcThreads::EndTime m_albumsNextReload;
+    XbmcThreads::EndTime m_artistsNextReload;
+    XbmcThreads::EndTime m_tracksNextReload;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* TOPLISTS_H_ */
diff --git a/xbmc/music/spotyXBMC/radio/RadioBackgroundLoader.cpp b/xbmc/music/spotyXBMC/radio/RadioBackgroundLoader.cpp
new file mode 100644
index 0000000..8f72cf4
--- /dev/null
+++ b/xbmc/music/spotyXBMC/radio/RadioBackgroundLoader.cpp
@@ -0,0 +1,85 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "RadioHandler.h"
+#include "../album/AlbumStore.h"
+#include "../track/TrackStore.h"
+#include "../artist/ArtistStore.h"
+#include "../session/Session.h"
+#include "RadioBackgroundLoader.h"
+#include "../Utils.h"
+
+namespace addon_music_spotify {
+
+  RadioBackgroundLoader::RadioBackgroundLoader(SxRadio* radio) : CThread("Spotify RadioBackgroundLoader") {
+    m_radio = radio;
+  }
+
+  RadioBackgroundLoader::~RadioBackgroundLoader() {
+    // TODO Auto-generated destructor stub
+  }
+
+  void RadioBackgroundLoader::OnStartup() {
+  }
+
+  void RadioBackgroundLoader::OnExit() {
+  }
+
+  void RadioBackgroundLoader::OnException() {
+  }
+
+  void RadioBackgroundLoader::Process() {
+    if (m_radio->m_isWaitingForResults) return;
+    while (!Session::getInstance()->lock()) {
+      SleepMs(1);
+    }
+
+    //add the tracks
+    if (m_radio->m_currentSearch != NULL) {
+      //if there are no tracks, return and break
+      if (sp_search_num_tracks(m_radio->m_currentSearch) == 0) return;
+
+      for (int index = m_radio->m_currentResultPos; index < sp_search_num_tracks(m_radio->m_currentSearch) && m_radio->m_tracks.size() < m_radio->m_numberOfTracksToDisplay; index++) {
+        if (sp_track_get_availability(Session::getInstance()->getSpSession(), sp_search_track(m_radio->m_currentSearch, index))) {
+          m_radio->m_tracks.push_back(TrackStore::getInstance()->getTrack(sp_search_track(m_radio->m_currentSearch, index)));
+        }
+        m_radio->m_currentResultPos++;
+      }
+    }
+
+    //are we still missing tracks? Do a new search
+    if (m_radio->m_tracks.size() < m_radio->m_numberOfTracksToDisplay) {
+      m_radio->m_isWaitingForResults = true;
+      m_radio->m_currentSearch = sp_radio_search_create(Session::getInstance()->getSpSession(), m_radio->m_fromYear, m_radio->m_toYear, m_radio->m_genres, &m_radio->cb_searchComplete, m_radio);
+      Session::getInstance()->unlock();
+    } else {
+      Logger::printOut("radio fetch tracks done");
+      Session::getInstance()->unlock();
+      while (!m_radio->isLoaded()) {
+        SleepMs(1);
+      }
+
+      if (m_radio->m_tracks.size() > 0) RadioHandler::getInstance()->allTracksLoaded(m_radio->m_radioNumber);
+    }
+  }
+}
+
+/* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/radio/RadioBackgroundLoader.h b/xbmc/music/spotyXBMC/radio/RadioBackgroundLoader.h
new file mode 100644
index 0000000..c95f354
--- /dev/null
+++ b/xbmc/music/spotyXBMC/radio/RadioBackgroundLoader.h
@@ -0,0 +1,48 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef RADIOBACKGROUNDLOADER_H_
+#define RADIOBACKGROUNDLOADER_H_
+
+#include "threads/Thread.h"
+#include "SxRadio.h"
+
+namespace addon_music_spotify {
+
+  class RadioBackgroundLoader: public CThread {
+  public:
+    RadioBackgroundLoader(SxRadio* radio);
+    virtual ~RadioBackgroundLoader();
+
+    void SleepMs(int ms) {
+      Sleep(ms);
+    }
+  private:
+    void OnStartup();
+    void OnExit();
+    void OnException(); // signal termination handler
+    void Process();
+    SxRadio* m_radio;
+
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* RADIOBACKGROUNDLOADER_H_ */
diff --git a/xbmc/music/spotyXBMC/radio/RadioHandler.cpp b/xbmc/music/spotyXBMC/radio/RadioHandler.cpp
new file mode 100644
index 0000000..dd01be7
--- /dev/null
+++ b/xbmc/music/spotyXBMC/radio/RadioHandler.cpp
@@ -0,0 +1,107 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "RadioHandler.h"
+#include "../SxSettings.h"
+#include "../Utils.h"
+#include "../Logger.h"
+#include "../../PlayListPlayer.h"
+#include "../../../playlists/PlayList.h"
+#include "../Addon.music.spotify.h"
+#include "guilib/GUIWindowManager.h"
+
+using namespace PLAYLIST;
+
+namespace addon_music_spotify {
+
+  RadioHandler::RadioHandler() {
+    Logger::printOut("creating radio handler");
+    //hardcode two radios, allow for any number of radios later maybe
+    SxRadio *radio1 = new SxRadio(1, Settings::getInstance()->getRadio1From(), Settings::getInstance()->getRadio1To(), Settings::getInstance()->getRadio1Genres());
+    SxRadio *radio2 = new SxRadio(2, Settings::getInstance()->getRadio2From(), Settings::getInstance()->getRadio2To(), Settings::getInstance()->getRadio2Genres());
+
+    m_radios.push_back(radio1);
+    m_radios.push_back(radio2);
+    Logger::printOut("creating radio handler done");
+  }
+
+  RadioHandler* RadioHandler::m_instance = 0;
+  RadioHandler *RadioHandler::getInstance() {
+    return m_instance ? m_instance : (m_instance = new RadioHandler);
+  }
+
+  void RadioHandler::deInit() {
+    delete m_instance;
+  }
+
+  RadioHandler::~RadioHandler() {
+    while (!m_radios.empty()) {
+      delete m_radios.back();
+      m_radios.pop_back();
+    }
+  }
+
+  void RadioHandler::allTracksLoaded(int radioNumber) {
+    Utils::updateRadio(radioNumber);
+
+    CStdString path;
+    path.Format("musicdb://3/spotify:radio:%i/", radioNumber);
+    //TODO update the now playing playlist with the new songs
+    Logger::printOut("updating now playing");
+    if (g_playlistPlayer.GetCurrentPlaylist() == PLAYLIST_MUSIC && m_radios[radioNumber - 1] != NULL && m_radios[radioNumber - 1]->m_currentPlayingPos != 0) {
+	  CPlayList& playlist = g_playlistPlayer.GetPlaylist(PLAYLIST_MUSIC);
+      g_playlistPlayer.SetCurrentSong(0); 
+      CStdString path;
+      path.Format("musicdb://3/spotify:radio:%i/", radioNumber);
+      CFileItemList items;
+      g_spotify->GetTracks(items, path, "", -1);
+	  playlist.Clear();
+      playlist.Add(items);
+      g_playlistPlayer.SetCurrentSong(0);
+    }
+  }
+
+  vector<SxTrack*> RadioHandler::getTracks(int radioNumber) {
+    Logger::printOut("get tracks handler");
+    if (radioNumber - 1 < m_radios.size()) {
+      //if (m_radios[radioNumber - 1]->isLoaded())
+      return m_radios[radioNumber - 1]->m_tracks;
+    }
+    Logger::printOut("get tracks handler radio not loaded");
+    vector<SxTrack*> empty;
+    return empty;
+  }
+
+  int RadioHandler::getLowestTrackNumber(int radioNumber) {
+    Logger::printOut("get lowest trackNumber handler");
+    if (radioNumber - 1 < m_radios.size()) {
+      return m_radios[radioNumber - 1]->m_currentPlayingPos;
+    }
+    return 0;
+  }
+
+  void RadioHandler::pushToTrack(int radioNumber, int trackNumber) {
+    if (radioNumber - 1 < m_radios.size()) {
+      m_radios[radioNumber - 1]->pushToTrack(trackNumber);
+    }
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/radio/RadioHandler.h b/xbmc/music/spotyXBMC/radio/RadioHandler.h
new file mode 100644
index 0000000..eb89e22
--- /dev/null
+++ b/xbmc/music/spotyXBMC/radio/RadioHandler.h
@@ -0,0 +1,51 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef RADIOHANDLER_H_
+#define RADIOHANDLER_H_
+
+#include "SxRadio.h"
+
+namespace addon_music_spotify {
+
+  class RadioHandler {
+  public:
+
+    static RadioHandler *getInstance();
+    static void deInit();
+
+    void pushToTrack(int radioNumber, int trackNumber);
+
+    void allTracksLoaded(int radioNumber);
+    int getLowestTrackNumber(int radioNumber);
+
+    vector<SxTrack*> getTracks(int radioNumber);
+
+  private:
+    RadioHandler();
+    virtual ~RadioHandler();
+    static RadioHandler *m_instance;
+
+    vector<SxRadio*> m_radios;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* RADIOHANDLER_H_ */
diff --git a/xbmc/music/spotyXBMC/radio/SxRadio.cpp b/xbmc/music/spotyXBMC/radio/SxRadio.cpp
new file mode 100644
index 0000000..d401da0
--- /dev/null
+++ b/xbmc/music/spotyXBMC/radio/SxRadio.cpp
@@ -0,0 +1,89 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "SxRadio.h"
+#include "../Logger.h"
+#include "../track/SxTrack.h"
+#include "../track/TrackStore.h"
+#include "../session/Session.h"
+#include "RadioHandler.h"
+#include "RadioBackgroundLoader.h"
+
+namespace addon_music_spotify {
+
+  SxRadio::SxRadio(int radioNumber, int fromYear, int toYear, sp_radio_genre genres) {
+    m_radioNumber = radioNumber;
+    m_fromYear = fromYear;
+    m_toYear = toYear;
+    m_genres = genres;
+    m_currentPlayingPos = 0;
+    m_currentResultPos = 0;
+    m_currentSearch = NULL;
+    //hard code the number of tracks to 15 for now
+    m_numberOfTracksToDisplay = Settings::getInstance()->getRadioNumberTracks();
+    m_isWaitingForResults = false;
+    fetchNewTracks();
+  }
+
+  SxRadio::~SxRadio() {
+    removeAllTracks();
+  }
+
+  bool SxRadio::isLoaded() {
+    if (m_isWaitingForResults) return false;
+    return tracksLoaded();
+  }
+
+  bool SxRadio::getTrackItems(CFileItemList& items) {
+    return true;
+  }
+
+  void SxRadio::pushToTrack(int trackNumber) {
+    Logger::printOut("SxRadio::pushToTrack");
+    while (m_currentPlayingPos < trackNumber) {
+      //kind of stupid to use a vector here, a list or dequeue is maybe better, change sometime...
+      TrackStore::getInstance()->removeTrack(m_tracks.front());
+      m_tracks.erase(m_tracks.begin());
+      m_currentPlayingPos++;
+    }
+    m_currentPlayingPos = trackNumber;
+    fetchNewTracks();
+  }
+
+  void SxRadio::fetchNewTracks() {
+    RadioBackgroundLoader* loader = new RadioBackgroundLoader(this);
+    loader->Create(true);
+  }
+
+  void SxRadio::newResults(sp_search* search) {
+    Logger::printOut("new radio result");
+    m_currentSearch = search;
+    m_currentResultPos = 0;
+    m_isWaitingForResults = false;
+    fetchNewTracks();
+  }
+
+  void SxRadio::cb_searchComplete(sp_search *search, void *userdata) {
+    SxRadio* searchObj = (SxRadio*) userdata;
+    searchObj->newResults(search);
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/radio/SxRadio.h b/xbmc/music/spotyXBMC/radio/SxRadio.h
new file mode 100644
index 0000000..57ed770
--- /dev/null
+++ b/xbmc/music/spotyXBMC/radio/SxRadio.h
@@ -0,0 +1,71 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SXRADIO_H_
+#define SXRADIO_H_
+
+#include <libspotify/api.h>
+#include "../track/TrackContainer.h"
+#include <vector>
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class SxTrack;
+  class SxRadio: private TrackContainer {
+  public:
+
+    static void SP_CALLCONV cb_searchComplete(sp_search *search, void *userdata);
+    void newResults(sp_search* search);
+
+    //this is called from the player when it is advancing to next track
+    void pushToTrack(int trackNumber);
+
+    bool getTrackItems(CFileItemList& items);
+
+    friend class RadioHandler;
+    friend class RadioBackgroundLoader;
+
+
+  private:
+    SxRadio(int radioNumber, int fromYear, int toYear, sp_radio_genre genres);
+    virtual ~SxRadio();
+
+    bool isLoaded();
+
+    int m_numberOfTracksToDisplay;
+    int m_radioNumber;
+
+    void fetchNewTracks();
+
+    bool m_isWaitingForResults;
+    sp_search* m_currentSearch;
+
+    sp_radio_genre m_genres;
+    int m_fromYear;
+    int m_toYear;
+    int m_currentPlayingPos;
+    int m_currentResultPos;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SXRADIO_H_ */
diff --git a/xbmc/music/spotyXBMC/search/Search.cpp b/xbmc/music/spotyXBMC/search/Search.cpp
new file mode 100644
index 0000000..2397b45
--- /dev/null
+++ b/xbmc/music/spotyXBMC/search/Search.cpp
@@ -0,0 +1,89 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "Search.h"
+#include "../session/Session.h"
+#include "../Logger.h"
+#include "../Utils.h"
+#include "../SxSettings.h"
+#include "SearchResultBackgroundLoader.h"
+#include "../album/SxAlbum.h"
+#include "../track/SxTrack.h"
+#include "../artist/SxArtist.h"
+
+namespace addon_music_spotify {
+
+  Search::Search(string query) {
+    m_maxArtistResults = Settings::getInstance()->getSearchNumberArtists();
+    m_maxAlbumResults = Settings::getInstance()->getSearchNumberAlbums();
+    m_maxTrackResults = Settings::getInstance()->getSearchNumberTracks();
+
+    m_query = query;
+
+    m_artistsDone = false;
+    m_albumsDone = false;
+    m_tracksDone = false;
+
+    //do the initial search
+    m_cancelSearch = false;
+    Logger::printOut("creating search");
+    Logger::printOut(query);
+    m_currentSearch = sp_search_create(Session::getInstance()->getSpSession(), m_query.c_str(), 0, m_maxTrackResults, 0, m_maxAlbumResults, 0, m_maxArtistResults, &cb_searchComplete, this);
+
+  }
+
+  Search::~Search() {
+    //we need to wait for the results
+    //m_cancelSearch = true;
+    //while (m_currentSearch != NULL)
+    //  ;
+    Logger::printOut("cleaning after search");
+    removeAllTracks();
+    removeAllAlbums();
+    removeAllArtists();
+    Logger::printOut("cleaning after search done");
+
+  }
+
+  bool Search::getTrackItems(CFileItemList& items) {
+    return true;
+  }
+
+  bool Search::getAlbumItems(CFileItemList& items) {
+    return true;
+  }
+
+  bool Search::getArtistItems(CFileItemList& items) {
+    return true;
+  }
+
+  bool Search::isLoaded() {
+    return (tracksLoaded() && albumsLoaded() && artistsLoaded());
+  }
+
+  void Search::cb_searchComplete(sp_search *search, void *userdata) {
+    Search* searchObj = (Search*) userdata;
+    searchObj->m_currentSearch = search;
+    SearchResultBackgroundLoader* loader = new SearchResultBackgroundLoader(searchObj);
+    loader->Create(true);
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/search/Search.h b/xbmc/music/spotyXBMC/search/Search.h
new file mode 100644
index 0000000..cba0bc0
--- /dev/null
+++ b/xbmc/music/spotyXBMC/search/Search.h
@@ -0,0 +1,88 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SEARCH_H_
+#define SEARCH_H_
+
+#include <libspotify/api.h>
+#include <string>
+#include <vector>
+#include "../album/AlbumContainer.h"
+#include "../artist/ArtistContainer.h"
+#include "../track/TrackContainer.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class Search: private TrackContainer, private AlbumContainer, private ArtistContainer  {
+  public:
+    Search(string query);
+    virtual ~Search();
+
+    string getQuery() {
+      return m_query;
+    }
+    vector<SxTrack*> getTracks() {
+      return m_tracks;
+    }
+
+
+    bool getTrackItems(CFileItemList& items);
+
+    vector<SxAlbum*> getAlbums() {
+      return m_albums;
+    }
+
+    bool getAlbumItems(CFileItemList& items);
+
+    vector<SxArtist*> getArtists() {
+      return m_artists;
+    }
+
+    bool getArtistItems(CFileItemList& items);
+
+    static void SP_CALLCONV cb_searchComplete(sp_search *search, void *userdata);
+
+    bool isLoaded();
+
+    friend class SearchResultBackgroundLoader;
+
+  private:
+    void newResults(sp_search *search);
+
+    string m_query;
+
+    int m_maxAlbumResults;
+    int m_maxArtistResults;
+    int m_maxTrackResults;
+
+    bool m_artistsDone;
+    bool m_albumsDone;
+    bool m_tracksDone;
+
+    sp_search* m_currentSearch;
+
+    bool m_cancelSearch;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SEARCH_H_ */
diff --git a/xbmc/music/spotyXBMC/search/SearchHandler.cpp b/xbmc/music/spotyXBMC/search/SearchHandler.cpp
new file mode 100644
index 0000000..9b04545
--- /dev/null
+++ b/xbmc/music/spotyXBMC/search/SearchHandler.cpp
@@ -0,0 +1,77 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "SearchHandler.h"
+#include <stdio.h>
+#include "../Logger.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  SearchHandler* SearchHandler::m_instance = 0;
+  SearchHandler *SearchHandler::getInstance() {
+    return m_instance ? m_instance : (m_instance = new SearchHandler);
+  }
+
+  SearchHandler::SearchHandler() {
+    m_currentSearch = NULL;
+
+  }
+
+  void SearchHandler::deInit() {
+    delete m_instance;
+  }
+
+  bool SearchHandler::search(string query) {
+    if (m_currentSearch != NULL) {
+      Logger::printOut("m_currentSearch not NULL");
+      if (m_currentSearch->getQuery() == query) {
+        //if its the same query we are holding, return false and fetch albums instead
+        return false;
+      }
+      Logger::printOut("delete m_currentSearch");
+      delete m_currentSearch;
+      m_currentSearch = NULL;
+    }
+    Logger::printOut("creating m_currentSearch");
+    m_currentSearch = new Search(query);
+    Logger::printOut("returning m_currentSearch");
+    return true;
+  }
+
+  vector<SxAlbum*> SearchHandler::getAlbumResults() {
+    if (m_currentSearch != NULL) return m_currentSearch->getAlbums();
+  }
+
+  vector<SxTrack*> SearchHandler::getTrackResults() {
+    if (m_currentSearch != NULL) return m_currentSearch->getTracks();
+  }
+
+  vector<SxArtist*> SearchHandler::getArtistResults() {
+    if (m_currentSearch != NULL) return m_currentSearch->getArtists();
+  }
+
+  SearchHandler::~SearchHandler() {
+    if (m_currentSearch != NULL) delete m_currentSearch;
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/search/SearchHandler.h b/xbmc/music/spotyXBMC/search/SearchHandler.h
new file mode 100644
index 0000000..dd110f4
--- /dev/null
+++ b/xbmc/music/spotyXBMC/search/SearchHandler.h
@@ -0,0 +1,58 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SEARCHHANDLER_H_
+#define SEARCHHANDLER_H_
+
+#include <vector>
+#include <string>
+#include <libspotify/api.h>
+#include "Search.h"
+#include "../album/SxAlbum.h"
+#include "../artist/SxArtist.h"
+
+using namespace std;
+namespace addon_music_spotify {
+
+  class SearchHandler {
+  public:
+    static SearchHandler *getInstance();
+    static void deInit();
+
+    bool search(string query);
+    bool hasSearch() {
+      return m_currentSearch != NULL;
+    }
+    vector<SxAlbum*> getAlbumResults();
+    vector<SxTrack*> getTrackResults();
+    vector<SxArtist*> getArtistResults();
+
+  private:
+    SearchHandler();
+    virtual ~SearchHandler();
+
+    Search* m_currentSearch;
+
+    static SearchHandler *m_instance;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SEARCHHANDLER_H_ */
diff --git a/xbmc/music/spotyXBMC/search/SearchResultBackgroundLoader.cpp b/xbmc/music/spotyXBMC/search/SearchResultBackgroundLoader.cpp
new file mode 100644
index 0000000..927fc78
--- /dev/null
+++ b/xbmc/music/spotyXBMC/search/SearchResultBackgroundLoader.cpp
@@ -0,0 +1,95 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "../album/AlbumStore.h"
+#include "../track/TrackStore.h"
+#include "../artist/ArtistStore.h"
+#include "../session/Session.h"
+#include "SearchResultBackgroundLoader.h"
+#include "../Utils.h"
+
+namespace addon_music_spotify {
+
+  SearchResultBackgroundLoader::SearchResultBackgroundLoader(Search* search) : CThread("Spotify SearchResultBackgroundLoader"){
+    m_search = search;
+  }
+
+  SearchResultBackgroundLoader::~SearchResultBackgroundLoader() {
+    // TODO Auto-generated destructor stub
+  }
+
+  void SearchResultBackgroundLoader::OnStartup() {
+  }
+
+  void SearchResultBackgroundLoader::OnExit() {
+  }
+
+  void SearchResultBackgroundLoader::OnException() {
+  }
+
+  void SearchResultBackgroundLoader::Process() {
+    while (!Session::getInstance()->lock()) {
+      SleepMs(1);
+    }
+
+    if (m_search->m_cancelSearch) {
+      Logger::printOut("search results arived, aborting due to request");
+      sp_search_release(m_search->m_currentSearch);
+      Session::getInstance()->unlock();
+      return;
+    }
+    Logger::printOut("search results arived");
+
+    //add the albums
+    for (int index = 0; index < sp_search_num_albums(m_search->m_currentSearch); index++) {
+      if (sp_album_is_available(sp_search_album(m_search->m_currentSearch, index))) {
+        m_search->m_albums.push_back(AlbumStore::getInstance()->getAlbum(sp_search_album(m_search->m_currentSearch, index), true));
+      }
+    }
+
+    //add the tracks
+    for (int index = 0; index < sp_search_num_tracks(m_search->m_currentSearch); index++) {
+      if (sp_track_get_availability(Session::getInstance()->getSpSession(), sp_search_track(m_search->m_currentSearch, index))) {
+        m_search->m_tracks.push_back(TrackStore::getInstance()->getTrack(sp_search_track(m_search->m_currentSearch, index)));
+      }
+    }
+
+    //add the artists
+    for (int index = 0; index < sp_search_num_artists(m_search->m_currentSearch); index++) {
+      //dont load the albums and tracks for all artists here, it takes forever
+      m_search->m_artists.push_back(ArtistStore::getInstance()->getArtist(sp_search_artist(m_search->m_currentSearch, index), false));
+    }
+
+    sp_search_release(m_search->m_currentSearch);
+
+    //wait for all albums, tracks and artists to load before calling out
+    Session::getInstance()->unlock();
+    while (!m_search->isLoaded()) {
+      SleepMs(1);
+    }
+
+    Utils::updateSearchResults(m_search->m_query);
+    Logger::printOut("search results done");
+  }
+
+}
+
+/* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/search/SearchResultBackgroundLoader.h b/xbmc/music/spotyXBMC/search/SearchResultBackgroundLoader.h
new file mode 100644
index 0000000..dfa2086
--- /dev/null
+++ b/xbmc/music/spotyXBMC/search/SearchResultBackgroundLoader.h
@@ -0,0 +1,47 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SEARCHRESULTBACKGROUNDLOADER_H_
+#define SEARCHRESULTBACKGROUNDLOADER_H_
+
+#include "threads/Thread.h"
+#include "Search.h"
+
+namespace addon_music_spotify {
+
+  class SearchResultBackgroundLoader: public CThread {
+  public:
+    SearchResultBackgroundLoader(Search* search);
+    virtual ~SearchResultBackgroundLoader();
+
+    void SleepMs(int ms) {
+      Sleep(ms);
+    }
+  private:
+    void OnStartup();
+    void OnExit();
+    void OnException(); // signal termination handler
+    void Process();
+    Search* m_search;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SEARCHRESULTBACKGROUNDLOADER_H_ */
diff --git a/xbmc/music/spotyXBMC/session/BackgroundThread.cpp b/xbmc/music/spotyXBMC/session/BackgroundThread.cpp
new file mode 100644
index 0000000..1f1b07f
--- /dev/null
+++ b/xbmc/music/spotyXBMC/session/BackgroundThread.cpp
@@ -0,0 +1,74 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "Session.h"
+#include "BackgroundThread.h"
+#include "../Logger.h"
+#include "../SxSettings.h"
+
+namespace addon_music_spotify {
+
+  BackgroundThread::BackgroundThread() : CThread("Spotify BackgroundThread") {
+  }
+
+  BackgroundThread::~BackgroundThread() {
+  }
+
+  void BackgroundThread::OnStartup() {
+  	Sleep(100);
+    Logger::printOut("bgthread OnStartup");
+    if (!Settings::getInstance()->init()){
+    	Logger::printOut("bgthread quiting, spotyxbmc is not enabled or the addon is missing");
+    	return;
+    }
+  	Sleep(Settings::getInstance()->getStartDelay());
+    Session::getInstance()->connect();
+    Session::getInstance()->unlock();
+    Logger::printOut("bgthread OnStartup done");
+  }
+
+  void BackgroundThread::OnExit() {
+    Logger::printOut("bgthread OnExit");
+  }
+
+  void BackgroundThread::OnException() {
+    Logger::printOut("bgthread OnException");
+  }
+
+  void BackgroundThread::Process() {
+
+    while (Session::getInstance()->isEnabled()) {
+      //Logger::printOut("bgthread Process");
+      //if the session is locked, sleep for awhile and try later again
+      if (Session::getInstance()->m_nextEvent <= 0 && Session::getInstance()->lock()) {
+        Session::getInstance()->processEvents();
+        Session::getInstance()->unlock();
+      }
+      Session::getInstance()->m_nextEvent -= 5;
+      Sleep(5);
+    }
+    Logger::printOut("exiting process thread");
+    Session::getInstance()->disConnect();
+    delete Session::getInstance();
+    Logger::printOut("exiting process thread done");
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/session/BackgroundThread.h b/xbmc/music/spotyXBMC/session/BackgroundThread.h
new file mode 100644
index 0000000..8ed6213
--- /dev/null
+++ b/xbmc/music/spotyXBMC/session/BackgroundThread.h
@@ -0,0 +1,44 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef BACKGROUNDTHREAD_H_
+#define BACKGROUNDTHREAD_H_
+
+#include "threads/Thread.h"
+
+namespace addon_music_spotify {
+
+  class BackgroundThread: public CThread {
+  public:
+    BackgroundThread();
+    virtual ~BackgroundThread();
+
+    void SleepMs(int ms){ Sleep(ms); }
+
+  private:
+    void OnStartup();
+    void OnExit();
+    void OnException(); // signal termination handler
+    void Process();
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* BACKGROUNDTHREAD_H_ */
diff --git a/xbmc/music/spotyXBMC/session/Session.cpp b/xbmc/music/spotyXBMC/session/Session.cpp
new file mode 100644
index 0000000..4ce0f0f
--- /dev/null
+++ b/xbmc/music/spotyXBMC/session/Session.cpp
@@ -0,0 +1,201 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "Session.h"
+#include "../../../../appkey.h"
+#include <string>
+
+#include "../player/PlayerHandler.h"
+#include "../artist/ArtistStore.h"
+#include "../track/TrackStore.h"
+#include "../album/AlbumStore.h"
+#include "../thumb/ThumbStore.h"
+#include "../radio/RadioHandler.h"
+#include "../search/SearchHandler.h"
+#include "../Utils.h"
+
+namespace addon_music_spotify {
+
+  Session::Session() {
+    m_isEnabled = false;
+    m_isLoggedOut = false;
+    m_session = NULL;
+    m_playlists = NULL;
+    m_nextEvent = 0;
+    m_lock = false;
+
+  }
+
+  void Session::deInit() {
+    m_isEnabled = false;
+  }
+
+  Session::~Session() {
+  }
+
+  bool Session::enable() {
+    if (isEnabled()) return true;
+
+    lock();
+    m_bgThread = new BackgroundThread();
+    m_bgThread->Create(true);
+    unlock();
+
+    return true;
+  }
+
+  bool Session::processEvents() {
+    sp_session_process_events(m_session, &m_nextEvent);
+    return true;
+  }
+
+  bool Session::connect() {
+    if (!m_session) {
+      sp_session_config config;
+      Logger::printOut("Creating session");
+	 
+      config.api_version = SPOTIFY_API_VERSION;
+      Logger::printOut("API version:");
+      char* version = new char[20];
+//      Logger::printOut(itoa(SPOTIFY_API_VERSION, version, 10));
+	  
+	  //the api is not copying the string so create a new c string
+	  CStdString location = Settings::getInstance()->getCachePath();
+	  char * cstr;
+      cstr = new char [location.size()+1];
+      strcpy (cstr, location.c_str());
+      config.cache_location = cstr;
+      config.settings_location = cstr;
+      config.tracefile = NULL;
+
+      config.application_key = g_appkey;
+      config.application_key_size = g_appkey_size;
+      config.user_agent = "spotyXBMC2";
+      config.device_id = "XBMC htpc";
+
+      sp_session_callbacks cb = m_sessionCallbacks.getCallbacks();
+      config.callbacks = &cb;
+      config.compress_playlists = true;
+      config.dont_save_metadata_for_playlists = false;
+      config.initially_unload_playlists = false;
+
+      sp_error error = sp_session_create(&config, &m_session);
+
+      if (SP_ERROR_OK != error) {
+        Logger::printOut("Failed to create session: error:");
+        Logger::printOut(sp_error_message(error));
+        m_session = NULL;
+        return false;
+      }
+
+      //set high bitrate
+      if (Settings::getInstance()->useHighBitrate()) sp_session_preferred_bitrate(m_session, SP_BITRATE_320k);
+
+      sp_session_set_connection_type(m_session, SP_CONNECTION_TYPE_WIRED);
+      sp_session_set_connection_rules(m_session, SP_CONNECTION_RULE_NETWORK);
+      sp_session_set_volume_normalization(m_session, Settings::getInstance()->useNormalization());
+
+      sp_session_login(m_session, Settings::getInstance()->getUserName().c_str(), Settings::getInstance()->getPassword().c_str(), true);
+      m_isEnabled = true;
+      Logger::printOut("Logged in, returning");
+      return true;
+    }
+    return false;
+  }
+
+  Session* Session::m_instance = 0;
+  Session *Session::getInstance() {
+    return m_instance ? m_instance : (m_instance = new Session);
+  }
+
+  bool Session::isReady() {
+    return m_isEnabled;
+  }
+
+  bool Session::disConnect() {
+  	if (m_isEnabled) {
+      Logger::printOut("Logging out");
+
+      PlayerHandler::deInit();
+      Logger::printOut("cleaned player");
+
+      //delete m_playlists;
+      //m_playlists = NULL;
+      Logger::printOut("cleaned playlists");
+
+      //SearchHandler::deInit();
+      Logger::printOut("cleaned search");
+
+      //RadioHandler::deInit();
+      Logger::printOut("cleaned radios");
+
+      //ArtistStore::deInit();
+      Logger::printOut("cleaned artists");
+
+      //AlbumStore::deInit();
+      Logger::printOut("cleaned albums");
+
+      //TrackStore::deInit();
+      Logger::printOut("cleaned tracks");
+
+      ThumbStore::deInit();
+      Logger::printOut("cleaned thumbs");
+
+      //TODO FIX THE LOGOUT... Why is it crashing on logout?
+      m_isLoggedOut = false;
+      sp_session_logout(m_session);
+
+      Logger::printOut("logged out waiting for callback");
+      while (!m_isLoggedOut) {
+        processEvents();
+      }
+      Logger::printOut("logged out");
+      sp_session_release(m_session);
+      Logger::printOut("cleaned session");
+  	}
+    return true;
+  }
+
+  void Session::loggedIn() {
+    m_playlists = new PlaylistStore();
+    //update the menu so the radio appears
+    Utils::updateMenu();
+  }
+
+  void Session::loggedOut() {
+    Logger::printOut("logged out session");
+    m_isLoggedOut = true;
+  }
+
+  bool Session::lock() {
+    if (m_lock)
+      return false;
+    else
+      m_lock = true;
+    return true;
+  }
+
+  bool Session::unlock() {
+    m_lock = false;
+    return true;
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/session/Session.h b/xbmc/music/spotyXBMC/session/Session.h
new file mode 100644
index 0000000..a822895
--- /dev/null
+++ b/xbmc/music/spotyXBMC/session/Session.h
@@ -0,0 +1,111 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SESSION_H_
+#define SESSION_H_
+
+
+namespace spotify {
+#include <libspotify/api.h>
+}
+
+using namespace spotify;
+#include "BackgroundThread.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include "../../../threads/SystemClock.h"
+#include "SessionCallbacks.h"
+#include "../playlist/PlaylistStore.h"
+#include "../SxSettings.h"
+#include "../Logger.h"
+
+
+namespace addon_music_spotify {
+
+  class PlayLists;
+  class TopLists;
+  class TrackStore;
+  class AlbumStore;
+
+  class Session {
+  public:
+
+    static Session *getInstance();
+    void deInit();
+    bool processEvents();
+
+    void notifyMainThread() {
+      m_nextEvent = 0;
+    }
+
+    void loggedIn();
+    void loggedOut();
+    bool isLoggedOut() {
+      return m_isLoggedOut;
+    }
+    bool enable();
+    bool isEnabled() {
+      return m_isEnabled;
+    }
+    bool isReady();
+
+    sp_session *getSpSession() {
+      return m_session;
+    }
+
+    PlaylistStore* getPlaylistStore() {
+      return m_playlists;
+    }
+    TopLists* getTopLists() {
+      if (m_playlists == NULL || !m_playlists->isLoaded()) return NULL;
+      return m_playlists->getTopLists();
+    }
+
+    bool lock();
+    bool unlock();
+    bool isLocked(){ return m_lock; }
+    void SleepThread(int ms){ m_bgThread->Sleep(ms); }
+
+  private:
+    Session();
+    virtual ~Session();
+
+    static Session *m_instance;
+    sp_session *m_session;
+    SessionCallbacks m_sessionCallbacks;
+
+    int m_nextEvent;
+    BackgroundThread *m_bgThread;
+    bool m_lock;
+
+    bool m_isEnabled;
+    bool m_isLoggedOut;
+
+    PlaylistStore *m_playlists;
+
+    bool connect();
+    bool disConnect();
+
+    friend class BackgroundThread;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SESSION_H_ */
diff --git a/xbmc/music/spotyXBMC/session/SessionCallbacks.cpp b/xbmc/music/spotyXBMC/session/SessionCallbacks.cpp
new file mode 100644
index 0000000..90b18b2
--- /dev/null
+++ b/xbmc/music/spotyXBMC/session/SessionCallbacks.cpp
@@ -0,0 +1,90 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "SessionCallbacks.h"
+#include "../album/AlbumStore.h"
+#include "../player/PlayerHandler.h"
+#include "Session.h"
+
+namespace addon_music_spotify {
+
+  SessionCallbacks::SessionCallbacks() {
+    m_callbacks.connection_error = &cb_connectionError;
+    m_callbacks.logged_out = &cb_loggedOut;
+    m_callbacks.message_to_user = 0;
+    m_callbacks.logged_in = &cb_loggedIn;
+    m_callbacks.notify_main_thread = &cb_notifyMainThread;
+    m_callbacks.music_delivery = &PlayerHandler::cb_musicDelivery;
+    m_callbacks.metadata_updated = 0;
+    m_callbacks.play_token_lost = 0;
+    m_callbacks.log_message = &cb_logMessage;
+    m_callbacks.end_of_track = &PlayerHandler::cb_endOfTrack;
+    m_callbacks.streaming_error = 0;
+    m_callbacks.userinfo_updated = 0;
+    m_callbacks.start_playback = 0;
+    m_callbacks.stop_playback = 0;
+    m_callbacks.get_audio_buffer_stats = 0;
+    //m_callbacks.offline_status_updated = 0;
+  }
+
+  SessionCallbacks::~SessionCallbacks() {
+  }
+
+  void SessionCallbacks::cb_connectionError(sp_session *session, sp_error error) {
+  }
+
+  void SessionCallbacks::cb_loggedIn(sp_session *session, sp_error error) {
+    if (error == SP_ERROR_OK) {
+      Session::getInstance()->loggedIn();
+      Logger::printOut("Logged in!");
+    } else {
+      Logger::printOut("Error while logging in!");
+      Logger::printOut(sp_error_message(error));
+    }
+  }
+
+  void SessionCallbacks::cb_loggedOut(sp_session *session) {
+    Logger::printOut("Logged out callback!");
+    Session::getInstance()->loggedOut();
+  }
+
+  void SessionCallbacks::cb_notifyMainThread(sp_session *session) {
+    Session::getInstance()->notifyMainThread();
+  }
+
+  void SessionCallbacks::cb_logMessage(sp_session *session, const char *data) {
+    Logger::printOut((char*) data);
+  }
+
+  void SessionCallbacks::cb_topListAritstsComplete(sp_toplistbrowse *result, void *userdata) {
+  }
+
+  void SessionCallbacks::cb_topListAlbumsComplete(sp_toplistbrowse *result, void *userdata) {
+  }
+
+  void SessionCallbacks::cb_topListTracksComplete(sp_toplistbrowse *result, void *userdata) {
+  }
+
+  void SessionCallbacks::cb_artistBrowseComplete(sp_artistbrowse *result, void *userdata) {
+  }
+
+} /* namespace addon_music_spotify */
+
diff --git a/xbmc/music/spotyXBMC/session/SessionCallbacks.h b/xbmc/music/spotyXBMC/session/SessionCallbacks.h
new file mode 100644
index 0000000..fa5be46
--- /dev/null
+++ b/xbmc/music/spotyXBMC/session/SessionCallbacks.h
@@ -0,0 +1,66 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SESSIONCALLBACKS_H_
+#define SESSIONCALLBACKS_H_
+
+#ifndef SP_CALLCONV
+#ifdef _WIN32
+#define SP_CALLCONV __stdcall
+#else
+#define SP_CALLCONV
+#endif
+#endif
+
+#include <libspotify/api.h>
+#include "../SxSettings.h"
+#include "../Logger.h"
+
+namespace addon_music_spotify {
+
+  class SxAlbum;
+
+  class SessionCallbacks {
+  public:
+    SessionCallbacks();
+    virtual ~SessionCallbacks();
+
+    static void SP_CALLCONV cb_connectionError(sp_session *session, sp_error error);
+    static void SP_CALLCONV cb_loggedIn(sp_session *session, sp_error error);
+    static void SP_CALLCONV cb_loggedOut(sp_session *session);
+    static void SP_CALLCONV cb_notifyMainThread(sp_session *session);
+    static void SP_CALLCONV cb_logMessage(sp_session *session, const char *data);
+    static void SP_CALLCONV cb_searchComplete(sp_search *search, void *userdata);
+    static void SP_CALLCONV cb_topListAritstsComplete(sp_toplistbrowse *result, void *userdata);
+    static void SP_CALLCONV cb_topListAlbumsComplete(sp_toplistbrowse *result, void *userdata);
+    static void SP_CALLCONV cb_topListTracksComplete(sp_toplistbrowse *result, void *userdata);
+    static void SP_CALLCONV cb_artistBrowseComplete(sp_artistbrowse *result, void *userdata);
+
+    sp_session_callbacks getCallbacks() {
+      return m_callbacks;
+    }
+
+  private:
+    sp_session_callbacks m_callbacks;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SESSIONCALLBACKS_H_ */
diff --git a/xbmc/music/spotyXBMC/thumb/SxThumb.cpp b/xbmc/music/spotyXBMC/thumb/SxThumb.cpp
new file mode 100644
index 0000000..9c8c5b6
--- /dev/null
+++ b/xbmc/music/spotyXBMC/thumb/SxThumb.cpp
@@ -0,0 +1,103 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "SxThumb.h"
+#include "../session/Session.h"
+#include "../Logger.h"
+#include "../Utils.h"
+#include "../../../TextureCache.h"
+#include "../../../filesystem/File.h"
+
+namespace addon_music_spotify {
+
+	using namespace std;
+
+	SxThumb::SxThumb(sp_image* image, string path) {
+		m_isLoaded = false;
+		m_image = image;
+		sp_link *link = sp_link_create_from_image(image);
+		char linkString[256];
+		sp_link_as_string(link, linkString, 256);
+		CStdString linkStringClean = linkString;
+		linkStringClean.Remove(':');
+		sp_link_release(link);
+		m_file = path + linkStringClean.c_str() + ".jpg";
+		if (XFILE::CFile::Exists(m_file, true)) {
+			m_isLoaded = true;
+		} else {
+		  CStdString pathS(m_file);
+		  bool recache;
+		  CStdString cached(CTextureCache::Get().CheckCachedImage(pathS,true,recache));
+		  if (!cached.IsEmpty() && !recache) {
+			//Logger::printOut("Thumb already in XBMC cache, no need to download again");
+			m_file = cached;
+			m_imageIsFromCache = true;
+			m_isLoaded = true;
+		  } else {
+			m_imageIsFromCache = false;
+			sp_image_add_load_callback(m_image, &cb_imageLoaded, this);
+		  }
+		}
+
+		m_references = 1;
+
+	}
+
+	SxThumb::~SxThumb() {
+		if (!m_isLoaded)
+			sp_image_remove_load_callback(m_image, &cb_imageLoaded, this);
+		sp_image_release(m_image);
+		//dont delete it from the cache
+		if (!m_imageIsFromCache)
+			Utils::removeFile(m_file.c_str());
+
+	}
+
+	void SxThumb::thumbLoaded(sp_image *image) {
+		if (sp_image_error(image) != SP_ERROR_OK) {
+			Logger::printOut("creating image error");
+			m_file = "";
+			//well its loaded but without image
+			m_isLoaded = true;
+			return;
+		}
+
+		XFILE::CFile file;
+		if (file.OpenForWrite(m_file, true)) {
+			const void *buffer;
+			size_t len;
+			buffer = sp_image_data(image, &len);
+			file.Write((const char*) buffer, len);
+			file.Close();
+		}
+
+		m_isLoaded = true;
+		//Logger::printOut("thumb downloaded");
+	}
+
+	void SxThumb::cb_imageLoaded(sp_image *image, void *userdata) {
+		SxThumb *thumb = (SxThumb*) userdata;
+		thumb->thumbLoaded(image);
+	}
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/thumb/SxThumb.h b/xbmc/music/spotyXBMC/thumb/SxThumb.h
new file mode 100644
index 0000000..b6185dc
--- /dev/null
+++ b/xbmc/music/spotyXBMC/thumb/SxThumb.h
@@ -0,0 +1,72 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SXTHUMB_H_
+#define SXTHUMB_H_
+
+#include <libspotify/api.h>
+#include <string>
+
+namespace addon_music_spotify {
+
+  using namespace std;
+
+  class ThumbStore;
+  class SxThumb {
+  public:
+
+    static void SP_CALLCONV cb_imageLoaded(sp_image *image, void *userdata);
+    void thumbLoaded(sp_image *image);
+
+    bool isLoaded() {
+      return m_isLoaded;
+    }
+
+    void addRef() {
+      m_references++;
+    }
+    int getReferencesCount() {
+      return m_references;
+    }
+
+    string getPath() {
+      return m_file;
+    }
+
+    friend class ThumbStore;
+
+  private:
+    SxThumb(sp_image* image, string path);
+    virtual ~SxThumb();
+
+    void rmRef() {
+      m_references--;
+    }
+
+    sp_image *m_image;
+    bool m_isLoaded;
+    bool m_imageIsFromCache;
+    string m_file;
+    int m_references;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SXTHUMB_H_ */
diff --git a/xbmc/music/spotyXBMC/thumb/ThumbStore.cpp b/xbmc/music/spotyXBMC/thumb/ThumbStore.cpp
new file mode 100644
index 0000000..1149926
--- /dev/null
+++ b/xbmc/music/spotyXBMC/thumb/ThumbStore.cpp
@@ -0,0 +1,223 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "ThumbStore.h"
+#include "SxThumb.h"
+#include "../SxSettings.h"
+#include "../Logger.h"
+#include "../session/Session.h"
+#include "../Utils.h"
+#include <string.h>
+#include "URL.h"
+#include "../../../filesystem/CurlFile.h"
+#include "../utils/XBMCTinyXML.h"
+#include <fstream>
+#include "../../../filesystem/File.h"
+
+using namespace XFILE;
+
+namespace addon_music_spotify {
+
+	using namespace std;
+
+	ThumbStore::ThumbStore() {
+		Logger::printOut("ThumbStore creating paths");
+		//Utils::removeDir(Settings::getInstance()->getThumbPath());
+		Utils::createDir(Settings::getInstance()->getThumbPath());
+		//Utils::removeDir(Settings::getInstance()->getArtistThumbPath());
+		//Utils::createDir(Settings::getInstance()->getArtistThumbPath());
+		Logger::printOut("ThumbStore creating paths done");
+		m_stdFanart = new CStdString(Settings::getInstance()->getFanart());
+
+		//load the fanartmap from file
+		string path = Settings::getInstance()->getCachePath() + "fanarts.txt";
+		Logger::printOut("loading fanart list");
+		ifstream file(path.c_str());
+		if (file.is_open()) {
+			while (file.good()) {
+				string name;
+				string path;
+				getline(file, name);
+				getline(file, path);
+				CStdString *fanartUrl;
+				if (path[0] == '/') {
+					// Don't create a new string if its not necessary
+					fanartUrl = m_stdFanart;
+				}
+				else {
+					fanartUrl= new CStdString(path);
+				}
+				m_fanarts.insert(stringMap::value_type(name, fanartUrl));
+			}
+		}
+		file.close();
+	}
+
+	void ThumbStore::deInit() {
+		delete m_instance;
+		Utils::removeDir(Settings::getInstance()->getThumbPath());
+	}
+
+	ThumbStore::~ThumbStore() {
+		for (thumbMap::iterator it = m_thumbs.begin(); it != m_thumbs.end(); ++it) {
+			delete it->second;
+		}
+	}
+
+	ThumbStore* ThumbStore::m_instance = 0;
+	ThumbStore *ThumbStore::getInstance() {
+		return m_instance ? m_instance : (m_instance = new ThumbStore);
+	}
+
+	SxThumb *ThumbStore::getThumb(const unsigned char* image) {
+		//check if we got the thumb
+		thumbMap::iterator it = m_thumbs.find(image);
+		SxThumb *thumb;
+		if (it == m_thumbs.end()) {
+			//we need to create it
+			//Logger::printOut("create thumb");
+			sp_image* spImage = sp_image_create(
+					Session::getInstance()->getSpSession(), (unsigned char*) image);
+
+			if (!spImage) {
+				Logger::printOut("no image");
+				return NULL;
+			}
+
+			string path = Settings::getInstance()->getThumbPath();
+			thumb = new SxThumb(spImage, path);
+			m_thumbs.insert(thumbMap::value_type(image, thumb));
+		} else {
+			//Logger::printOut("loading thumb from store");
+			thumb = it->second;
+			thumb->addRef();
+		}
+
+		return thumb;
+	}
+
+	void ThumbStore::removeThumb(const unsigned char* image) {
+		thumbMap::iterator it = m_thumbs.find(image);
+		SxThumb *thumb;
+		if (it != m_thumbs.end()) {
+			thumb = it->second;
+			if (thumb->getReferencesCount() <= 1) {
+				m_thumbs.erase(image);
+				delete thumb;
+			} else
+				thumb->rmRef();
+		}
+	}
+
+	void ThumbStore::removeThumb(SxThumb* thumb) {
+		removeThumb((const unsigned char*) thumb->m_image);
+	}
+
+	CStdString *ThumbStore::getFanart(const char *artistName) {
+
+		if (!Settings::getInstance()->getUseHTFanarts())
+			return m_stdFanart;
+
+		//Logger::printOut("Looking for fanart");
+
+		//check if we got the fanart
+		string artistNameString = artistName;
+		stringMap::iterator it = m_fanarts.find(artistNameString);
+		if (it == m_fanarts.end()) {
+			//we dont have it so we need to to a search for it
+
+			CCurlFile http;
+			CStdString artistString = artistName;
+			artistString.Replace(' ', '+');
+			CStdString urlString;
+			urlString.Format(
+					"http://htbackdrops.com/api/afb0f6cdbd412a7888005de34f86e4a5/searchXML?keywords=%s&default_operator=and&aid=1&fields=title,keywords,caption,mb_name,mb_alias&inc=keywords,caption,mb_name,mb_aliases&limit=1",
+					artistString);
+
+			CURL url(urlString);
+
+			if (http.Open(url)) {
+				Logger::printOut("Looking for fanart, need to fetch a new address");
+				Logger::printOut(artistNameString);
+				//try to parse the resulting file for a fanart image
+				CStdString data;
+				http.ReadData(data);
+
+				TiXmlDocument xmlDoc;
+				xmlDoc.Parse(data);
+				TiXmlNode* element = xmlDoc.RootElement();
+				//get the images child
+				element = element->FirstChild("images");
+				if (element) {
+
+					//get the first image child, (should only be one)
+					element = element->FirstChild();
+					if (element) {
+						//get the id
+						TiXmlNode* idElement = element->FirstChild("id");
+						CStdString id = idElement->ToElement()->GetText();
+						//get the filename
+						TiXmlNode* fileNameElement = element->FirstChild("filename");
+						CStdString name = fileNameElement->ToElement()->GetText();
+
+						CStdString *fanartUrl = new CStdString();
+						fanartUrl->Format(
+								"http://htbackdrops.com/api/afb0f6cdbd412a7888005de34f86e4a5/download/%s/fullsize/%s",
+								id, name);
+						//Logger::printOut("Adding online fanart");
+
+						m_fanarts.insert(
+								stringMap::value_type(artistNameString, fanartUrl));
+
+						//save the fanart url to the cachefile
+						string path = Settings::getInstance()->getCachePath() + "fanarts.txt";
+						Logger::printOut("saving fanart list");
+						ofstream file(path.c_str(), ios::app);
+						if (file.is_open()) {
+							file << artistNameString << "\n" << *fanartUrl << "\n";
+						}
+
+						file.close();
+
+						return fanartUrl;
+					}
+				}
+			}
+			//Logger::printOut("Adding standard fanart");
+			m_fanarts.insert(stringMap::value_type(artistNameString, m_stdFanart));
+
+			//save the fanart url to the cachefile
+			string path = Settings::getInstance()->getCachePath() + "fanarts.txt";
+			Logger::printOut("saving fanart list");
+			ofstream file(path.c_str(), ios::app);
+			if (file.is_open()) {
+				file << artistNameString << "\n" << *m_stdFanart << "\n";
+			}
+
+			file.close();
+
+			return m_stdFanart;
+		}
+		//Logger::printOut("Returning cached fanart");
+		return it->second;
+	}
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/thumb/ThumbStore.h b/xbmc/music/spotyXBMC/thumb/ThumbStore.h
new file mode 100644
index 0000000..aa60bb3
--- /dev/null
+++ b/xbmc/music/spotyXBMC/thumb/ThumbStore.h
@@ -0,0 +1,68 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef THUMBSTORE_H_
+#define THUMBSTORE_H_
+
+#ifdef _WIN32
+#include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
+#include <libspotify/api.h>
+#include <string.h>
+#include "URL.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class SxThumb;
+  class ThumbStore {
+  public:
+
+    static ThumbStore *getInstance();
+    static void deInit();
+
+    SxThumb *getThumb(const unsigned char* image);
+
+    void removeThumb(const unsigned char* image);
+    void removeThumb(SxThumb* thumb);
+
+    CStdString *getFanart(const char *artist_name);
+
+  private:
+    ThumbStore();
+    virtual ~ThumbStore();
+
+    static ThumbStore *m_instance;
+
+    typedef std::tr1::unordered_map<const unsigned char*, SxThumb*> thumbMap;
+    thumbMap m_thumbs;
+
+    typedef std::tr1::unordered_map<string, CStdString*> stringMap;
+    stringMap m_fanarts;
+
+    CStdString* m_stdFanart;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* THUMBSTORE_H_ */
diff --git a/xbmc/music/spotyXBMC/track/SxTrack.cpp b/xbmc/music/spotyXBMC/track/SxTrack.cpp
new file mode 100644
index 0000000..7f4afd7
--- /dev/null
+++ b/xbmc/music/spotyXBMC/track/SxTrack.cpp
@@ -0,0 +1,100 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include <stdio.h>
+#include <math.h>
+#include "SxTrack.h"
+#include "../Logger.h"
+#include "../session/Session.h"
+#include "../album/AlbumStore.h"
+#include "../album/SxAlbum.h"
+#include "../thumb/ThumbStore.h"
+
+namespace addon_music_spotify {
+
+  SxTrack::SxTrack(sp_track *spTrack) {
+//  Logger::printOut("creating track");
+//  Logger::printOut(sp_track_name(spSxTrack));
+    while (!sp_track_is_loaded(spTrack))
+      ;
+
+    //Logger::printOut("creating track loaded");
+
+    m_references = 1;
+    m_spTrack = spTrack;
+    m_name = sp_track_name(spTrack);
+
+    m_rating = ceil((float)sp_track_popularity(spTrack) / 10);
+
+    m_duration = 0.001 * sp_track_duration(spTrack);
+    m_trackNumber = sp_track_index(spTrack);
+
+    m_albumName = "";
+    m_albumArtistName = "";
+    m_year = 0;
+    m_thumb = NULL;
+    m_hasTHumb = false;
+
+    //load the album and release it when we have harvested all data we need
+    sp_album * album = sp_track_album(spTrack);
+    if (sp_album_is_loaded(album)) {
+      SxAlbum* sAlbum = AlbumStore::getInstance()->getAlbum(sp_track_album(spTrack), false);
+      m_thumb = sAlbum->getThumb();
+      m_albumName = sAlbum->getAlbumName();
+      m_albumArtistName = sAlbum->getAlbumArtistName();
+      m_year = sAlbum->getAlbumYear();
+      //release it again
+      AlbumStore::getInstance()->removeAlbum(sAlbum);
+
+      if (m_thumb != NULL) {
+        m_thumb->addRef();
+        m_hasTHumb = true;
+      }
+
+    } else
+      Logger::printOut("no album loaded for track");
+
+    m_artistName = sp_artist_name(sp_track_artist(spTrack, 0));
+    m_fanart = ThumbStore::getInstance()->getFanart(sp_artist_name(sp_track_artist(spTrack, 0)));
+
+    sp_link *link = sp_link_create_from_track(spTrack, 0);
+    m_uri = new char[256];
+    sp_link_as_string(link, m_uri, 256);
+    sp_link_release(link);
+
+  }
+
+  SxTrack::~SxTrack() {
+    if (m_thumb) ThumbStore::getInstance()->removeThumb(m_thumb);
+    delete m_uri;
+    sp_track_release(m_spTrack);
+  }
+
+  bool SxTrack::isLoaded() {
+    //TODO the local tracks are never reported as local....why?
+    //if (m_album && !sp_track_is_local(Session::getInstance()->getSpSession(),m_spSxTrack))
+    //  return m_album->getAlbumSxThumb()->isLoaded();
+    if (m_thumb) return m_thumb->isLoaded();
+    return true;
+  }
+
+} /* namespace addon_music_spotify */
+
diff --git a/xbmc/music/spotyXBMC/track/SxTrack.h b/xbmc/music/spotyXBMC/track/SxTrack.h
new file mode 100644
index 0000000..c840123
--- /dev/null
+++ b/xbmc/music/spotyXBMC/track/SxTrack.h
@@ -0,0 +1,132 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef SXTRACK_H_
+#define SXTRACK_H_
+
+#include <string>
+#include <libspotify/api.h>
+#include "URL.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class TrackStore;
+  class SxAlbum;
+  class SxThumb;
+  class SxTrack {
+  public:
+
+    void addRef() {
+      m_references++;
+    }
+
+    int getReferencesCount() {
+      return m_references;
+    }
+
+    bool isLoaded();
+
+    int getDuration() const {
+      return m_duration;
+    }
+
+    int getRating() const {
+      return m_rating;
+    }
+
+    int getTrackNumber() const {
+      return m_trackNumber;
+    }
+
+    sp_track* getSpTrack() {
+      return m_spTrack;
+    }
+
+    string getName() {
+      return m_name;
+    }
+
+    string getArtistName() {
+      return m_artistName;
+    }
+
+    string getAlbumName() {
+      return m_albumName;
+    }
+
+    string getAlbumArtistName() {
+      return m_albumArtistName;
+    }
+
+    int getYear() {
+      return m_year;
+    }
+
+    SxThumb* getThumb() {
+      return m_thumb;
+    }
+
+    bool hasThumb() {
+      return m_hasTHumb;
+    }
+
+    CStdString *getFanart(){
+    	return m_fanart;
+    }
+
+    const char* getUri() {
+      return m_uri;
+    }
+
+    int getDisc() {
+      return sp_track_disc(m_spTrack);
+    }
+
+    friend class TrackStore;
+
+  private:
+    SxTrack(sp_track* spTrack);
+    virtual ~SxTrack();
+
+    void rmRef() {
+      m_references--;
+    }
+
+    int m_references;
+    sp_track* m_spTrack;
+    SxThumb* m_thumb;
+    CStdString *m_fanart;
+    bool m_hasTHumb;
+    char* m_uri;
+    string m_name;
+    string m_artistName;
+    string m_albumName;
+    string m_albumArtistName;
+    int m_year;
+    int m_duration;
+    int m_rating;
+    int m_trackNumber;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* SXTRACK_H_ */
diff --git a/xbmc/music/spotyXBMC/track/TrackContainer.cpp b/xbmc/music/spotyXBMC/track/TrackContainer.cpp
new file mode 100644
index 0000000..6fea610
--- /dev/null
+++ b/xbmc/music/spotyXBMC/track/TrackContainer.cpp
@@ -0,0 +1,51 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "TrackContainer.h"
+#include "TrackStore.h"
+#include "SxTrack.h"
+
+namespace addon_music_spotify {
+
+  TrackContainer::TrackContainer() {
+    // TODO Auto-generated constructor stub
+
+  }
+
+  TrackContainer::~TrackContainer() {
+    // TODO Auto-generated destructor stub
+  }
+
+  void TrackContainer::removeAllTracks() {
+    while (!m_tracks.empty()) {
+      TrackStore::getInstance()->removeTrack(m_tracks.back());
+      m_tracks.pop_back();
+    }
+  }
+
+  bool TrackContainer::tracksLoaded() {
+    for (int i = 0; i < m_tracks.size(); i++) {
+      if (!m_tracks[i]->isLoaded()) return false;
+    }
+    return true;
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/track/TrackContainer.h b/xbmc/music/spotyXBMC/track/TrackContainer.h
new file mode 100644
index 0000000..f0a70a0
--- /dev/null
+++ b/xbmc/music/spotyXBMC/track/TrackContainer.h
@@ -0,0 +1,49 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef TRACKCONTAINER_H_
+#define TRACKCONTAINER_H_
+
+#include "SxTrack.h"
+#include <vector>
+#include "FileItem.h"
+
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  class TrackContainer {
+  public:
+    TrackContainer();
+    virtual ~TrackContainer();
+
+    virtual bool getTrackItems(CFileItemList& items) = 0;
+
+  protected:
+    vector<SxTrack*> m_tracks;
+
+    void removeAllTracks();
+    bool tracksLoaded();
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* TRACKCONTAINER_H_ */
diff --git a/xbmc/music/spotyXBMC/track/TrackStore.cpp b/xbmc/music/spotyXBMC/track/TrackStore.cpp
new file mode 100644
index 0000000..b753907
--- /dev/null
+++ b/xbmc/music/spotyXBMC/track/TrackStore.cpp
@@ -0,0 +1,98 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#include "TrackStore.h"
+#include "../Logger.h"
+#include "SxTrack.h"
+
+using namespace std;
+
+namespace addon_music_spotify {
+
+  TrackStore::TrackStore() {
+    // TODO Auto-generated constructor stub
+
+  }
+
+  void TrackStore::deInit() {
+    delete m_instance;
+  }
+
+  TrackStore::~TrackStore() {
+    for (trackMap::iterator it = m_tracks.begin(); it != m_tracks.end(); ++it) {
+      delete it->second;
+    }
+  }
+
+  TrackStore* TrackStore::m_instance = 0;
+  TrackStore *TrackStore::getInstance() {
+    return m_instance ? m_instance : (m_instance = new TrackStore);
+  }
+
+  SxTrack* TrackStore::getTrack(sp_track *spTrack) {
+    //Logger::printOut("asking store for track");
+    sp_track_add_ref(spTrack);
+    while (!sp_track_is_loaded(spTrack))
+      ;
+    //Logger::printOut("track done loading");
+    if (sp_track_error(spTrack) != SP_ERROR_OK) {
+      Logger::printOut("error in track");
+      return NULL;
+    }
+    trackMap::iterator it = m_tracks.find(spTrack);
+
+    SxTrack *track;
+    if (it == m_tracks.end()) {
+      //we need to create it
+      track = new SxTrack(spTrack);
+      m_tracks.insert(trackMap::value_type(spTrack, track));
+      //Logger::printOut("adding track to store");
+    } else {
+      //Logger::printOut("loading track from store");
+      track = it->second;
+
+      track->addRef();
+    }
+
+    return track;
+  }
+
+  void TrackStore::removeTrack(sp_track *spTrack) {
+    trackMap::iterator it = m_tracks.find(spTrack);
+    SxTrack *track;
+    if (it != m_tracks.end()) {
+      track = it->second;
+      if (track->getReferencesCount() <= 1) {
+        m_tracks.erase(spTrack);
+        // Logger::printOut("removing track!");
+        delete track;
+      } else {
+        // Logger::printOut("lower track ref!");
+        track->rmRef();
+      }
+    }
+  }
+
+  void TrackStore::removeTrack(SxTrack* track) {
+    removeTrack(track->getSpTrack());
+  }
+
+} /* namespace addon_music_spotify */
diff --git a/xbmc/music/spotyXBMC/track/TrackStore.h b/xbmc/music/spotyXBMC/track/TrackStore.h
new file mode 100644
index 0000000..eabb6ae
--- /dev/null
+++ b/xbmc/music/spotyXBMC/track/TrackStore.h
@@ -0,0 +1,57 @@
+/*
+ spotyxbmc2 - A project to integrate Spotify into XBMC
+ Copyright (C) 2011  David Erenger
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ For contact with the author:
+ david.erenger@gmail.com
+ */
+
+#ifndef TRACKSTORE_H_
+#define TRACKSTORE_H_
+
+#include <libspotify/api.h>
+#ifdef _WIN32
+#include <unordered_map>
+#else
+#include <tr1/unordered_map>
+#endif
+
+namespace addon_music_spotify {
+
+  class SxTrack;
+  class TrackStore {
+  public:
+
+    static TrackStore *getInstance();
+    static void deInit();
+
+    SxTrack* getTrack(sp_track *spTrack);
+    void removeTrack(sp_track *spTrack);
+    void removeTrack(SxTrack* track);
+
+  private:
+
+    TrackStore();
+    virtual ~TrackStore();
+
+    static TrackStore *m_instance;
+
+    typedef std::tr1::unordered_map<sp_track*, SxTrack*> trackMap;
+    trackMap m_tracks;
+  };
+
+} /* namespace addon_music_spotify */
+#endif /* ALBUMSTORE_H_ */
diff --git a/xbmc/music/windows/GUIWindowMusicBase.cpp b/xbmc/music/windows/GUIWindowMusicBase.cpp
index 2ee3313..b0ef15b 100644
--- a/xbmc/music/windows/GUIWindowMusicBase.cpp
+++ b/xbmc/music/windows/GUIWindowMusicBase.cpp
@@ -18,6 +18,9 @@
  *
  */
 
+//spotify
+#include "../spotyXBMC/Addon.music.spotify.h"
+
 #include "threads/SystemClock.h"
 #include "system.h"
 #include "GUIUserMessages.h"
@@ -1333,6 +1336,11 @@ bool CGUIWindowMusicBase::GetDirectory(const CStdString &strDirectory, CFileItem
   // add in the "New Playlist" item if we're in the playlists folder
   if ((items.GetPath() == "special://musicplaylists/") && !items.Contains("newplaylist://"))
   {
+    //spotify, this is probably not the right place to do this but cant find a better one.
+    //load up the spotify playlists
+    //TODO scan all plugins for playlists
+    g_spotify->GetPlaylists(items);
+
     CFileItemPtr newPlaylist(new CFileItem(g_settings.GetUserDataItem("PartyMode.xsp"),false));
     newPlaylist->SetLabel(g_localizeStrings.Get(16035));
     newPlaylist->SetLabelPreformated(true);
diff --git a/xbmc/music/windows/GUIWindowMusicNav.cpp b/xbmc/music/windows/GUIWindowMusicNav.cpp
index cd8dfd8..39576d0 100644
--- a/xbmc/music/windows/GUIWindowMusicNav.cpp
+++ b/xbmc/music/windows/GUIWindowMusicNav.cpp
@@ -18,6 +18,9 @@
  *
  */
 
+//spotify include spotify hooks so that we can allow toggling of stared tracks and albums
+#include "music/spotyXBMC/Addon.music.spotify.h"
+
 #include "GUIWindowMusicNav.h"
 #include "utils/FileUtils.h"
 #include "utils/URIUtils.h"
@@ -101,12 +104,15 @@ bool CGUIWindowMusicNav::OnMessage(CGUIMessage& message)
       // is this the first time the window is opened?
       if (m_vecItems->GetPath() == "?" && message.GetStringParam().IsEmpty())
         message.SetStringParam(g_settings.m_defaultMusicLibSource);
-      
-      DisplayEmptyDatabaseMessage(false); // reset message state
+	  
+	  DisplayEmptyDatabaseMessage(false); // reset message state
 
       if (!CGUIWindowMusicBase::OnMessage(message))
         return false;
 
+		//spotify, force the library to be enabled even if there are no local songs
+		/*
+
       //  base class has opened the database, do our check
       DisplayEmptyDatabaseMessage(m_musicdatabase.GetSongsCount() <= 0);
 
@@ -118,6 +124,7 @@ bool CGUIWindowMusicNav::OnMessage(CGUIMessage& message)
         SetHistoryForPath("");
         Update("");
       }
+      */
 
       return true;
     }
@@ -261,7 +268,7 @@ bool CGUIWindowMusicNav::OnClick(int iItem)
   }
   if (item->IsMusicDb() && !item->m_bIsFolder)
     m_musicdatabase.SetPropertiesForFileItem(*item);
-    
+  
   return CGUIWindowMusicBase::OnClick(iItem);
 }
 
@@ -430,6 +437,10 @@ void CGUIWindowMusicNav::GetContextButtons(int itemNumber, CContextButtons &butt
        !item->IsLastFM() && !item->m_bIsFolder)
     {
       buttons.Add(CONTEXT_BUTTON_SONG_INFO, 658);
+
+			//Spotify allow spotyxbmc to add contextbuttons to songs and albums, for now its the star/unstar capability
+			g_spotify->GetContextButtons(item, buttons);
+
     }
     else if (item->IsVideoDb())
     {
@@ -462,6 +473,8 @@ void CGUIWindowMusicNav::GetContextButtons(int itemNumber, CContextButtons &butt
        !item->IsPlugin() && !item->GetPath().Left(14).Equals("musicsearch://"))
     {
       buttons.Add(CONTEXT_BUTTON_INFO_ALL, 20059);
+			//Spotify allow spotyxbmc to add contextbuttons to songs and albums, for now its the star/unstar capability
+			g_spotify->GetContextButtons(item, buttons);
     }
 
     // enable query all artist button only in album view
@@ -557,6 +570,41 @@ bool CGUIWindowMusicNav::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
 
   switch (button)
   {
+
+  //spotify context buttons
+  case CONTEXT_BUTTON_SPOTIFY_TOGGLE_STAR_TRACK:
+  	{
+  		g_spotify->ToggleStarTrack(item);
+  		return true;
+  	}
+
+  case CONTEXT_BUTTON_SPOTIFY_TOGGLE_STAR_ALBUM:
+  	{
+  		g_spotify->ToggleStarAlbum(item);
+  		return true;
+  	}
+
+  case CONTEXT_BUTTON_SPOTIFY_BROWSE_ALBUM:
+  	{
+  		CURL url(item->GetPath());
+  		CStdString uri = url.GetFileNameWithoutPath();
+  		CStdString path;
+  		path.Format("musicdb://3/%s/", uri);
+  		Update(path);
+  		return true;
+  	}
+
+  case CONTEXT_BUTTON_SPOTIFY_BROWSE_ARTIST:
+  	{
+  		CURL url(item->GetPath());
+  		CStdString uri = url.GetFileNameWithoutPath();
+  		CStdString path;
+  		path.Format("musicdb://2/%s/", uri);
+  		Update(path);
+  		return true;
+  	}
+  //spotify end
+
   case CONTEXT_BUTTON_INFO:
     {
       if (!item->IsVideoDb())
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 8a430ad..75ed790 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -99,7 +99,7 @@ void CSettings::Initialize()
   m_bNonLinStretch = false;
 
   m_pictureExtensions = ".png|.jpg|.jpeg|.bmp|.gif|.ico|.tif|.tiff|.tga|.pcx|.cbz|.zip|.cbr|.rar|.m3u|.dng|.nef|.cr2|.crw|.orf|.arw|.erf|.3fr|.dcr|.x3f|.mef|.raf|.mrw|.pef|.sr2|.rss";
-  m_musicExtensions = ".nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.mod|.amf|.669|.dmf|.dsm|.far|.gdm|.imf|.it|.m15|.med|.okt|.s3m|.stm|.sfx|.ult|.uni|.xm|.sid|.ac3|.dts|.cue|.aif|.aiff|.wpl|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.rar|.wv|.nsf|.spc|.gym|.adx|.dsp|.adp|.ymf|.ast|.afc|.hps|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.mid|.kar|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.cm3|.cms|.dlt|.brstm|.wtv|.mka";
+  m_musicExtensions = ".spotify|.nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.mod|.amf|.669|.dmf|.dsm|.far|.gdm|.imf|.it|.m15|.med|.okt|.s3m|.stm|.sfx|.ult|.uni|.xm|.sid|.ac3|.dts|.cue|.aif|.aiff|.wpl|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.rar|.wv|.nsf|.spc|.gym|.adx|.dsp|.adp|.ymf|.ast|.afc|.hps|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.mid|.kar|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.cm3|.cms|.dlt|.brstm|.wtv|.mka";
   m_videoExtensions = ".m4v|.3g2|.3gp|.nsv|.tp|.ts|.ty|.strm|.pls|.rm|.rmvb|.m3u|.m3u8|.ifo|.mov|.qt|.divx|.xvid|.bivx|.vob|.nrg|.img|.iso|.pva|.wmv|.asf|.asx|.ogm|.m2v|.avi|.bin|.dat|.mpg|.mpeg|.mp4|.mkv|.avc|.vp3|.svq3|.nuv|.viv|.dv|.fli|.flv|.rar|.001|.wpl|.zip|.vdr|.dvr-ms|.xsp|.mts|.m2t|.m2ts|.evo|.ogv|.sdp|.avs|.rec|.url|.pxml|.vc1|.h264|.rcv|.rss|.mpls|.webm|.bdmv|.wtv";
   m_discStubExtensions = ".disc";
   // internal music extensions
